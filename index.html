
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>UNCEIR的个人博客</title>
    <meta name="author" content="David Huang" />
    <meta name="description" content="广东工业大学信息管理与信息系统专业的一名大三学生，未来想从事后端开发，请多指教。" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>UNCEIR的个人博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;UNCEIR的个人博客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>UNCEIR的个人博客</h1>
                <h3>欢迎光临www</h3>
                <h5>广东工业大学信息管理与信息系统专业的一名大三学生，未来想从事后端开发，请多指教。</h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2025/10/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9A%BE%E7%82%B901%EF%BC%9AMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
        <h2 class="post-title">消息队列难点01：MQ常见问题以及消息的可靠性</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/10/13
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="如何解决消息丢失问题"><a href="#如何解决消息丢失问题" class="headerlink" title="如何解决消息丢失问题"></a>如何解决消息丢失问题</h4><h5 id="消息可靠性问题"><a href="#消息可靠性问题" class="headerlink" title="消息可靠性问题"></a>消息可靠性问题</h5><ul>
<li><p>消息从生产者发送到交换机，再发送到对应的队列，最后才传递到消费者，有哪些导致消息丢失的情况？</p>
<ul>
<li><p>发送时丢失：</p>
<ul>
<li><p>发送的消息未到达交换机丢失</p>
</li>
<li><p>消息到达交换机后未发送到队列丢失</p>
</li>
</ul>
</li>
<li><p>队列丢失：</p>
<ul>
<li>MQ宕机了，队列中的消息丢失</li>
</ul>
</li>
<li><p>消费者丢失：</p>
<ul>
<li>消费者接受到消息未消费宕机丢失</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="如何保障消息的可靠性"><a href="#如何保障消息的可靠性" class="headerlink" title="如何保障消息的可靠性"></a>如何保障消息的可靠性</h5><ul>
<li><p><strong>消息确认机制</strong>：消费者在成功处理消息后，应该向消息队列发送确认ack信号。消息队列只有收到确认后，才会将消息从队列中移除。如果没有收到确认或者返回nack信号，消息队列可能会在一定时间后重新发送消息给其他消费者或者再次发送给同一个消费者。以 Kafka 为例，消费者通过commitSync或者commitAsync方法来提交偏移量（offset），从而确认消息的消费。</p>
</li>
<li><p><strong>消息持久化</strong>：在系统崩溃、重启或者网络故障等情况下，未处理的消息不应丢失。MQ默认情况下是用内存来存储信息，需要调用相关api来开启持久化功能。例如，像 RabbitMQ 可以通过配置将消息持久化到磁盘，通过将队列和消息都设置为持久化的方式（设置durable &#x3D; true），这样在服务器重启后，消息依然可以被重新读取和处理。</p>
</li>
<li><p><strong>消息重试策略</strong>：当消费者处理消息失败时，需要有合理的重试策略。默认情况下会不断requeue发送给消费者，给消息队列带来不必要巨大压力。可以利用spring的Retry机制进行本地重试。设置重试次数和重试间隔时间。例如，在第一次处理失败后，等待一段时间（如 5 秒）后进行第二次重试，如果重试多次（如 3 次）后仍然失败，默认情况是重试耗尽后直接丢弃信息，或者返回nack，也可以将消息发送到<strong>死信队列</strong>，以便后续人工排查或者采取其他特殊处理。</p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/10/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9A%BE%E7%82%B901%EF%BC%9AMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/09/23/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B05%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A802/">
        <h2 class="post-title">JUC并发编程05：java并发安全02</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/23
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="Java中是如何保证线程安全的"><a href="#Java中是如何保证线程安全的" class="headerlink" title="Java中是如何保证线程安全的"></a>Java中是如何保证线程安全的</h4><ul>
<li><p><strong>synchronized关键字</strong>:可以使用synchronized关键字来同步代码块或方法，确保同一时刻只有一个线程可以访问这些代码。对象锁是通过synchronized关键字锁定对象的监视器（monitor）来实现的。</p>
</li>
<li><p><strong>volatile关键字</strong>:volatile关键字用于变量，确保所有线程看到的是该变量的最新值，而不是可能存储在本地寄存器中的副本。</p>
</li>
<li><p><strong>Lock接口和ReentrantLock类</strong>:java.util.concurrent.locks.Lock接口提供了比synchronized更强大的锁定机制，ReentrantLock是一个实现该接口的例子，提供了更灵活的锁管理和更高的性能。</p>
</li>
<li><p><strong>原子类</strong>：Java并发库（java.util.concurrent.atomic）提供了原子类如AtomicInteger、AtomicLong等，这些类提供了原子操作，可以用于更新基本类型的变量而无需额外的同步。</p>
</li>
<li><p><strong>线程局部变量</strong>:ThreadLocal类可以为每个线程提供独立的变量副本，这样每个线程都拥有自己的变量，消除了竞争条件。</p>
</li>
<li><p><strong>并发集合</strong>:使用java.util.concurrent包中的线程安全集合，如ConcurrentHashMap、ConcurrentLinkedQueue等，这些集合内部已经实现了线程安全的逻辑。</p>
</li>
<li><p><strong>JUC工具类</strong>: 使用java.util.concurrent包中的一些工具类可以用于控制线程间的同步和协作。例如：Semaphore和CyclicBarrier等。</p>
</li>
</ul>
<h4 id="synchronized关键词"><a href="#synchronized关键词" class="headerlink" title="synchronized关键词"></a>synchronized关键词</h4><h5 id="synchronized关键词是什么-有什么用"><a href="#synchronized关键词是什么-有什么用" class="headerlink" title="synchronized关键词是什么?有什么用?"></a>synchronized关键词是什么?有什么用?</h5><ul>
<li><p>synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
</li>
<li><p>在 Java 早期版本中，synchronized 属于重量级锁，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
</li>
<li><p>不过，在 Java 6 之后， synchronized 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 synchronized 锁的效率提升了很多。因此， synchronized 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 synchronized 。</p>
</li>
</ul>
<h5 id="synchronized关键词的底层原理"><a href="#synchronized关键词的底层原理" class="headerlink" title="synchronized关键词的底层原理"></a>synchronized关键词的底层原理</h5><ul>
<li><p>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</p>
</li>
<li><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取而代之的是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。</p>
</li>
<li><p><strong>两个本质都是对锁监视器monitor的获取</strong></p>
</li>
</ul>
<h5 id="synchronized和volatile关键字有什么区别"><a href="#synchronized和volatile关键字有什么区别" class="headerlink" title="synchronized和volatile关键字有什么区别"></a>synchronized和volatile关键字有什么区别</h5><ul>
<li><strong>两者是互补的关系，不是对立的关系</strong><ul>
<li><p>volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。</p>
</li>
<li><p>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</p>
</li>
<li><p>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</p>
</li>
</ul>
</li>
</ul>
<h5 id="介绍ReentrantLock"><a href="#介绍ReentrantLock" class="headerlink" title="介绍ReentrantLock"></a>介绍ReentrantLock</h5><ul>
<li><p>ReentrantLock 实现了 Lock 接口，是一个可重入且独占式的锁，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>
</li>
<li><p>ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS，添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。</p>
</li>
</ul>
<h5 id="公平锁和非公平锁之间的区别"><a href="#公平锁和非公平锁之间的区别" class="headerlink" title="公平锁和非公平锁之间的区别"></a>公平锁和非公平锁之间的区别</h5><ul>
<li><p>公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p>
</li>
<li><p>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p>
</li>
</ul>
<h5 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h5><ul>
<li><p>相同点：<strong>都是可重入锁</strong>。</p>
<ul>
<li>可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</li>
</ul>
</li>
<li><p>不同点：<strong>synchronized依赖于JVM而ReentrantLock依赖于API</strong></p>
<ul>
<li><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p>
</li>
<li><p>ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
</li>
</ul>
</li>
</ul>
<h5 id="线程池常见的参数"><a href="#线程池常见的参数" class="headerlink" title="线程池常见的参数"></a>线程池常见的参数</h5><ul>
<li><p><strong>线程池的构造函数（ThreadPoolExecutor）有7个核心参数</strong>：</p>
<ul>
<li><p><strong>corePoolSize</strong> : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</p>
</li>
<li><p><strong>maximumPoolSize</strong> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</p>
</li>
<li><p><strong>workQueue</strong>: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
</li>
<li><p>keepAliveTime:当线程池中的线程数量大于 corePoolSize ，即有非核心线程（线程池中核心线程以外的线程）时，这些非核心线程空闲后不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime才会被回收销毁。</p>
</li>
<li><p>unit : keepAliveTime 参数的时间单位。</p>
</li>
<li><p>threadFactory :executor 创建新线程的时候会用到。</p>
</li>
<li><p>handler :拒绝策略（后面会单独详细介绍一下）。</p>
</li>
</ul>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/09/23/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B05%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A802/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/09/23/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B04%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/">
        <h2 class="post-title">JUC并发编程04：java并发安全01</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/23
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="JUC包下常用的类"><a href="#JUC包下常用的类" class="headerlink" title="JUC包下常用的类"></a>JUC包下常用的类</h4><ul>
<li><p>线程池相关：</p>
<ul>
<li>ThreadPoolExecutor：最核心的线程池类，用于创建和管理线程池。通过它可以灵活地配置线程池的参数，如核心线程数、最大线程数、任务队列等，以满足不同的并发处理需求。</li>
<li>Executors：线程池工厂类，提供了一系列静态方法来创建不同类型的线程池，如newFixedThreadPool（创建固定线程数的线程池）、newCachedThreadPool（创建可缓存线程池），newSingleThreadExecutor（创建单线程线程池）等，方便开发者快速创建线程池。</li>
</ul>
</li>
<li><p>并发集合类：</p>
<ul>
<li><p>ConcurrentHashMap：线程安全的哈希映射表，用于在多线程环境下高效地存储和访问键值对。它采用了分段锁等技术，允许多个线程同时访问不同的段，提高了并发性能，在高并发场景下比传统的Hashtable性能更好。</p>
</li>
<li><p>CopyOnWriteArrayList：线程安全的列表，在对列表进行修改操作时，会创建一个新的底层数组，将修改操作应用到新数组上，而读操作仍然可以在旧数组上进行，从而实现了读写分离，提高了并发读的性能，适用于读多写少的场景。</p>
</li>
</ul>
</li>
<li><p>同步工具类：</p>
<ul>
<li>CountDownLatch：允许一个或多个线程等待其他一组线程完成操作后再继续执行。它通过一个计数器来实现，计数器初始化为线程的数量，每个线程完成任务后调用countDown方法将计数器减一，当计数器为零时，等待的线程可以继续执行。常用于多个线程完成各自任务后，再进行汇总或下一步操作的场景。</li>
<li>CyclicBarrier：让一组线程互相等待，直到所有线程都到达某个屏障点后，再一起继续执行。与CountDownLatch不同的是，CyclicBarrier可以重复使用，当所有线程都通过屏障后，计数器会重置，可以再次用于下一轮的等待。适用于多个线程需要协同工作，在某个阶段完成后再一起进入下一个阶段的场景。</li>
<li>Semaphore：信号量，用于控制同时访问某个资源的线程数量。它维护了一个许可计数器，线程在访问资源前需要获取许可，如果有可用许可，则获取成功并将许可计数器减一，否则线程需要等待，直到有其他线程释放许可。常用于控制对有限资源的访问，如数据库连接池、线程池中的线程数量等。</li>
</ul>
</li>
<li><p>原子类：</p>
<ul>
<li>AtomicInteger：原子整数类，提供了对整数类型的原子操作，如自增、自减、比较并交换等。通过硬件级别的原子指令来保证操作的原子性和线程安全性，避免了使用锁带来的性能开销，在多线程环境下对整数进行计数、状态标记等操作非常方便。</li>
<li>AtomicReference：原子引用类，用于对对象引用进行原子操作。可以保证在多线程环境下，对对象的更新操作是原子性的，即要么全部成功，要么全部失败，不会出现数据不一致的情况。常用于实现无锁数据结构或需要对对象进行原子更新的场景。</li>
</ul>
</li>
</ul>
<h4 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h4><ul>
<li><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li><p>互斥条件：互斥条件是指<strong>多个线程不能同时使用同一个资源</strong>。</p>
</li>
<li><p>持有并等待条件：持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1。</p>
</li>
<li><p>不可剥夺条件：不可剥夺条件是指，当线程已经持有了资源 ，在自己使用完之前不能被其他线程获取，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</p>
</li>
<li><p>环路等待条件：环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</p>
</li>
</ul>
</li>
<li><p>例如，线程 A 持有资源 R1 并试图获取资源 R2，而线程 B 持有资源 R2 并试图获取资源 R1，此时两个线程相互等待对方释放资源，从而导致死锁。</p>
</li>
</ul>
<h5 id="如何预防和避免死锁？"><a href="#如何预防和避免死锁？" class="headerlink" title="如何预防和避免死锁？"></a>如何预防和避免死锁？</h5><ul>
<li><p>破坏死锁的产生的必要条件即可：</p>
<ul>
<li><p>1.破坏请求与保持条件：一次性申请所有的资源。</p>
</li>
<li><p>2.破坏不剥削条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
</li>
<li><p>3.破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
</li>
</ul>
</li>
<li><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行评估，使其进入安全状态。</p>
<ul>
<li>安全状态 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 &lt;P1、P2、P3…..Pn&gt; 序列为安全序列。</li>
</ul>
</li>
</ul>
<h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><h5 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a>volatile关键字的作用</h5><ul>
<li><p><strong>保证变量对所有线程的可见性</strong>。当一个变量被声明为volatile时，它会保证对这个变量的写操作会立即刷新到主存中，而对这个变量的读操作会直接从主存中读取，确保了多线程环境下对该变量访问的可见性。这意味着一个线程修改了volatile变量的值，其他线程能够立刻看到这个修改，不会受到各自线程工作内存的影响。</p>
</li>
<li><p><strong>禁止指令重排序优化</strong>。volatile关键字在Java中主要通过内存屏障来禁止特定类型的指令重排序。</p>
<ul>
<li><p><strong>写-写（Write-Write）屏障</strong>：在对volatile变量执行写操作之前，会插入一个写屏障。这确保了在该变量写操作之前的所有普通写操作都已完成，防止了这些写操作被移到volatile写操作之后。</p>
</li>
<li><p><strong>读-写（Read-Write）屏障</strong>：在对volatile变量执行读操作之后，会插入一个读屏障。它确保了对volatile变量的读操作之后的所有普通读操作都不会被提前到volatile读之前执行，保证读取到的数据是最新的。</p>
</li>
<li><p><strong>写-读（Write-Read）屏障</strong>：这是最重要的一个屏障，它发生在volatile写之后和volatile读之前。这个屏障确保了volatile写操作之前的所有内存操作（包括写操作)都不会被重排序到volatile读之后，同时也确保了volatile读操作之后的所有内存操作（包括读操作）都不会被重排序到volatile写之前。</p>
</li>
</ul>
</li>
</ul>
<h5 id="什么是悲观锁"><a href="#什么是悲观锁" class="headerlink" title="什么是悲观锁"></a>什么是悲观锁</h5><ul>
<li><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</p>
</li>
<li><p>像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
</li>
<li><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p>
</li>
</ul>
<h5 id="什么是乐观锁"><a href="#什么是乐观锁" class="headerlink" title="什么是乐观锁"></a>什么是乐观锁</h5><ul>
<li><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p>
</li>
<li><p>在 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式 CAS 实现的。</p>
</li>
<li><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p>
</li>
</ul>
<h5 id="CAS算法介绍"><a href="#CAS算法介绍" class="headerlink" title="CAS算法介绍"></a>CAS算法介绍</h5><ul>
<li><p>CAS 的全称是 Compare And Swap（比较与交换），用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>
</li>
<li><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p>
<ul>
<li>原子操作 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</li>
</ul>
</li>
<li><p>CAS 涉及到三个操作数：</p>
<ul>
<li>V：要更新的变量值(Var)</li>
<li>E：预期值(Expected)</li>
<li>N：拟写入的新值(New)</li>
</ul>
</li>
<li><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p>
</li>
</ul>
<h5 id="CAS有什么缺点"><a href="#CAS有什么缺点" class="headerlink" title="CAS有什么缺点"></a>CAS有什么缺点</h5><ul>
<li><p><strong>ABA问题</strong>：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍是A，但实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p>
<ul>
<li>Java如何解决ABA问题：Java 提供的工具类会在 CAS 操作中增加<strong>版本号（Stamp）或标记</strong>，每次修改都更新版本号，使得即使值相同也能识别变更历史。比如，可以用 AtomicStampedReference 来解决 ABA 问题，通过比对值和版本号识别ABA问题。</li>
</ul>
</li>
<li><p><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</p>
</li>
<li><p><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。</p>
</li>
</ul>
<h5 id="为什么不能所有的锁都用CAS？"><a href="#为什么不能所有的锁都用CAS？" class="headerlink" title="为什么不能所有的锁都用CAS？"></a>为什么不能所有的锁都用CAS？</h5><ul>
<li>CAS操作是基于循环重试的机制，如果CAS操作一直未能成功，线程会一直自旋重试，占用CPU资源。在高并发情况下，大量线程自旋会导致CPU资源浪费。</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/09/23/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B04%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/09/23/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03%EF%BC%9A%E6%B7%B1%E5%85%A5Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
        <h2 class="post-title">JUC并发编程03：深入Java多线程</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/23
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h5 id="sleep和wait方法区别的详解"><a href="#sleep和wait方法区别的详解" class="headerlink" title="sleep和wait方法区别的详解"></a>sleep和wait方法区别的详解</h5><ul>
<li><p><strong>所属分类的不同</strong>：sleep 是 Thread 类的静态方法，以在任何地方直接通过 Thread.sleep() 调用，无需依赖对象实例。wait 是 Object 类的实例方法，这意味着必须通过对象实例来调用。</p>
</li>
<li><p><strong>锁释放的情况</strong>：Thread.sleep() 在调用时，线程会暂停执行指定的时间，但不会释放持有的对象锁。也就是说，在 sleep 期间，其他线程无法获得该线程持有的锁。Object.wait()：调用该方法时，线程会释放持有的对象锁，进入等待状态，直到其他线程调用相同对象的 notify() 或 notifyAll() 方法唤醒它。</p>
</li>
<li><p><strong>使用条件</strong>：sleep 可在任意位置调用，无需事先获取锁。 wait 必须在同步块或同步方法内调用（即线程需持有该对象的锁），否则抛出 IllegalMonitorStateException。</p>
</li>
<li><p><strong>唤醒机制</strong>：sleep 休眠时间结束后，线程 自动恢复 到就绪状态，等待CPU调度。wait 需要其他线程调用相同对象的 notify() 或 notifyAll() 方法才能被唤醒。notify() 会随机唤醒一个在该对象上等待的线程，而 notifyAll() 会唤醒所有在该对象上等待的线程。</p>
</li>
</ul>
<h5 id="sleep会释放cpu吗？"><a href="#sleep会释放cpu吗？" class="headerlink" title="sleep会释放cpu吗？"></a>sleep会释放cpu吗？</h5><ul>
<li><p>是的，调用 Thread.sleep() 时，线程会释放 CPU，但不会释放持有的锁。</p>
<ul>
<li><strong>当线程调用 sleep() 后，会主动让出 CPU 时间片</strong>，进入 TIMED_WAITING 状态。此时操作系统会触发调度，将 CPU 分配给其他处于就绪状态的线程。这样其他线程（无论是需要同一锁的线程还是不相关线程）便有机会执行。</li>
<li>sleep() 不会释放线程已持有的任何锁（如 synchronized 同步代码块或方法中获取的锁）。此，如果有其他线程试图获取同一把锁，它们仍会被阻塞，直到原线程退出同步代码块。</li>
</ul>
</li>
</ul>
<h5 id="blocked和waiting有啥区别"><a href="#blocked和waiting有啥区别" class="headerlink" title="blocked和waiting有啥区别"></a>blocked和waiting有啥区别</h5><ul>
<li><p><strong>触发条件</strong>:线程进入BLOCKED状态通常是因为试图获取一个对象的锁（monitor lock），但该锁已经被另一个线程持有。这通常发生在尝试进入synchronized块或方法时，如果锁已被占用，则线程将被阻塞直到锁可用。线程进入WAITING状态是因为它正在等待另一个线程执行某些操作，例如调用Object.wait()方法、Thread.join()方法或LockSupport.park()方法。在这种状态下，线程将不会消耗CPU资源，并且不会参与锁的竞争。</p>
</li>
<li><p><strong>唤醒机制</strong>:当一个线程被阻塞等待锁时，一旦锁被释放，线程将有机会重新尝试获取锁。如果锁此时未被其他线程获取，那么线程可以从BLOCKED状态变为RUNNABLE状态。线程在WAITING状态中需要被显式唤醒。例如，如果线程调用了Object.wait()，，那么它必须等待另一个线程调用同一对象上的Object.notify()或Object.notifyAll()方法才能被唤醒。</p>
</li>
<li><p>所以，BLOCKED和WAITING两个状态最大的区别有两个:</p>
<ul>
<li><p>BLOCKED是锁竞争失败后被被动触发的状态，WAITING是人为的主动触发的状态。</p>
</li>
<li><p>BLOCKED的唤醒时自动触发的，而WAITING状态是必须要通过特定的方法来主动唤醒</p>
</li>
</ul>
</li>
</ul>
<h5 id="notify-和-notifyAll-的区别"><a href="#notify-和-notifyAll-的区别" class="headerlink" title="notify 和 notifyAll 的区别"></a>notify 和 notifyAll 的区别</h5><ul>
<li><p>相同点：同样是唤醒等待的线程，同样最多只有一个线程能获得锁，同样不能控制哪个线程获得锁。</p>
</li>
<li><p>不同的：</p>
<ul>
<li>方法notify：唤醒一个线程，其他线程依然处于wait的等待唤醒状态，如果被唤醒的线程结束时没调用notify，其他线程就永远没人去唤醒，只能等待超时，或者被中断。</li>
<li>方法notifyAll：所有线程退出wait的状态，开始竞争锁，但只有一个线程能抢到，这个线程执行完后，其他线程又会有一个幸运儿脱颖而出得到锁。</li>
</ul>
</li>
</ul>
<h5 id="notify-选择哪个线程"><a href="#notify-选择哪个线程" class="headerlink" title="notify 选择哪个线程"></a>notify 选择哪个线程</h5><ul>
<li><p>notify在源码的注释中说到notify选择唤醒的线程是任意的，但是依赖于具体实现的jvm。</p>
</li>
<li><p>JVM有很多实现，比较流行的就是hotspot，hotspot对notofy()的实现并不是我们以为的随机唤醒,，而是“先进先出”的顺序唤醒。</p>
</li>
</ul>
<h5 id="不同的线程之间如何通信"><a href="#不同的线程之间如何通信" class="headerlink" title="不同的线程之间如何通信"></a>不同的线程之间如何通信</h5><ul>
<li><p>共享变量是最基本的线程间通信方式。多个线程可以访问和修改同一个共享变量，从而实现信息的传递。为了保证线程安全，通常需要使用 synchronized 关键字或 volatile 关键字。</p>
</li>
<li><p>Object 类中的 wait()、notify() 和 notifyAll() 方法可以用于线程间的协作。wait() 方法使当前线程进入等待状态，notify() 方法唤醒在此对象监视器上等待的单个线程，notifyAll() 方法唤醒在此对象监视器上等待的所有线程。</p>
</li>
<li><p>java.util.concurrent.locks 包中的 Lock 和 Condition接口提供了比 synchronized 更灵活的线程间通信方式。Condition 接口的 await() 方法类似于 wait() 方法，signal() 方法类似于 notify() 方法，signalAll() 方法类似于 notifyAll() 方法。</p>
</li>
<li><p>java.util.concurrent 包中的 BlockingQueue 接口提供了线程安全的队列操作，当队列满时，插入元素的线程会被阻塞；当队列为空时，获取元素的线程会被阻塞。</p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/09/23/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03%EF%BC%9A%E6%B7%B1%E5%85%A5Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/09/22/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
        <h2 class="post-title">JUC并发编程02：Java多线程基础知识</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h4><ul>
<li><p><strong>1.继承Thread类</strong></p>
<ul>
<li><p>自定义的类继承Thread类，重写里面的run()方法，具体的run()方法中定义具体线程启动后要执行的任务，创建该类的实例后，调用start()方法启动线程。</p>
</li>
<li><p>优点：编写简单，要获取当前线程无需Thread.currentThread()来实现，直接this.即可.</p>
</li>
<li><p>缺点：已经继承了Thread类，无法再继承其他类了。</p>
</li>
</ul>
</li>
<li><p><strong>2.实现runnable接口</strong></p>
<ul>
<li><p>优点：只是实现了runnable这个接口 ，还可以继承其他类，这样就相当于多个线程可以共享该资源，适合多个线程处理同一份资源这种情况，从而可以将CPU和代码分开，形成良好的模型，较好地体现面向对象这一编程思维。</p>
</li>
<li><p>缺点：编码相对复杂，必须使用Thread.currentThread()来获取当前进程。</p>
</li>
<li><p>也需要重写run方法，同时将创建地Runnable实例作为参数传递给Thread的构造器中。</p>
</li>
</ul>
</li>
<li><p><strong>3.实现Callable接口与FutureTask</strong></p>
<ul>
<li><p>实现Callable接口与FutureTask类似于runnable接口，但Callable的call()方法可以有返回值并可以抛出异常，将它包装成一个FutureTask,因为Thread类的构造器只接受Runnable类型的参数，而FutureTask实现了Runnable接口。</p>
</li>
<li><p>优点: 与runnable接口优点特性一样。</p>
</li>
<li><p>缺点：编码相对复杂，必须使用Thread.currentThread()来获取当前进程。</p>
</li>
</ul>
</li>
<li><p><strong>4.使用线程池</strong>（Executor框架）</p>
<ul>
<li>从Java 5开始引入的java.util.concurrent.ExecutorService和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销。可以通过Executors类的静态方法创建不同类型的线程池。</li>
<li>缺点：程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。错误的配置可能导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂。</li>
<li>优点： 线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。 并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）。通过合理配置线程池大小，可以最大化CPU利用率和系统吞吐量。</li>
</ul>
</li>
</ul>
<h4 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h4><ul>
<li>线程池的好处：<ul>
<li>1.降低资源的消耗</li>
<li>2.提高响应的速度</li>
<li>3.方便管理</li>
</ul>
</li>
<li>三大方法；<ul>
<li><p>Executors.newSingleThreadExecutor()： 创建单线程的线程池，相当于创建一个固定的线程池</p>
</li>
<li><p>Executors.newFixedThreadPool(int number)： 创建固定线程数为number的线程池</p>
</li>
<li><p>Executors.newCachedThreadPool()：可伸缩的，遇强则强，遇弱则弱 ，可根据循环提交次数来改变</p>
</li>
</ul>
</li>
</ul>
<h5 id="java里面的线程和操作系统的线程一样吗"><a href="#java里面的线程和操作系统的线程一样吗" class="headerlink" title="java里面的线程和操作系统的线程一样吗"></a>java里面的线程和操作系统的线程一样吗</h5><ul>
<li>Java 底层会调用 pthread_create 来创建线程，所以本质上 java 程序创建的线程，就是和操作系统线程是一样的，是 1 对 1 的线程模型。</li>
</ul>
<h5 id="多线程安全性的体现"><a href="#多线程安全性的体现" class="headerlink" title="多线程安全性的体现"></a>多线程安全性的体现</h5><ul>
<li><p><strong>原子性</strong>：提供互斥访问，同一时刻只能有一个线程对数据进行操作，在Java中使用了atomic包和synchronized关键字来确保原子性；</p>
</li>
<li><p><strong>可见性</strong>：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性；</p>
</li>
<li><p><strong>有序性</strong>：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。</p>
</li>
</ul>
<h5 id="保证数据一致性的方案"><a href="#保证数据一致性的方案" class="headerlink" title="保证数据一致性的方案"></a>保证数据一致性的方案</h5><ul>
<li><p><strong>事务管理</strong>：使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过ACID（原子性、一致性、隔离性、持久性）属性，数据库事务可以保证数据的一致性。</p>
</li>
<li><p><strong>锁机制</strong>：使用锁来实现对共享资源的互斥访问。在 Java 中，可以使用 synchronized 关键字、ReentrantLock 或其他锁机制来控制并发访问，从而避免并发操作导致数据不一致。</p>
</li>
<li><p><strong>版本控制</strong>：通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性。</p>
</li>
</ul>
<h5 id="停止线程的方法"><a href="#停止线程的方法" class="headerlink" title="停止线程的方法"></a>停止线程的方法</h5><ul>
<li><p><strong>异常法</strong>停止：线程调用interrupt()方法后，在线程的run方法中判断当前对象的interrupted()状态，如果是中断状态则抛出异常，达到中断线程的效果。</p>
</li>
<li><p><strong>在sleep()中</strong>停止：先将线程sleep，然后调用interrupt标记中断状态，interrupt会将阻塞状态的线程中断。会抛出中断异常，达到停止线程的效果。</p>
</li>
<li><p><strong>stop()暴力</strong>停止：线程调用stop()方法会被暴力停止，方法已弃用，该方法会有不好的后果：强制让线程停止有可能使一些清理性的工作得不到完成。</p>
</li>
<li><p><strong>使用return</strong>停止线程：调用interrupt标记为中断状态后，在run方法中判断当前线程状态，如果为中断状态则return，能达到停止线程的效果。</p>
</li>
</ul>
<h5 id="调用-interrupt-是如何让线程抛出异常的"><a href="#调用-interrupt-是如何让线程抛出异常的" class="headerlink" title="调用 interrupt 是如何让线程抛出异常的?"></a>调用 interrupt 是如何让线程抛出异常的?</h5><ul>
<li>每个线程都一个与之关联的布尔属性来表示其中断状态，中断状态的初始值为false，当一个线程被其它线程调用Thread.interrupt()方法中断时，会根据实际情况做出响应。<ul>
<li>如果该线程正在执行低级别的可中断方法（如Thread.sleep()、Thread.join()或Object.wait()），则会解除阻塞并抛出InterruptedException异常。</li>
<li>否则Thread.interrupt()仅设置线程的中断状态，在该被中断的线程中稍后可通过轮询中断状态来决定是否要停止当前正在执行的任务。</li>
</ul>
</li>
</ul>
<h5 id="什么是线程上下文切换？"><a href="#什么是线程上下文切换？" class="headerlink" title="什么是线程上下文切换？"></a>什么是线程上下文切换？</h5><ul>
<li><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li><p>主动让出 CPU，比如调用了 sleep(), wait() 等。</p>
</li>
<li><p>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</p>
</li>
<li><p>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</p>
</li>
<li><p>被终止或结束运行</p>
</li>
</ul>
</li>
<li><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p>
</li>
<li><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/09/22/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/09/21/%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%AC%94%E8%AE%B006-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%98%E5%8C%96%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95%E9%97%AE%E9%A2%98/">
        <h2 class="post-title">项目一笔记06：分布式锁优化集群下秒杀下单问题</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="集群下的环境条件改变"><a href="#集群下的环境条件改变" class="headerlink" title="集群下的环境条件改变"></a>集群下的环境条件改变</h4><h5 id="synchronized的局限性"><a href="#synchronized的局限性" class="headerlink" title="synchronized的局限性"></a>synchronized的局限性</h5><ul>
<li>当出现多个服务器集群时，不同端口的服务同时进行着，多用户重复下单就会依然存在着。这是由于synchronized是本地锁，只能提供线程级别的同步，<strong>每个JVM中都有一把synchronized锁，不能跨 JVM 进行上锁</strong>，当一个线程进入被 synchronized 关键字修饰的方法或代码块时，它会尝试获取对象的内置锁（也称为监视器锁）。如果该锁没有被其他线程占用，则当前线程获得锁，可以继续执行代码；否则，当前线程将进入阻塞状态，直到获取到锁为止。而多个节点也就意味着有多个JVM进程，所以synchronized会失效！</li>
</ul>
<h5 id="使用分布式锁"><a href="#使用分布式锁" class="headerlink" title="使用分布式锁"></a>使用分布式锁</h5><ul>
<li><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁</p>
<ul>
<li>前面sychronized锁失效的原因是由于每一个JVM都有一个独立的锁监视器，用于监视当前JVM中的sychronized锁，所以无法保障多个集群下只有一个线程访问一个代码块。所以我们直接将使用一个分布锁，在整个系统的全局中设置一个锁监视器，从而保障不同节点的JVM都能够识别，从而实现集群下只允许一个线程访问一个代码块。</li>
</ul>
</li>
<li><p>分布式锁的特点：</p>
<ul>
<li><strong>多线程可见</strong></li>
<li><strong>互斥</strong>。分布式锁必须能够确保在任何时刻只有一个节点能够获得锁，其他节点需要等待。</li>
<li><strong>高可用</strong>。分布式锁应该具备高可用性，即使在网络分区或节点故障的情况下，仍然能够正常工作。（容错性）当持有锁的节点发生故障或宕机时，系统需要能够自动释放该锁，以确保其他节点能够继续获取锁。</li>
<li><strong>高性能</strong>。分布式锁需要具备良好的性能，尽可能减少对共享资源的访问等待时间，以及减少锁竞争带来的开销。</li>
<li><strong>安全性</strong>。（可重入性）如果一个节点已经获得了锁，那么它可以继续请求获取该锁而不会造成死锁。（锁超时机制）为了避免某个节点因故障或其他原因无限期持有锁而影响系统正常运行，分布式锁通常应该设置超时机制，确保锁的自动释放。</li>
</ul>
</li>
<li><p>分布式锁的常见实现方式：</p>
<ul>
<li><p><strong>基于关系数据库</strong>：可以利用数据库的事务特性和唯一索引来实现分布式锁。通过向数据库插入一条具有唯一约束的记录作为锁，其他进程在获取锁时会受到数据库的并发控制机制限制。</p>
</li>
<li><p><strong>基于缓存</strong>：使用分布式缓存服务（如Redis）提供的原子操作来实现分布式锁。通过将锁信息存储在缓存中，其他进程可以通过检查缓存中的锁状态来判断是否可以获取锁。</p>
</li>
<li><p><strong>基于ZooKeeper</strong>：ZooKeeper是一个分布式协调服务，可以用于实现分布式锁。通过创建临时有序节点，每个请求都会尝试创建一个唯一的节点，并检查自己是否是最小节点，如果是则表示获取到了锁。</p>
</li>
<li><p><strong>基于分布式算法</strong>：还可以利用一些分布式算法来实现分布式锁，例如Chubby、DLM（Distributed Lock Manager）等。这些算法通过在分布式系统中协调进程之间的通信和状态变化，实现分布式锁的功能。</p>
</li>
</ul>
</li>
<li><p>setnx指令的特点：setnx只能设置key不存在的值，值不存在设置成功，返回 1 ；值存在设置失败，返回 0</p>
</li>
</ul>
<h4 id="分布式锁对相关集群超卖问题的优化"><a href="#分布式锁对相关集群超卖问题的优化" class="headerlink" title="分布式锁对相关集群超卖问题的优化"></a>分布式锁对相关集群超卖问题的优化</h4><ul>
<li><p><strong>相关问题和对应优化</strong>：</p>
<ul>
<li>1.实现了一个简单的分布式锁，但是会存在一个问题：当线程1获取锁后，由于业务阻塞，线程1的锁超时释放了，这时候线程2趁虚而入拿到了锁，然后此时线程1业务完成了，然后把线程2刚刚获取的锁给释放了，这时候线程3又趁虚而入拿到了锁，这就导致又出现了超卖问题！（但是这个在小项目（并发数不高）中出现的概率比较低，在大型项目（并发数高）情况下是有一定概率的）<strong>因此要为分布式锁添加一个线程标识，在释放锁时判断当前锁是否是自己的锁，是自己的就直接释放，不是自己的就不释放锁，从而解决多个线程同时获得锁的情况导致出现超卖</strong>。</li>
<li>2.虽然但是，上述情况虽然得到优化了，但是在高并发量的场景下下述例子概率任然有：当线程1获取锁，执行完业务然后并且判断完当前锁是自己的锁时，但就在此时发生了阻塞，结果锁被超时释放了，线程2立马就趁虚而入了，获得锁执行业务，但就在此时线程1阻塞完成，由于已经判断过锁，已经确定锁是自己的锁了，于是直接就删除了锁，结果删的是线程2的锁，这就又导致线程3趁虚而入了，从而继续发生超卖问题。</li>
<li>问题二的解决方案：该问题的关键之处在于，无法保证<strong>判断是自己锁</strong>和<strong>释放锁</strong>之间代码的原子性。<br>那么如何保障<strong>判断是自己锁</strong>和<strong>释放锁</strong>之间代码的原子性呢？答案便是使用<strong>Lua脚本</strong>。<ul>
<li><p>那么Lua脚本是如何确保原子性的呢？Redis使用（支持）相同的Lua解释器，来运行所有的命令。Redis还保证脚本以原子方式执行：在执行脚本时，不会执行其他脚本或Redis命令。这个语义类似于MULTI（开启事务）&#x2F;EXEC（触发事务，一并执行事务中的所有命令）。从所有其他客户端的角度来看，脚本的效果要么仍然不可见，要么已经完成。Redis自身的MULTI&#x2F;EXEC 并不是传统数据库那种完整的事务——它只能把命令打包顺序执行，但不能在服务器端用“读的结果”做条件分支、不能回滚错误、也不能保证像数据库那样的隔离&#x2F;一致性语义。而使用Lua脚本可以先在脚本里先 GET，再判断，然后 SET&#x2F;DEL —— 并且整段脚本在 Redis 内被当作一个命令执行，中途不会插入别的客户端命令，因此读写判断能完全原子化。实现获取读值以后并决定后续操作的这一需求。</p>
<ul>
<li>介绍一下MULTI&#x2F;EXEC 的工作机制：</li>
<li>MULTI：告诉 Redis 开始一个事务，会把后续命令 队列化（queued），不会立即执行。</li>
<li>在事务中发出的命令，客户端会收到 QUEUED（而不是命令实际的返回值）。</li>
<li>EXEC：一次性按顺序在服务器上执行之前队列的命令。</li>
<li>特点：在 EXEC 执行期间，Redis 单线程会顺序执行这些命令，外部命令不会插入到这批命令中间。</li>
<li>重要限制：在 MULTI 阶段你无法得到某个命令的回传结果来决定下一个命令（因为所有命令只是被排队），所以客户端不能做“基于读结果做复杂逻辑然后决定后续命令”的单次事务。</li>
</ul>
</li>
<li><p><strong>注意</strong>：虽然Redis在单个Lua脚本的执行期间会暂停其他脚本和Redis命令，以确保脚本的执行是原子的，但如果Lua脚本本身出错，那么无法完全保证原子性。也就是说Lua脚本中的Redis指令出错，会发生回滚以确保原子性，但Lua脚本本身出错就无法保障原子性。</p>
</li>
<li><p>Lua脚本的代码业务：</p>
<ul>
<li>获取锁中的线程标示</li>
<li>判断是否与指定的标示（当前线程标示）一致</li>
<li>如果一致则释放锁（删除）</li>
<li>如果不一致则什么都不做</li>
<li>传值：RedisTemplate使用execute这一api调用Lua脚本</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>现在我们的分布式锁满足了：</p>
<ul>
<li><strong>多线程可见</strong>，将锁放到Redis中，所有的JVM都可以同时看到</li>
<li><strong>互斥</strong>，set ex nx指令互斥</li>
<li><strong>高可用</strong>，层层优化，即使是特别极端的情况下照样可以防止超卖</li>
<li><strong>高性能</strong>，Redis的IO速度很快，Lua脚本的性能也很快</li>
<li><strong>安全性</strong>，通过给锁夹线程标识+Lua封装Redis指令充分保障了线程安全，不那么容易出现并发安全问题，同时采用超时释放避免死锁。</li>
</ul>
</li>
<li><p>经过优化1和优化2，我们实现的分布式锁已经达到生产可用级别了，但是还不够完善，比如：</p>
<ul>
<li><p>分布式锁<strong>不可重入</strong>：不可重入是指同一线程不能重复获取同一把锁。比如，方法A中调用方法B，方法A需要获取分布式锁，方法B同样需要获取分布式锁，线程1进入方法A获取了一次锁，进入方法B又获取一次锁，由于锁不可重入，所以就会导致死锁。</p>
</li>
<li><p>分布式锁<strong>不可重试</strong>：获取锁只尝试一次就返回false，没有重试机制，这会导致数据丢失，比如线程1获取锁，然后要将数据写入数据库，但是当前的锁被线程2占用了，线程1直接就结束了而不去重试，这就导致数据发生了丢失。</p>
</li>
<li><p>分布式锁<strong>超时释放</strong>：超时释放机机制虽然一定程度避免了死锁发生的概率，但是如果业务执行耗时过长，期间锁就释放了，这样存在安全隐患。锁的有效期过短，容易出现业务没执行完就被释放，锁的有效期过长，容易出现死锁，所以这是一个大难题！（（（感觉像套娃</p>
</li>
<li><p><strong>主从一致性问题</strong>：如果Redis提供了主从集群，主从同步存在延迟，线程1获取了锁写操作写入到Redis集群中的主服务器，此时从节点还没读取主服务器就宕机了，从节点通过哨兵机制选出新的主服务器又可以获取锁，锁就相当于失效。</p>
</li>
</ul>
</li>
<li><p>因此，我们这里便使用Redssion，Redssion是一个十分成熟的Redis框架，功能也很多，比如：分布式锁和同步器、分布式对象、分布式集合、分布式服务，各种Redis实现分布式的解决方案。简而言之Redisson就是一个使用Redis解决分布式问题的方案的集合，当然它不仅仅是解决分布式相关问题，还包含其它的一些问题。（ 感觉前面白雪了，这里全封装好了）</p>
</li>
<li><p><strong>Redisson分布式锁原理</strong>:</p>
<ul>
<li><p><strong>如何解决可重入问题</strong>：利用hash结构记录线程id和重入次数。</p>
</li>
<li><p><strong>如何解决可重试问题</strong>：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制。</p>
</li>
<li><p><strong>如何解决超时续约问题</strong>：利用watchDog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间。</p>
</li>
<li><p><strong>如何解决主从一致性问题</strong>：利用Redisson的multiLock，多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功。<br>  缺陷：运维成本高、实现复杂</p>
</li>
</ul>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/09/21/%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%AC%94%E8%AE%B006-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%98%E5%8C%96%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95%E9%97%AE%E9%A2%98/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/09/21/%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%AC%94%E8%AE%B005%EF%BC%9A%E5%88%A9%E7%94%A8%E6%82%B2%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E5%8D%95%E4%BD%93%E4%B8%8B%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95%E9%97%AE%E9%A2%98/">
        <h2 class="post-title">项目一笔记05：利用悲观锁解决单体下一人一单问题</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="一人一单问题的具体描述"><a href="#一人一单问题的具体描述" class="headerlink" title="一人一单问题的具体描述"></a>一人一单问题的具体描述</h4><ul>
<li>出现这个问题的原因和前面库存为负数数的情况是一样的，线程1查询当前用户是否有订单，当前用户没有订单准备下单，此时线程2也查询当前用户是否有订单，由于线程1还没有完成下单操作，线程2同样发现当前用户未下单，也准备下单，这样明明一个用户只能下一单，结果下了两单，也就出现了超卖问题。</li>
</ul>
<h4 id="为何使用悲观锁而非乐观锁"><a href="#为何使用悲观锁而非乐观锁" class="headerlink" title="为何使用悲观锁而非乐观锁"></a>为何使用悲观锁而非乐观锁</h4><ul>
<li>乐观锁需要判断数据是否修改，而当前是判断当前是否存在，所以无法像解决库存超卖一样使用CAS机制，但是可以使用版本号法，但是版本号法需要新增一个字段（导致一定的内存消耗），所以这里为了方便，就直接演示使用悲观锁解决超卖问题。</li>
</ul>
<h5 id="具体的实现细节："><a href="#具体的实现细节：" class="headerlink" title="具体的实现细节："></a>具体的实现细节：</h5><ul>
<li><p>锁的范围尽量小。synchronized尽量锁代码块，而不是方法，锁的范围越大性能越低</p>
</li>
<li><p>锁的对象一定要是一个不变的值。我们不能直接锁 Long 类型的 userId，每请求一次都会创建一个新的 userId 对象，synchronized 要锁不变的值，所以我们要将 Long 类型的 userId 通过 toString()方法转成 String 类型的 userId，toString()方法底层（源码思路）是直接 new 一个新的String对象，显然还是在变，所以我们要使用 <strong>intern()</strong> 方法从常量池中寻找与当前 字符串值一致的字符串对象，这就能够保障一个用户 发送多次请求，每次请求的 userId 都是不变的，从而能够完成锁的效果（并行变串行）。</p>
</li>
<li><p>我们要锁住整个事务，而不是锁住事务内部的代码。如果我们锁住事务内部的代码会导致其它线程能够进入事务，当我们事务还未提交，锁一旦释放，仍然会存在超卖问题。</p>
</li>
<li><p>Spring的@Transactional注解要想事务生效，必须使用动态代理。Service中一个方法中调用另一个方法，另一个方法使用了事务，此时会导致@Transactional失效，所以我们需要创建一个代理对象，使用代理对象来调用方法。</p>
</li>
<li><p>让代理对象生效的步骤：</p>
<ul>
<li>引入AOP依赖，动态代理是AOP的常见实现之一</li>
</ul>
<hr>
<pre><code>  &lt;dependency&gt;
      &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
      &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
  &lt;/dependency&gt;
</code></pre>
</li>
</ul>
<hr>
<ul>
<li>暴露动态代理对象，默认是关闭的</li>
</ul>
<hr>
<p> @EnableAspectJAutoProxy(exposeProxy &#x3D; true)</p>
<hr>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/09/21/%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%AC%94%E8%AE%B005%EF%BC%9A%E5%88%A9%E7%94%A8%E6%82%B2%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E5%8D%95%E4%BD%93%E4%B8%8B%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95%E9%97%AE%E9%A2%98/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/09/21/%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%AC%94%E8%AE%B004%EF%BC%9A%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/">
        <h2 class="post-title">项目一笔记04：利用乐观锁解决单体下多单超卖问题</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="多单超卖问题的具体是指什么？"><a href="#多单超卖问题的具体是指什么？" class="headerlink" title="多单超卖问题的具体是指什么？"></a>多单超卖问题的具体是指什么？</h4><ul>
<li>举个例子：线程一查询库存发现充足时（假设此时库存量为1），在进行判断并扣减的执行过程中间，线程二也进行了查询库存这一业务，发现充足，而线程一判断后扣减使得库存量为0，线程二随之也扣减（按它之前查询的数据为主判断是充足的）使得库存量为-1，导致出现了多单超卖问题。两个线程是这样，多个大量线程并发就会造成库存量出现严重错误。</li>
</ul>
<h4 id="超卖问题的常见解决方案："><a href="#超卖问题的常见解决方案：" class="headerlink" title="超卖问题的常见解决方案："></a>超卖问题的常见解决方案：</h4><ul>
<li><p><strong>悲观锁</strong>，认为线程安全问题一定会发生，因此操作数据库之前都需要先获取锁，确保线程串行执行。常见的悲观锁有synchronized、lock。</p>
</li>
<li><p><strong>乐观锁</strong>，认为线程安全问题不一定发生，因此不加锁，只会在更新数据库的时候去判断有没有其它线程对数据进行修改，如果没有修改则认为是安全的，直接更新数据库中的数据即可，如果修改了则说明不安全，直接抛异常或者等待重试。常见的实现方式有：版本号法、CAS操作、乐观锁算法</p>
</li>
</ul>
<h5 id="悲观锁和乐观锁之间进行比较"><a href="#悲观锁和乐观锁之间进行比较" class="headerlink" title="悲观锁和乐观锁之间进行比较"></a>悲观锁和乐观锁之间进行比较</h5><ul>
<li><p>悲观锁比乐观锁的<strong>性能</strong>低：悲观锁需要先加锁再操作，而乐观锁不需要加锁因此通常具有更好的性能。</p>
</li>
<li><p>悲观锁比乐观锁的<strong>冲突处理能力</strong>低：悲观锁在冲突发生时直接阻塞其他线程，乐观锁则是在提交阶段检查冲突并进行重试。</p>
</li>
<li><p>悲观锁比乐观锁的<strong>并发度</strong>低：悲观锁存在锁粒度较大的问题，可能会限制并发性能；而乐观锁可以实现较高的并发度。</p>
</li>
<li><p>应用场景：两者都是互斥锁，悲观锁适合写入操作较多、冲突频繁的场景；乐观锁适合读取操作较多、冲突较少的场景。</p>
</li>
</ul>
<h4 id="悲观锁和乐观锁在该项目业务应用的侧重点："><a href="#悲观锁和乐观锁在该项目业务应用的侧重点：" class="headerlink" title="悲观锁和乐观锁在该项目业务应用的侧重点："></a>悲观锁和乐观锁在该项目业务应用的侧重点：</h4><ul>
<li>乐观锁是在下单过程中根据库存量这一字段进行CAS操作的，主要解决的是<strong>库存超卖</strong>问题</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/09/21/%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%AC%94%E8%AE%B004%EF%BC%9A%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/09/21/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E9%9B%AA%E5%B4%A9%EF%BC%8C%E5%87%BB%E7%A9%BF%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/">
        <h2 class="post-title">项目一笔记03：缓存穿透，雪崩，击穿三大问题的解决</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="缓存穿透问题的解决方案"><a href="#缓存穿透问题的解决方案" class="headerlink" title="缓存穿透问题的解决方案"></a>缓存穿透问题的解决方案</h4><ul>
<li><p><strong>缓存穿透</strong>是指请求的数据在缓存和数据库里面都不存在，缓存永远都不会生效，而这些请求都会打在数据库上，造成很大压力（可能MySQL服务会因此崩溃）</p>
</li>
<li><p>常见的解决缓存穿透问题的方案：</p>
<ul>
<li><p>缓存空对象：</p>
<ul>
<li>优点：实现简单，便于维护</li>
<li>缺点：会造成一定的内存消耗（Redis里面存了空值）,短期的不一致性。</li>
</ul>
</li>
<li><p>布隆过滤：  </p>
<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：实现复杂，存在误判可能（有穿透的风险），无法删除数据</li>
</ul>
</li>
</ul>
</li>
<li><p>上面两种方式都是被动的解决缓存穿透方案，此外我们还可以采用主动的方案预防缓存穿透，比如：增强id的复杂度避免被猜测id规律、做好数据的基础格式校验、加强用户权限校验、做好热点参数的限流。</p>
</li>
</ul>
<h4 id="缓存雪崩问题的解决方案"><a href="#缓存雪崩问题的解决方案" class="headerlink" title="缓存雪崩问题的解决方案"></a>缓存雪崩问题的解决方案</h4><ul>
<li><p><strong>缓存雪崩</strong>是指Redis里面同一时间段内大量key突然失效或者服务直接宕机而导致请求都打在数据库上</p>
</li>
<li><p>常见的解决缓存雪崩问题的方案：</p>
<ul>
<li>给不同key的TTL值添加随机值（避免同一时间失效）</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略，比如快速失败机制，让请求尽可能打不到数据库上</li>
<li>给业务添加多级缓存</li>
</ul>
</li>
</ul>
<h4 id="缓存击穿问题的解决方案"><a href="#缓存击穿问题的解决方案" class="headerlink" title="缓存击穿问题的解决方案"></a>缓存击穿问题的解决方案</h4><ul>
<li><p><strong>缓存击穿</strong>，也叫热点key问题，是指Redis当中高并发访问量并且重建业务耗时比较久的key突然失效，而这些key失效重建时请求都打在数据库上，造成巨大压力。</p>
</li>
<li><p>常见的解决缓存击穿问题的方案:</p>
<ul>
<li>互斥锁（时间换空间）              <ul>
<li>优点：内存占用小，一致性高，实现简单</li>
<li>缺点：性能较低，容易出现死锁（两个方法抢夺锁资源）</li>
</ul>
</li>
<li>设置逻辑过期时间（空间换时间）<ul>
<li>优点：性能高（其他线程不用等待这个线程一直重建完成才进行）</li>
<li>缺点：内存占用大，脏读容易出现（重建时返回过期数据）</li>
</ul>
</li>
</ul>
</li>
<li><p>两者相比较，互斥锁更加易于实现，但是容易发生死锁，且锁导致并行变成串行，导致系统性能下降，逻辑过期实现起来相较复杂，且需要耗费额外的内存，但是通过开启子线程重建缓存，使原来的同步阻塞变成异步，提高系统的响应速度，但是容易出现脏读。</p>
</li>
<li><p>基于<strong>互斥锁</strong>的具体实现思路：</p>
<ul>
<li>这里使用Redis中的setnx指令实现互斥锁，只有当值不存在时才能进行set操作</li>
<li>锁的有效期更具体业务有关，需要灵活变动，一般锁的有效期是业务处理时长10-20倍</li>
<li>线程获取锁后，还需要查询缓存（也就是所谓的双检），这样才能够真正有效保障缓存不被击穿</li>
</ul>
</li>
<li><p>基于<strong>逻辑过期</strong>的具体实现思路：所谓的逻辑过期，类似于逻辑删除，并不是真正意义上的过期，而是新增一个字段，用来标记key的过期时间，这样能能够避免key过期而被自动删除，这样数据就永不过期了，从根本上解决因为热点key过期导致的缓存击穿。一般搞活动时，比如抢优惠券，秒杀等场景，请求量比较大就可以使用逻辑过期，等活动一过就手动删除逻辑过期的数据。</p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/09/21/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E9%9B%AA%E5%B4%A9%EF%BC%8C%E5%87%BB%E7%A9%BF%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/09/21/%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%AC%94%E8%AE%B002%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/">
        <h2 class="post-title">项目一笔记02：数据一致性问题的解决</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h3 id="数据一致性问题概括"><a href="#数据一致性问题概括" class="headerlink" title="数据一致性问题概括"></a>数据一致性问题概括</h3><ul>
<li><p>在本项目当中，主要是确保MySQL和Redis之间的数据一致性，避免脏读导致信息读取不匹配所引起的一系列安全问题。为了保证一致性，因此就要为Redis选择一个最佳的缓存更新策略。</p>
</li>
<li><p>Redis常见的几种缓存更新策略：</p>
<ul>
<li>内存淘汰：默认的，相当于全自动的，不用自己去维护。当Redis发现自己内存不足的时候，会根据一定策略自动淘汰数据。这种成本最低，但是一致性最差。适用低一致性需求的常见（例如店铺类型的查询缓存）</li>
<li>超时剔除：收到给缓存数据添加TTL（过期时间），到期后Redis自动删除，属于半自动化类型。</li>
<li>主动更新：手动进行业务编码实现缓存更新功能，需求是更新数据库的同时更新缓存。</li>
</ul>
</li>
<li><p>双写方案：人工编码方式，缓存调用者在更新完数据库后再去更新缓存。使用困难，灵活度高。</p>
<ol>
<li>读取（Read）：当需要读取数据时，首先检查缓存是否存在该数据。如果缓存中存在，直接返回缓存中的数据。如果缓存中不存在，则从底层数据存储（如数据库）中获取数据，并将数据存储到缓存中，以便以后的读取操作可以更快地访问该数据。<br> 2.写入（Write）：当进行数据写入操作时，首先更新底层数据存储中的数据。然后，根据具体情况，可以选择直接更新缓存中的数据（使缓存与底层数据存储保持同步），或者是简单地将缓存中与修改数据相关的条目标记为无效状态（缓存失效），以便下一次读取时重新加载最新数据。</li>
</ol>
</li>
<li><p>使用双写方案需要考虑的两大问题：<br>  1.是使用更新缓存模式还是使用删除缓存模式？<br>  2.是先操作数据库再操作缓存还是先操作缓存再操作数据库？</p>
</li>
<li><p>更新缓存模式：每次更新数据库都更新缓存，无效写操作较多（不推荐使用）</p>
<ul>
<li>假如我们执行上百次更新数据库操作，那么就要执行上百次写入缓存的操作，而在这期间并没有查询请求，那么这上百次写入缓存的操作就显得没有什么意义。</li>
</ul>
</li>
<li><p>删除缓存模式：每次更新数据库都删除对应的缓存，当有读操作时再更新最新数据,减少了很多无效的写操作<br>（<strong>推荐使用</strong>）</p>
</li>
<li><p>先操作缓存：先删缓存，再更新数据库（不推荐使用）</p>
<ul>
<li>当线程1删除缓存到更新数据库之间的时间段，会有其它线程进来查询数据，由于没有加锁，且前面的线程将缓存删除了，这就导致请求会直接打到数据库上，给数据库带来巨大压力（缓存击穿问题）。其次，因为更新数据库这一事务操作还没完成，因此查询到的是旧数据，会读取旧数据并更新到缓存，导致数据不一致问题的出现。</li>
</ul>
</li>
<li><p>先操作数据库：先更新数据库，再删缓存（<strong>推荐使用</strong>）</p>
<ul>
<li>当线程1在查询缓存且未命中，此时线程1查询数据，查询完准备写入缓存时，由于没有加锁线程2乘虚而入，线程2在这期间对数据库进行了更新，此时线程1将旧数据返回了，出现了脏读，这个事件发生的概率很低，因为先是需要满足缓存未命中，且在写入缓存的那段事件内有一个线程进行更新操作，缓存的查询和写入很快，这段空隙时间很小，所以出现脏读现象的概率也很低。</li>
</ul>
</li>
<li><p>选择先更新数据库，再删除缓存。那么如何保证缓存与数据库的操作的原子性（同时成功或失败）？</p>
<ul>
<li>对于单体系统，将缓存与数据库操作放在同一个事务中（当前项目就是一个单体项目）</li>
<li>对于分布式系统，利用TCC（Try-Confirm-Cancel）等分布式事务方案</li>
</ul>
</li>
<li><p>缓存主动更新策略的具体编码实现：</p>
<ul>
<li>在启动类添加@EnableTransactionManagement注解开启事务</li>
<li>然后使用缓存主动更新策略（采用删除缓存模式，并且先操作数据库再操作缓存，同时添加事务保证数据库操作和缓存操作的原子性）解决数据一致性问题：</li>
</ul>
<hr>
<p>   &#x2F;**</p>
<ul>
<li>根据id查询商铺数据（查询时，重建缓存）</li>
<li></li>
<li>@param id</li>
<li>@return<br>   <em>&#x2F;<br>  @Override<br>  public Result queryById(Long id) {<br> String key &#x3D; CACHE_SHOP_KEY + id;<br> &#x2F;&#x2F; 1、从Redis中查询店铺数据<br> String shopJson &#x3D; stringRedisTemplate.opsForValue().get(key);<br> Shop shop &#x3D; null;<br> &#x2F;&#x2F; 2、判断缓存是否命中<br> if (StrUtil.isNotBlank(shopJson)) {<br> &#x2F;&#x2F; 2.1 缓存命中，直接返回店铺数据<br> shop &#x3D; JSONUtil.toBean(shopJson, Shop.class);<br> return Result.ok(shop);<br> }<br> &#x2F;&#x2F; 2.2 缓存未命中，从数据库中查询店铺数据<br> shop &#x3D; this.getById(id);<br> &#x2F;&#x2F; 4、判断数据库是否存在店铺数据<br> if (Objects.isNull(shop)) {<br> &#x2F;&#x2F; 4.1 数据库中不存在，返回失败信息<br> return Result.fail(“店铺不存在”);<br> }<br> &#x2F;&#x2F; 4.2 数据库中存在，重建缓存，并返回店铺数据<br> stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br> return Result.ok(shop);<br>  }<br>  &#x2F;</em>*<br>   *更新商铺数据（更新时，更新数据库，删除缓存）</li>
<li></li>
</ul>
<p>   *@param shop<br>   *@return<br>   *&#x2F;<br>  @Transactional<br>  @Override<br>  public Result updateShop(Shop shop) {<br>      &#x2F;&#x2F; 参数校验, 略<br>      &#x2F;&#x2F; 1、更新数据库中的店铺数据<br>      boolean f &#x3D; this.updateById(shop);<br>      if (!f){<br>          &#x2F;&#x2F; 缓存更新失败，抛出异常，事务回滚<br>          throw new RuntimeException(“数据库更新失败”);<br>      }<br>      &#x2F;&#x2F; 2、删除缓存<br>      f &#x3D; stringRedisTemplate.delete(CACHE_SHOP_KEY + shop.getId());<br>      if (!f){<br>          &#x2F;&#x2F; 缓存删除失败，抛出异常，事务回滚<br>          throw new RuntimeException(“缓存删除失败”);<br>      }<br>      return Result.ok();<br>  }</p>
</li>
</ul>
<hr>
<p>&#96;</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/09/21/%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%AC%94%E8%AE%B002%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    <a class="page-num" href="/page/2">
        2
    </a>
    
    
    
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">David Huang</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 UNCEIR的个人博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;David Huang
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
