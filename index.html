
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>UNCEIR的个人博客</title>
    <meta name="author" content="David Huang" />
    <meta name="description" content="广东工业大学信息管理与信息系统专业的一名大三学生，未来想从事后端开发，请多指教。" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>UNCEIR的个人博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;UNCEIR的个人博客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>UNCEIR的个人博客</h1>
                <h3>欢迎光临www</h3>
                <h5>广东工业大学信息管理与信息系统专业的一名大三学生，未来想从事后端开发，请多指教。</h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2025/11/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6/">
        <h2 class="post-title">大模型开发如何自学</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/11/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>入门大模型（LLM）开发，<strong>不要一上来就去啃算法数学公式</strong>（那是科学家做的事），作为开发者，你应该从<strong>应用工程（AI Engineering）</strong> 角度切入。</p>
<p>现在的 LLM 开发主要分为三个阶段：<strong>Prompt 工程</strong> -&gt; <strong>RAG（外挂知识库）</strong> -&gt; <strong>微调（Fine-tuning）</strong>。</p>
<p>以下是保姆级的快速入门路径和文档推荐：</p>
<hr>
<h3 id="第一阶段：API-调用与-Prompt-工程（先跑通）"><a href="#第一阶段：API-调用与-Prompt-工程（先跑通）" class="headerlink" title="第一阶段：API 调用与 Prompt 工程（先跑通）"></a>第一阶段：API 调用与 Prompt 工程（先跑通）</h3><p>这是最简单的入门方式。你不需要显卡，只需要会写 Python（或者 Java，但 Python 生态最强）。</p>
<ul>
<li><p><strong>核心任务</strong>：学会申请 Key，调用 API，理解 <code>System Prompt</code>（系统提示词）、<code>Temperature</code>（随机性）等参数。</p>
</li>
<li><p><strong>推荐路线</strong>：</p>
<ol>
<li><strong>选一个模型</strong>：<ul>
<li><strong>国际标准</strong>：<a target="_blank" rel="noopener" href="https://platform.openai.com/docs/introduction">OpenAI</a> (ChatGPT)。文档是行业标杆，必读。</li>
<li><strong>国内首选</strong>：<a target="_blank" rel="noopener" href="https://platform.deepseek.com/">DeepSeek (深度求索)</a> 或 <a target="_blank" rel="noopener" href="https://open.bigmodel.cn/dev/howuse/introduction">智谱 AI (ChatGLM)</a>。国内访问快，送免费额度，API 兼容 OpenAI 格式。</li>
</ul>
</li>
<li><strong>看文档</strong>：<ul>
<li><strong>OpenAI Cookbook</strong>（必看）：官方出的“食谱”，里面有大量代码示例（怎么写摘要、怎么做翻译）。</li>
<li><em>Github地址</em>：<a target="_blank" rel="noopener" href="https://github.com/openai/openai-cookbook">openai-cookbook</a></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>你需要掌握的概念</strong>：</p>
<ul>
<li><strong>Prompt</strong>：你对 AI 说的话。</li>
<li><strong>Token</strong>：计费单位（约等于字数）。</li>
<li><strong>Context Window</strong>：上下文窗口（AI 能记住多少之前的对话）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第二阶段：应用框架开发（LangChain-LlamaIndex）"><a href="#第二阶段：应用框架开发（LangChain-LlamaIndex）" class="headerlink" title="第二阶段：应用框架开发（LangChain&#x2F;LlamaIndex）"></a>第二阶段：应用框架开发（LangChain&#x2F;LlamaIndex）</h3><p>当你觉得直接调 API 处理复杂逻辑很麻烦（比如要处理长文本、要联网搜索），你就需要框架了。</p>
<ul>
<li><p><strong>核心工具</strong>：</p>
<ol>
<li><strong>LangChain</strong>：目前最火的 LLM 开发框架。它把“读文件”、“切分文本”、“存数据库”、“调大模型”串成了一条链。<ul>
<li><em>缺点</em>：文档有点乱，概念多。</li>
<li><em>文档</em>：<a target="_blank" rel="noopener" href="https://python.langchain.com/docs/get_started/introduction">LangChain Python Docs</a></li>
</ul>
</li>
<li><strong>LlamaIndex</strong>：如果你主要想做“<strong>把我的私有数据喂给 AI</strong>”这件事，用它更简单高效。<ul>
<li><em>文档</em>：<a target="_blank" rel="noopener" href="https://docs.llamaindex.ai/en/stable/">LlamaIndex Docs</a></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>必做 Demo</strong>：写一个“<strong>基于本地 PDF 文档的问答机器人</strong>”。这能让你学会目前最主流的 <strong>RAG (检索增强生成)</strong> 技术。</p>
</li>
</ul>
<p>你看得很准！你列出的这套技术栈（<strong>LangGraph + DeepSeek&#x2F;GPT + Chroma&#x2F;Milvus + BGE-M3</strong>）是目前构建<strong>生产级、复杂 Agent 应用</strong>的**“黄金标准”**。</p>
<p>这套组合已经脱离了简单的“玩具 Demo”阶段，能够真正解决工业界遇到的痛点（如：逻辑死循环、上下文丢失、只会单向执行不懂反思）。</p>
<p>以下是对你这套技术栈的<strong>深度解析</strong>和<strong>落地建议</strong>，帮助你把它们串起来：</p>
<hr>
<h3 id="1-核心编排：LangGraph-Agent-的大脑"><a href="#1-核心编排：LangGraph-Agent-的大脑" class="headerlink" title="1. 核心编排：LangGraph (Agent 的大脑)"></a>1. 核心编排：LangGraph (Agent 的大脑)</h3><blockquote>
<p><strong>你的评价非常到位：</strong> 相比 LangChain 传统的 Chain（单向链表），LangGraph 是图（Graph）。</p>
</blockquote>
<ul>
<li><strong>为什么要换 LangGraph？</strong><ul>
<li><strong>有状态（Stateful）</strong>：传统的 Chain 跑完就忘。LangGraph 有一个全局的 <code>State</code>（状态对象），所有节点都能读写这个状态。这就像给了 AI 一个“短期记忆本”，它知道自己刚才查了什么，现在缺什么。</li>
<li><strong>循环与反思（Cyclic &amp; Reflection）</strong>：这是最强的点。<ul>
<li><em>Chain</em>：输入 -&gt; 步骤A -&gt; 步骤B -&gt; 结束。（一条路走到黑）</li>
<li><em>Graph</em>：输入 -&gt; 步骤A -&gt; 检查结果 -&gt; <strong>觉得不行</strong> -&gt; <strong>回到步骤A重做</strong> -&gt; 结束。</li>
</ul>
</li>
<li><strong>应用场景</strong>：比如写代码助手。写代码 -&gt; 运行报错 -&gt; 读取错误 -&gt; <strong>跳回写代码步骤修正</strong> -&gt; 再运行 -&gt; 成功。</li>
</ul>
</li>
</ul>
<h3 id="2-模型层：LLM-接口-动力源"><a href="#2-模型层：LLM-接口-动力源" class="headerlink" title="2. 模型层：LLM 接口 (动力源)"></a>2. 模型层：LLM 接口 (动力源)</h3><blockquote>
<p><strong>推荐</strong>：DeepSeek (性价比之王) &#x2F; GPT-4o (逻辑天花板)</p>
</blockquote>
<ul>
<li><strong>对接建议</strong>：<ul>
<li>虽然 LangChain 有封装好的 ChatOpenAI 类，但在 LangGraph 中，通常直接调用这些模型来做<strong>决策（Router）</strong>。</li>
<li><strong>工具调用（Function Calling）</strong>：这是 Agent 的核心。DeepSeek V3&#x2F;R1 和 GPT-4 的 Function Calling 能力最强，能精准地输出 JSON 格式来告诉程序该去查数据库还是该去搜索。</li>
</ul>
</li>
</ul>
<h3 id="3-RAG-核心：Embedding-与-向量库-海马体"><a href="#3-RAG-核心：Embedding-与-向量库-海马体" class="headerlink" title="3. RAG 核心：Embedding 与 向量库 (海马体)"></a>3. RAG 核心：Embedding 与 向量库 (海马体)</h3><h4 id="Embedding-模型：BGE-M3-vs-M3E"><a href="#Embedding-模型：BGE-M3-vs-M3E" class="headerlink" title="Embedding 模型：BGE-M3 vs M3E"></a>Embedding 模型：BGE-M3 vs M3E</h4><p>你提到的 <code>bge-m3</code> 是目前的<strong>中文最强开源 Embedding</strong>（智源出品）。</p>
<ul>
<li><strong>BGE-M3 的优势</strong>：它支持 <strong>混合检索</strong>（Dense + Sparse）。<ul>
<li><em>Dense (稠密)</em>：懂语义（比如搜“苹果”，它知道你想找“水果”或“手机”）。</li>
<li><em>Sparse (稀疏)</em>：懂关键词匹配（类似倒排索引，精准匹配专有名词）。</li>
<li><strong>落地建议</strong>：如果你的机器跑得动，<strong>无脑上 BGE-M3</strong>。如果资源受限（比如只有 CPU），用 <code>m3e-base</code> 或 <code>bge-small-zh</code>。</li>
</ul>
</li>
</ul>
<h4 id="向量数据库：Chroma-vs-Milvus"><a href="#向量数据库：Chroma-vs-Milvus" class="headerlink" title="向量数据库：Chroma vs Milvus"></a>向量数据库：Chroma vs Milvus</h4><ul>
<li><strong>ChromaDB</strong>：<ul>
<li><em>优点</em>：<code>pip install chromadb</code> 就能用，无需 Docker，数据存在本地文件，极其适合开发测试和单机应用。</li>
<li><em>缺点</em>：不支持分布式，数据量百万级以上性能下降。</li>
</ul>
</li>
<li><strong>Milvus</strong>：<ul>
<li><em>优点</em>：云原生，Kubernetes 友好，亿级数据毫秒响应，大厂标配。</li>
<li><em>缺点</em>：部署重（依赖 MinIO, Etcd 等组件）。</li>
</ul>
</li>
<li><strong>选型建议</strong>：<strong>开发阶段用 Chroma，上线前看数据量，超过 500万条再迁移到 Milvus。</strong></li>
</ul>
<hr>
<h3 id="4-实战架构：如何把它们串起来？"><a href="#4-实战架构：如何把它们串起来？" class="headerlink" title="4. 实战架构：如何把它们串起来？"></a>4. 实战架构：如何把它们串起来？</h3><p>假设你要做一个**“智能课程推荐助手”**，流程如下：</p>
<h4 id="第一步：定义状态-State"><a href="#第一步：定义状态-State" class="headerlink" title="第一步：定义状态 (State)"></a>第一步：定义状态 (State)</h4><p>在 LangGraph 中，先定义一个 Python 类（TypedDict）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgentState</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    query: <span class="built_in">str</span>          <span class="comment"># 用户原始问题</span></span><br><span class="line">    user_profile: <span class="built_in">dict</span>  <span class="comment"># 用户画像</span></span><br><span class="line">    documents: <span class="type">List</span>[<span class="built_in">str</span>]<span class="comment"># 查到的课程资料</span></span><br><span class="line">    answer: <span class="built_in">str</span>         <span class="comment"># 最终回复</span></span><br><span class="line">    retry_count: <span class="built_in">int</span>    <span class="comment"># 重试次数（防止死循环）</span></span><br></pre></td></tr></table></figure>

<h4 id="第二步：定义节点-Nodes"><a href="#第二步：定义节点-Nodes" class="headerlink" title="第二步：定义节点 (Nodes)"></a>第二步：定义节点 (Nodes)</h4><p>每个节点是一个函数，接收 State，修改 State，返回 State。</p>
<ol>
<li><strong>Node_Retrieve_User</strong>：去数据库查这个用户是谁（初学者还是专家？）。</li>
<li><strong>Node_Search_Course</strong>：拿着用户画像 + 问题，去 <strong>ChromaDB</strong> (用 BGE-M3 向量化) 检索相关课程。</li>
<li><strong>Node_Generate</strong>：调用 <strong>DeepSeek</strong>，根据资料生成回答。</li>
<li><strong>Node_Reflect (反思)</strong>：让 LLM 自己检查回答是否解决了用户问题。如果没解决，修改搜索关键词。</li>
</ol>
<h4 id="第三步：构建图-Graph-边缘-Edges"><a href="#第三步：构建图-Graph-边缘-Edges" class="headerlink" title="第三步：构建图 (Graph) &amp; 边缘 (Edges)"></a>第三步：构建图 (Graph) &amp; 边缘 (Edges)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> StateGraph, END</span><br><span class="line"></span><br><span class="line">workflow = StateGraph(AgentState)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加节点</span></span><br><span class="line">workflow.add_node(<span class="string">&quot;查用户&quot;</span>, retrieve_user_node)</span><br><span class="line">workflow.add_node(<span class="string">&quot;查课程&quot;</span>, search_course_node)</span><br><span class="line">workflow.add_node(<span class="string">&quot;生成&quot;</span>, generate_node)</span><br><span class="line">workflow.add_node(<span class="string">&quot;反思&quot;</span>, reflect_node)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义流程（边缘）</span></span><br><span class="line">workflow.set_entry_point(<span class="string">&quot;查用户&quot;</span>)</span><br><span class="line">workflow.add_edge(<span class="string">&quot;查用户&quot;</span>, <span class="string">&quot;查课程&quot;</span>)</span><br><span class="line">workflow.add_edge(<span class="string">&quot;查课程&quot;</span>, <span class="string">&quot;生成&quot;</span>)</span><br><span class="line">workflow.add_edge(<span class="string">&quot;生成&quot;</span>, <span class="string">&quot;反思&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重点：条件边（Conditional Edge）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_quality</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">if</span> state[<span class="string">&#x27;answer&#x27;</span>] == <span class="string">&quot;不知道&quot;</span> <span class="keyword">and</span> state[<span class="string">&#x27;retry_count&#x27;</span>] &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;查课程&quot;</span> <span class="comment"># 没查到，换个词跳回去重查</span></span><br><span class="line">    <span class="keyword">return</span> END <span class="comment"># 查到了，或者重试次数用完了，结束</span></span><br><span class="line"></span><br><span class="line">workflow.add_conditional_edges(</span><br><span class="line">    <span class="string">&quot;反思&quot;</span>,</span><br><span class="line">    check_quality,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;查课程&quot;</span>: <span class="string">&quot;查课程&quot;</span>,</span><br><span class="line">        END: END</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app = workflow.<span class="built_in">compile</span>()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-总结你的学习路径"><a href="#5-总结你的学习路径" class="headerlink" title="5. 总结你的学习路径"></a>5. 总结你的学习路径</h3><p>既然你已经到了这个阶段，接下来的重点不再是 API 怎么调，而是<strong>图的设计</strong>：</p>
<ol>
<li><strong>文档</strong>：<ul>
<li>去啃 <strong>LangGraph 官方文档</strong>（非常新，更新很快）。</li>
<li>去 HuggingFace 搜 <strong>BAAI&#x2F;bge-m3</strong> 查看它的用法。</li>
</ul>
</li>
<li><strong>实操</strong>：<ul>
<li>用 Docker 部署一个 Milvus（虽然重，但你需要熟悉一下 docker-compose）。</li>
<li>写一个简单的 <code>CRAG</code> (Corrective RAG) 架构：检索 -&gt; 评分 -&gt; (如果分低) -&gt; 联网搜索 -&gt; 生成。</li>
</ul>
</li>
</ol>
<p>这套架构学会了，你就是市面上稀缺的<strong>高级 AI 应用工程师</strong>。加油！</p>
<hr>
<h3 id="第三阶段：本地部署开源模型（Ollama）"><a href="#第三阶段：本地部署开源模型（Ollama）" class="headerlink" title="第三阶段：本地部署开源模型（Ollama）"></a>第三阶段：本地部署开源模型（Ollama）</h3><p>如果你不想花钱调 API，或者数据由于隐私不能上网，你需要在自己电脑上跑模型。</p>
<ul>
<li><p><strong>神器推荐：Ollama</strong></p>
<ul>
<li>这是目前最无脑、最简单的本地大模型运行工具。</li>
<li><em>操作</em>：下载安装 -&gt; 终端输入 <code>ollama run llama3</code> -&gt; 完事。</li>
<li><em>文档</em>：<a target="_blank" rel="noopener" href="https://github.com/ollama/ollama">Ollama Github</a></li>
</ul>
</li>
<li><p><strong>模型推荐</strong>：</p>
<ul>
<li><code>Llama 3</code> (Meta出品，开源最强)</li>
<li><code>Qwen</code> (通义千问，中文能力极强)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第四阶段：系统学习资源（最好的教程）"><a href="#第四阶段：系统学习资源（最好的教程）" class="headerlink" title="第四阶段：系统学习资源（最好的教程）"></a>第四阶段：系统学习资源（最好的教程）</h3><p>不要去B站乱翻视频，直接看吴恩达（Andrew Ng）的 DeepLearning.AI 出的短课程，<strong>免费、权威、极简</strong>（每门课只有 1-2 小时）。</p>
<ol>
<li><strong>入门必看</strong>：<ul>
<li><strong>ChatGPT Prompt Engineering for Developers</strong> (面向开发者的提示工程) —— 教你怎么写好 Prompt。</li>
</ul>
</li>
<li><strong>进阶必看</strong>：<ul>
<li><strong>LangChain for LLM Application Development</strong> —— LangChain 作者亲自教你怎么用。</li>
<li><strong>Building Systems with the ChatGPT API</strong> —— 教怎么构建系统。</li>
</ul>
</li>
</ol>
<ul>
<li><em>观看地址</em>：DeepLearning.AI 官网（英文），或者 B站搜索“吴恩达 大模型”有汉化搬运。</li>
</ul>
<hr>
<h3 id="总结：你的行动清单"><a href="#总结：你的行动清单" class="headerlink" title="总结：你的行动清单"></a>总结：你的行动清单</h3><ol>
<li><strong>第一天</strong>：注册一个 DeepSeek 或 OpenAI 账号，用 Python 写几行代码调用 API，让它给你讲个笑话。（感受 Input&#x2F;Output）。</li>
<li><strong>第二天</strong>：安装 <strong>Ollama</strong>，在本地跑一个 <code>qwen2:7b</code>，体验离线对话。</li>
<li><strong>第三天</strong>：看吴恩达的《Prompt Engineering》课程。</li>
<li><strong>第四天</strong>：学习 <strong>LangChain</strong>，尝试写一个脚本，让 AI 读取你的一个 <code>.txt</code> 笔记并总结内容。</li>
</ol>
<p><strong>避坑指南</strong>：</p>
<ul>
<li><strong>别去学怎么训练模型（Pre-training）</strong>，那需要几百万的显卡。</li>
<li><strong>别去死磕数学原理</strong>，Transformer 的架构图看懂个大概就行，把它当成一个“黑盒函数”去调用。</li>
<li><strong>文档优先看英文</strong>，AI 技术迭代太快，中文文档通常是滞后的。</li>
</ul>
<p>需要具体的 Python 代码示例（比如怎么调用 API）吗？我可以写给你。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/11/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/11/29/%E5%85%AB%E8%82%A1%E6%96%B9%E5%90%9102/">
        <h2 class="post-title">八股方向02</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/11/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <hr>
<h1 id="🚀-Java-后端高级面试备战指南：从“知道”到“精通”"><a href="#🚀-Java-后端高级面试备战指南：从“知道”到“精通”" class="headerlink" title="🚀 Java 后端高级面试备战指南：从“知道”到“精通”"></a>🚀 Java 后端高级面试备战指南：从“知道”到“精通”</h1><p>这份清单针对中高级开发岗位，重点在于<strong>源码理解</strong>、<strong>底层原理</strong>以及<strong>高并发场景下的实战解决方案</strong>。请务必按照“深挖&#x2F;避坑”部分的提示进行针对性复习。</p>
<h2 id="🏗️-一、-Java-基础：地基要稳"><a href="#🏗️-一、-Java-基础：地基要稳" class="headerlink" title="🏗️ 一、 Java 基础：地基要稳"></a>🏗️ 一、 Java 基础：地基要稳</h2><blockquote>
<p><strong>核心重点</strong>：HashMap 源码、线程池参数与运行流程。</p>
</blockquote>
<h3 id="🔍-深挖与避坑"><a href="#🔍-深挖与避坑" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>HashMap</strong>：<ul>
<li><strong>结构演变</strong>：熟背 JDK 1.7（数组+链表）与 1.8（数组+链表+红黑树）的区别。</li>
<li><strong>扩容机制</strong>：重点理解 1.8 的优化（利用高位 0&#x2F;1 判断，无需重新计算 Hash）。</li>
<li><strong>线程不安全</strong>：1.7 的死循环问题，1.8 的数据覆盖问题。</li>
</ul>
</li>
<li><strong>线程池 (ThreadPool)</strong>：<ul>
<li><strong>参数配置</strong>：7 大参数必背。</li>
<li><strong>场景化设置</strong>：<ul>
<li><strong>CPU 密集型</strong>：<code>CPU核数 + 1</code>。</li>
<li><strong>IO 密集型</strong>：<code>CPU核数 * 2</code> 或 <code>CPU / (1 - 阻塞系数)</code>。</li>
</ul>
</li>
<li><strong>拒绝策略</strong>：默认 <code>AbortPolicy</code>，生产环境如何自定义？</li>
<li><strong>队列区别</strong>：<code>ArrayBlockingQueue</code> (有界) vs <code>LinkedBlockingQueue</code> (默认无界，易 OOM) 的区别是必考点。</li>
</ul>
</li>
</ul>
<h2 id="⚡-二、-JUC-并发编程-：高薪分水岭"><a href="#⚡-二、-JUC-并发编程-：高薪分水岭" class="headerlink" title="⚡ 二、 JUC (并发编程)：高薪分水岭"></a>⚡ 二、 JUC (并发编程)：高薪分水岭</h2><blockquote>
<p><strong>核心重点</strong>：ReentrantLock 源码、AQS 核心原理。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-1"><a href="#🔍-深挖与避坑-1" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>AQS (AbstractQueuedSynchronizer)</strong>：<ul>
<li>JUC 的基石。必须理解 <strong>state 变量</strong>（锁状态）和 <strong>CLH 队列</strong>（双向链表，存储等待线程）的工作流程。</li>
</ul>
</li>
<li><strong>Synchronized vs Lock</strong>：<ul>
<li>不仅是 API 区别，要懂底层：<code>synchronized</code> 基于对象头 Mark Word 和 Monitor；Lock 是 Java 层面实现。</li>
</ul>
</li>
<li><strong>原子类与 CAS</strong>：<ul>
<li><strong>ABA 问题</strong>：值变了又变回来。解决方案：<strong>版本号</strong>或<strong>时间戳</strong>（<code>AtomicStampedReference</code>）。</li>
</ul>
</li>
</ul>
<h2 id="☕-三、-JVM：进阶必懂"><a href="#☕-三、-JVM：进阶必懂" class="headerlink" title="☕ 三、 JVM：进阶必懂"></a>☕ 三、 JVM：进阶必懂</h2><blockquote>
<p><strong>核心重点</strong>：类加载（双亲委派）、内存模型、GC。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-2"><a href="#🔍-深挖与避坑-2" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>GC (垃圾回收)</strong>：<em>(必补项)</em><ul>
<li><strong>算法</strong>：复制算法（新生代）、标记-整理（老年代）。</li>
<li><strong>收集器</strong>：CMS 和 G1 的区别（重点掌握 G1 的 Region 概念）。</li>
</ul>
</li>
<li><strong>OOM 排查实战</strong>：<ul>
<li>是否使用过 <code>jstat</code>, <code>jmap</code>, <code>MAT</code> 工具？</li>
<li>分析 Dump 文件的流程（定位大对象、泄漏点）是面试极大的加分项。</li>
</ul>
</li>
</ul>
<h2 id="🌱-四、-Spring-Boot：框架原理"><a href="#🌱-四、-Spring-Boot：框架原理" class="headerlink" title="🌱 四、 Spring Boot：框架原理"></a>🌱 四、 Spring Boot：框架原理</h2><blockquote>
<p><strong>核心重点</strong>：AOP&#x2F;IOC 原理、三级缓存、自动配置。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-3"><a href="#🔍-深挖与避坑-3" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>三级缓存</strong>：<ul>
<li>核心目的：解决<strong>循环依赖</strong>。</li>
<li>难点：为什么需要第三级？（为了在对象实例化后、初始化前，提前暴露 <strong>AOP 代理对象</strong>）。</li>
</ul>
</li>
<li><strong>Bean 的生命周期</strong>：<ul>
<li>流程：<code>实例化</code> -&gt; <code>属性赋值</code> -&gt; <code>初始化</code> -&gt; <code>销毁</code>。</li>
<li>关键点：<code>BeanPostProcessor</code> 在 AOP 中的作用。</li>
</ul>
</li>
<li><strong>事务失效场景</strong>：<ul>
<li>类内部自调用（<code>this.method()</code> 不走代理）。</li>
<li>方法非 <code>public</code>。</li>
<li>异常被 <code>try-catch</code> 吞掉，未抛出。</li>
</ul>
</li>
</ul>
<h2 id="💾-五、-数据库-MySQL-：重中之重"><a href="#💾-五、-数据库-MySQL-：重中之重" class="headerlink" title="💾 五、 数据库 (MySQL)：重中之重"></a>💾 五、 数据库 (MySQL)：重中之重</h2><blockquote>
<p><strong>核心重点</strong>：索引原理、事务 (MVCC)、三大日志、SQL 调优。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-4"><a href="#🔍-深挖与避坑-4" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>索引</strong>：<ul>
<li><strong>数据结构</strong>：为什么选 B+ 树（层高低、范围查询好）而不是 B 树？</li>
<li><strong>回表</strong>：聚簇索引 vs 非聚簇索引的区别。</li>
<li><strong>失效</strong>：最左前缀原则、索引列计算等场景。</li>
</ul>
</li>
<li><strong>MVCC (多版本并发控制)</strong>：<ul>
<li>不要死背定义。核心是 <strong>Read View (读视图)</strong> + <strong>Undo Log 版本链</strong> 如何配合实现“可重复读”隔离级别。</li>
</ul>
</li>
<li><strong>三大日志</strong>：<ul>
<li><strong>Binlog</strong>：主从复制，归档。</li>
<li><strong>Redo Log</strong>：物理日志，保证持久性 (Crash-safe)。</li>
<li><strong>Undo Log</strong>：逻辑日志，保证原子性 (回滚)。</li>
</ul>
</li>
</ul>
<h2 id="🚀-六、-Redis：性能利器"><a href="#🚀-六、-Redis：性能利器" class="headerlink" title="🚀 六、 Redis：性能利器"></a>🚀 六、 Redis：性能利器</h2><blockquote>
<p><strong>核心重点</strong>：数据结构、缓存异常、一致性、分布式锁。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-5"><a href="#🔍-深挖与避坑-5" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>缓存一致性</strong>：<em>(高频难点)</em><ul>
<li>方案对比：延时双删 vs 先删缓存再更新库。</li>
<li><strong>大厂方案</strong>：订阅 Binlog (Canal) -&gt; 消息队列 -&gt; 异步删除缓存（最终一致性）。</li>
</ul>
</li>
<li><strong>分布式锁</strong>：<ul>
<li><code>setnx</code> 缺陷：业务没跑完锁过期怎么办？</li>
<li><strong>解决方案</strong>：Redisson 的 <strong>WatchDog (看门狗)</strong> 机制自动续期。</li>
</ul>
</li>
<li><strong>底层结构</strong>：<ul>
<li><strong>跳表 (SkipList)</strong>：ZSet 为什么用跳表不用红黑树？（实现简单、并发好、范围查询效率高）。</li>
</ul>
</li>
</ul>
<h2 id="📨-七、-消息队列-MQ-：解耦削峰"><a href="#📨-七、-消息队列-MQ-：解耦削峰" class="headerlink" title="📨 七、 消息队列 (MQ)：解耦削峰"></a>📨 七、 消息队列 (MQ)：解耦削峰</h2><blockquote>
<p><strong>核心重点</strong>：Kafka&#x2F;RocketMQ 选型、消息丢失&#x2F;重复&#x2F;积压。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-6"><a href="#🔍-深挖与避坑-6" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>消息不丢失</strong>：<ul>
<li>涉及三端确认：生产者 ACK、Broker 同步刷盘&#x2F;多副本、消费者手动 ACK。</li>
</ul>
</li>
<li><strong>消息积压处理</strong>：<ul>
<li>线上事故应对：临时新建 Topic，将积压消息转发，开启多倍消费者进行消费。</li>
</ul>
</li>
</ul>
<h2 id="🛠️-八、-项目经验：面试的“胜负手”"><a href="#🛠️-八、-项目经验：面试的“胜负手”" class="headerlink" title="🛠️ 八、 项目经验：面试的“胜负手”"></a>🛠️ 八、 项目经验：面试的“胜负手”</h2><blockquote>
<p><strong>策略</strong>：面试官不关心普通的 CRUD，关心的是<strong>难点</strong>和<strong>思考</strong>。</p>
</blockquote>
<h3 id="🌟-STAR-原则准备法-准备-2-个技术难点"><a href="#🌟-STAR-原则准备法-准备-2-个技术难点" class="headerlink" title="🌟 STAR 原则准备法 (准备 2 个技术难点)"></a>🌟 STAR 原则准备法 (准备 2 个技术难点)</h3><ol>
<li><strong>S (Situation 情境)</strong>：高并发秒杀&#x2F;大流量&#x2F;复杂业务。</li>
<li><strong>T (Task 任务)</strong>：防止超卖、保证服务稳定性。</li>
<li><strong>A (Action 行动)</strong>：使用了 Redis 预减库存 + Lua 脚本保证原子性，配合 RabbitMQ 异步下单削峰。</li>
<li><strong>R (Result 结果)</strong>：最终支撑了 X QPS，响应时间降低了 Y%，且数据零丢失。</li>
</ol>
<h2 id="🌐-九、-计算机网络：基础素养"><a href="#🌐-九、-计算机网络：基础素养" class="headerlink" title="🌐 九、 计算机网络：基础素养"></a>🌐 九、 计算机网络：基础素养</h2><blockquote>
<p><strong>核心重点</strong>：TCP&#x2F;UDP、HTTP&#x2F;HTTPS、URL 请求流程。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-7"><a href="#🔍-深挖与避坑-7" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>HTTPS</strong>：SSL&#x2F;TLS 握手过程（公钥传输 -&gt; 协商 -&gt; 对称加密通信）。</li>
<li><strong>TCP 粘包&#x2F;拆包</strong>：在 Netty 中如何解决？（固定长度、分隔符、长度字段字段法）。</li>
</ul>
<hr>
<h2 id="🎁-补充：加分项-Bonus"><a href="#🎁-补充：加分项-Bonus" class="headerlink" title="🎁 补充：加分项 (Bonus)"></a>🎁 补充：加分项 (Bonus)</h2><h3 id="1-算法-LeetCode"><a href="#1-算法-LeetCode" class="headerlink" title="1. 算法 (LeetCode)"></a>1. 算法 (LeetCode)</h3><ul>
<li>虽然未列入必须，但大厂必考。</li>
<li><strong>底线</strong>：Top 100 题。重点刷：链表（反转）、二叉树（遍历&#x2F;深度）、动态规划、手写快排、二分查找。</li>
</ul>
<h3 id="2-Linux-Docker"><a href="#2-Linux-Docker" class="headerlink" title="2. Linux &#x2F; Docker"></a>2. Linux &#x2F; Docker</h3><ul>
<li><strong>常用命令</strong>：<code>top</code> (看负载), <code>awk</code>&#x2F;<code>grep</code> (查日志), <code>tail -f</code>。</li>
<li><strong>容器化</strong>：Docker 基本操作，K8s 概念了解。</li>
</ul>
<hr>
<h3 id="💡-最后建议"><a href="#💡-最后建议" class="headerlink" title="💡 最后建议"></a>💡 最后建议</h3><p><strong>不要只“看”，要“讲”</strong>。<br>每一个知识点，尝试对着镜子用自己的话完整的讲一遍逻辑。只有能流利地讲清楚原理和方案，才算真正拿下了这个知识点。<strong>祝你面试顺利，Offer 拿到手软！</strong></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/11/29/%E5%85%AB%E8%82%A1%E6%96%B9%E5%90%9102/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/11/29/%E5%85%AB%E8%82%A1%E6%96%B9%E5%90%9101/">
        <h2 class="post-title">八股方向01</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/11/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <hr>
<h1 id="☕-Java-后端经典面试题库-32题详解"><a href="#☕-Java-后端经典面试题库-32题详解" class="headerlink" title="☕ Java 后端经典面试题库 (32题详解)"></a>☕ Java 后端经典面试题库 (32题详解)</h1><p>这份题库涵盖了 Java 基础、集合框架、并发编程、JVM、数据库、中间件、Spring 框架以及个人成长等核心领域，适合面试前的查漏补缺和系统复习。</p>
<h2 id="📌-一、-Java-基础与面向对象"><a href="#📌-一、-Java-基础与面向对象" class="headerlink" title="📌 一、 Java 基础与面向对象"></a>📌 一、 Java 基础与面向对象</h2><h3 id="1-对-Java-面向对象怎么理解的？"><a href="#1-对-Java-面向对象怎么理解的？" class="headerlink" title="1. 对 Java 面向对象怎么理解的？"></a>1. 对 Java 面向对象怎么理解的？</h3><ul>
<li><strong>核心思想</strong>：将现实世界的事物抽象为“对象”，重点在于通过对象之间的<strong>交互</strong>来解决问题。</li>
<li><strong>对比面向过程</strong>：<ul>
<li>面向过程（如 C 语言）侧重于“步骤”和函数调用。</li>
<li>面向对象侧重于“谁来做”以及对象间的职责分配。</li>
</ul>
</li>
<li><strong>优势</strong>：代码复用性高、易维护、易扩展、低耦合。</li>
</ul>
<h3 id="2-Java-面向对象的特性有哪些？"><a href="#2-Java-面向对象的特性有哪些？" class="headerlink" title="2. Java 面向对象的特性有哪些？"></a>2. Java 面向对象的特性有哪些？</h3><ol>
<li><strong>封装 (Encapsulation)</strong>：隐藏对象的属性和实现细节，仅对外公开接口，提高安全性。</li>
<li><strong>继承 (Inheritance)</strong>：子类继承父类的特征和行为，实现代码复用。</li>
<li><strong>多态 (Polymorphism)</strong>：同一个接口，使用不同的实例而执行不同操作（实现条件：继承、重写、父类引用指向子类对象）。</li>
<li><em>(补充)</em> <strong>抽象 (Abstraction)</strong>：提取事物的共性，忽略细节。</li>
</ol>
<h3 id="3-String-类可以被继承吗？"><a href="#3-String-类可以被继承吗？" class="headerlink" title="3. String 类可以被继承吗？"></a>3. String 类可以被继承吗？</h3><ul>
<li><strong>回答</strong>：不能。</li>
<li><strong>原因</strong>：String 类被 <code>final</code> 关键字修饰。</li>
<li><strong>设计目的</strong>：<ol>
<li><strong>安全</strong>：防止核心类被恶意篡改（如数据库连接串、类加载机制）。</li>
<li><strong>效率</strong>：配合字符串常量池（String Pool），只有不可变才能实现池化。</li>
<li><strong>线程安全</strong>：不可变对象天生是线程安全的。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="📂-二、-集合框架-Collections"><a href="#📂-二、-集合框架-Collections" class="headerlink" title="📂 二、 集合框架 (Collections)"></a>📂 二、 集合框架 (Collections)</h2><h3 id="4-ArrayList-和-LinkedList-的区别"><a href="#4-ArrayList-和-LinkedList-的区别" class="headerlink" title="4. ArrayList 和 LinkedList 的区别"></a>4. ArrayList 和 LinkedList 的区别</h3><ul>
<li><strong>底层结构</strong>：<code>ArrayList</code> 是动态数组；<code>LinkedList</code> 是双向链表。</li>
<li><strong>随机访问</strong>：<code>ArrayList</code> 支持 $O(1)$ 的随机访问（通过下标）；<code>LinkedList</code> 需要 $O(n)$ 遍历。</li>
<li><strong>增删效率</strong>：<ul>
<li><code>ArrayList</code> 尾部增删快，但在中间增删需要数组扩容和内存拷贝，较慢。</li>
<li><code>LinkedList</code> 增删节点快（$O(1)$），但定位节点位置较慢。</li>
</ul>
</li>
<li><strong>内存空间</strong>：<code>ArrayList</code> 存在扩容时的预留空间浪费；<code>LinkedList</code> 每个节点需存储前后指针，单节点开销较大。</li>
</ul>
<h3 id="5-HashMap-的扩容原理"><a href="#5-HashMap-的扩容原理" class="headerlink" title="5. HashMap 的扩容原理"></a>5. HashMap 的扩容原理</h3><ul>
<li><strong>触发条件</strong>：当 <code>size &gt; capacity * loadFactor</code>（默认负载因子 0.75）时触发。</li>
<li><strong>过程</strong>：<ol>
<li>创建一个新的数组，容量是原来的 <strong>2倍</strong>。</li>
<li><strong>Rehash</strong>：将旧数组中的元素重新映射到新数组中。</li>
</ol>
</li>
<li><strong>JDK 1.8 优化</strong>：不需要重新计算 Hash，只需要判断原 Hash 值新增的那个 bit 是 0 还是 1，从而决定是在“原位置”还是“原位置 + 旧容量”。</li>
</ul>
<h3 id="6-7-HashMap-的-key-可以为空吗？若为空会怎么样？"><a href="#6-7-HashMap-的-key-可以为空吗？若为空会怎么样？" class="headerlink" title="6 &amp; 7. HashMap 的 key 可以为空吗？若为空会怎么样？"></a>6 &amp; 7. HashMap 的 key 可以为空吗？若为空会怎么样？</h3><ul>
<li><strong>回答</strong>：可以为空。</li>
<li><strong>处理机制</strong>：HashMap 会将 key 为 <code>null</code> 的元素存放在数组索引为 <strong>0</strong> 的位置（内部强制 hash 值为 0）。</li>
<li><strong>注意</strong>：只能有一个 key 为 <code>null</code>，但可以有多个 value 为 <code>null</code>。</li>
</ul>
<h3 id="8-Set-有了解吗，怎么保证数据不重复的？-重点"><a href="#8-Set-有了解吗，怎么保证数据不重复的？-重点" class="headerlink" title="8. Set 有了解吗，怎么保证数据不重复的？(重点)"></a>8. Set 有了解吗，怎么保证数据不重复的？(重点)</h3><ul>
<li><strong>底层实现</strong>：<code>HashSet</code> 底层其实就是一个 <code>HashMap</code>。数据存储在 HashMap 的 Key 上，Value 是一个固定的 <code>Object</code> 对象（PRESENT）。</li>
<li><strong>去重机制</strong>：<ol>
<li>计算元素的 <code>hashCode()</code>，定位到对应的桶（Bucket）。</li>
<li>如果桶无元素，直接存入。</li>
<li>如果桶有元素（Hash 冲突），调用 <code>equals()</code> 方法比较。</li>
<li>若 <code>equals()</code> 返回 true，视为重复，不添加；返回 false，则以链表&#x2F;红黑树形式追加。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="🚀-三、-并发编程-Concurrency"><a href="#🚀-三、-并发编程-Concurrency" class="headerlink" title="🚀 三、 并发编程 (Concurrency)"></a>🚀 三、 并发编程 (Concurrency)</h2><h3 id="9-进程和线程的区别"><a href="#9-进程和线程的区别" class="headerlink" title="9. 进程和线程的区别"></a>9. 进程和线程的区别</h3><ul>
<li><strong>定义</strong>：进程是<strong>资源分配</strong>的最小单位；线程是<strong>CPU调度</strong>的最小单位。</li>
<li><strong>关系</strong>：一个进程包含多个线程，线程共享进程的堆内存和方法区（元空间）。</li>
<li><strong>开销</strong>：进程切换开销大（独立内存空间），线程切换开销小。</li>
</ul>
<h3 id="10-操作系统的调度算法"><a href="#10-操作系统的调度算法" class="headerlink" title="10. 操作系统的调度算法"></a>10. 操作系统的调度算法</h3><ol>
<li><strong>先来先服务 (FCFS)</strong>。</li>
<li><strong>短作业优先 (SJF)</strong>。</li>
<li><strong>时间片轮转 (RR)</strong>（最常见，保证响应时间）。</li>
<li><strong>优先级调度</strong>。</li>
<li><strong>多级反馈队列调度</strong>。</li>
</ol>
<h3 id="11-Java-创建线程的方式"><a href="#11-Java-创建线程的方式" class="headerlink" title="11. Java 创建线程的方式"></a>11. Java 创建线程的方式</h3><ol>
<li>继承 <code>Thread</code> 类。</li>
<li>实现 <code>Runnable</code> 接口。</li>
<li>实现 <code>Callable</code> 接口（有返回值）。</li>
<li>使用线程池 (<code>ExecutorService</code>)。</li>
</ol>
<h3 id="12-Callable-和-Runnable-的区别"><a href="#12-Callable-和-Runnable-的区别" class="headerlink" title="12. Callable 和 Runnable 的区别"></a>12. Callable 和 Runnable 的区别</h3><ul>
<li><strong>返回值</strong>：<code>Runnable</code> 的 <code>run()</code> 返回 void；<code>Callable</code> 的 <code>call()</code> 有返回值（泛型）。</li>
<li><strong>异常</strong>：<code>Runnable</code> 不能抛出 Checked Exception；<code>Callable</code> 可以。</li>
<li><strong>执行</strong>：<code>Callable</code> 通常配合 <code>FutureTask</code> 或线程池使用，通过 <code>Future.get()</code> 获取结果。</li>
</ul>
<h3 id="13-线程池的核心参数"><a href="#13-线程池的核心参数" class="headerlink" title="13. 线程池的核心参数"></a>13. 线程池的核心参数</h3><ol>
<li><code>corePoolSize</code>：核心线程数（常驻）。</li>
<li><code>maximumPoolSize</code>：最大线程数。</li>
<li><code>keepAliveTime</code>：非核心线程空闲存活时间。</li>
<li><code>unit</code>：时间单位。</li>
<li><code>workQueue</code>：任务阻塞队列。</li>
<li><code>threadFactory</code>：线程工厂（用于命名线程等）。</li>
<li><code>handler</code>：拒绝策略（如 AbortPolicy, CallerRunsPolicy 等）。</li>
</ol>
<h3 id="14-线程池的-corePoolSize-大小的设置策略"><a href="#14-线程池的-corePoolSize-大小的设置策略" class="headerlink" title="14. 线程池的 corePoolSize 大小的设置策略"></a>14. 线程池的 corePoolSize 大小的设置策略</h3><ul>
<li><strong>CPU 密集型</strong>：CPU 核数 + 1（减少线程切换开销）。</li>
<li><strong>IO 密集型</strong>：CPU 核数 * 2 或 <code>CPU 核数 / (1 - 阻塞系数)</code>（因为 IO 操作不占用 CPU，可以多开线程）。</li>
</ul>
<hr>
<h2 id="☕-四、-JVM-Java-虚拟机"><a href="#☕-四、-JVM-Java-虚拟机" class="headerlink" title="☕ 四、 JVM (Java 虚拟机)"></a>☕ 四、 JVM (Java 虚拟机)</h2><h3 id="15-JVM-怎么判断对象是否是垃圾对象？"><a href="#15-JVM-怎么判断对象是否是垃圾对象？" class="headerlink" title="15. JVM 怎么判断对象是否是垃圾对象？"></a>15. JVM 怎么判断对象是否是垃圾对象？</h3><ul>
<li><strong>引用计数法</strong>（HotSpot 未采用）：有引用+1，失效-1。缺点：无法解决<strong>循环引用</strong>问题。</li>
<li><strong>可达性分析法</strong>（主流）：从 <strong>GC Roots</strong>（如栈帧中的局部变量、静态变量、常量引用等）出发，搜索引用的对象链。搜索不到的对象即为垃圾。</li>
</ul>
<h3 id="16-垃圾收集算法有哪些？"><a href="#16-垃圾收集算法有哪些？" class="headerlink" title="16. 垃圾收集算法有哪些？"></a>16. 垃圾收集算法有哪些？</h3><ol>
<li><strong>标记-清除 (Mark-Sweep)</strong>：容易产生内存碎片。</li>
<li><strong>标记-复制 (Copying)</strong>：新生代常用，效率高但浪费一半空间。</li>
<li><strong>标记-整理 (Mark-Compact)</strong>：老年代常用，解决碎片问题。</li>
<li><strong>分代收集</strong>：根据对象存活周期不同，新生代用复制算法，老年代用标记-整理算法。</li>
</ol>
<h3 id="17-对-Java-内存模型-JMM-有了解吗？"><a href="#17-对-Java-内存模型-JMM-有了解吗？" class="headerlink" title="17. 对 Java 内存模型 (JMM) 有了解吗？"></a>17. 对 Java 内存模型 (JMM) 有了解吗？</h3><ul>
<li><strong>目的</strong>：屏蔽硬件差异，解决并发中的<strong>原子性、可见性、有序性</strong>问题。</li>
<li><strong>结构</strong>：主内存（共享数据） vs 工作内存（线程私有缓存）。</li>
<li><strong>核心关键字</strong>：<ul>
<li><code>volatile</code>：保证可见性、禁止指令重排（有序性）。</li>
<li><code>synchronized</code>：保证原子性、可见性、有序性。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="💾-五、-数据库与中间件-MySQL-Redis"><a href="#💾-五、-数据库与中间件-MySQL-Redis" class="headerlink" title="💾 五、 数据库与中间件 (MySQL &amp; Redis)"></a>💾 五、 数据库与中间件 (MySQL &amp; Redis)</h2><h3 id="18-对-MySQL-中索引的理解、索引的分类"><a href="#18-对-MySQL-中索引的理解、索引的分类" class="headerlink" title="18. 对 MySQL 中索引的理解、索引的分类"></a>18. 对 MySQL 中索引的理解、索引的分类</h3><ul>
<li><strong>理解</strong>：索引是帮助快速查找数据的排好序的数据结构（通常是 <strong>B+树</strong>）。</li>
<li><strong>分类</strong>：<ul>
<li><strong>物理存储</strong>：聚簇索引（数据和索引在一起，如主键）、非聚簇索引（二级索引，叶子节点存主键）。</li>
<li><strong>逻辑约束</strong>：主键索引、唯一索引、普通索引、全文索引。</li>
<li><strong>字段个数</strong>：单列索引、联合索引（需遵循<strong>最左前缀原则</strong>）。</li>
</ul>
</li>
</ul>
<h3 id="19-Redis-数据结构有哪几种，应用场景？"><a href="#19-Redis-数据结构有哪几种，应用场景？" class="headerlink" title="19. Redis 数据结构有哪几种，应用场景？"></a>19. Redis 数据结构有哪几种，应用场景？</h3><ol>
<li><strong>String</strong>：缓存、计数器、分布式锁、Session 共享。</li>
<li><strong>List</strong>：消息队列、最新动态（时间轴）。</li>
<li><strong>Hash</strong>：存储对象（如用户信息、购物车）。</li>
<li><strong>Set</strong>：去重、抽奖、共同好友（交集操作）。</li>
<li><strong>ZSet (Sorted Set)</strong>：排行榜、带权重的队列。</li>
</ol>
<hr>
<h2 id="🔒-六、-高级并发与锁"><a href="#🔒-六、-高级并发与锁" class="headerlink" title="🔒 六、 高级并发与锁"></a>🔒 六、 高级并发与锁</h2><h3 id="20-阻塞队列和非阻塞队列的区别"><a href="#20-阻塞队列和非阻塞队列的区别" class="headerlink" title="20. 阻塞队列和非阻塞队列的区别"></a>20. 阻塞队列和非阻塞队列的区别</h3><ul>
<li><strong>阻塞队列</strong>（如 <code>ArrayBlockingQueue</code>）：基于锁和等待&#x2F;通知机制。当队列满时写阻塞，空时读阻塞。常用于生产者-消费者模型。</li>
<li><strong>非阻塞队列</strong>（如 <code>ConcurrentLinkedQueue</code>）：基于 <strong>CAS</strong> 机制（无锁），操作立即返回或重试，高并发下性能更好，但 CPU 开销可能较大。</li>
</ul>
<h3 id="21-CAS-的原理及其应用场景"><a href="#21-CAS-的原理及其应用场景" class="headerlink" title="21. CAS 的原理及其应用场景"></a>21. CAS 的原理及其应用场景</h3><ul>
<li><strong>原理</strong>：<strong>Compare And Swap</strong>（比较并交换）。包含三个操作数：内存地址 V、预期原值 A、新值 B。只有当 V&#x3D;&#x3D;A 时，才将 V 更新为 B。</li>
<li><strong>场景</strong>：<code>AtomicInteger</code> 等原子类、自旋锁、并发容器。</li>
</ul>
<h3 id="22-ABA-问题及其解决方法"><a href="#22-ABA-问题及其解决方法" class="headerlink" title="22. ABA 问题及其解决方法"></a>22. ABA 问题及其解决方法</h3><ul>
<li><strong>问题</strong>：值从 A 变为 B 又变回 A，CAS 检查时以为没变，实际中间经历了变化。</li>
<li><strong>解决</strong>：增加<strong>版本号</strong>（<code>AtomicStampedReference</code>），比较时同时比较值和版本号。</li>
</ul>
<h3 id="23-进程级别的锁解决的是什么问题？"><a href="#23-进程级别的锁解决的是什么问题？" class="headerlink" title="23. 进程级别的锁解决的是什么问题？"></a>23. 进程级别的锁解决的是什么问题？</h3><ul>
<li><strong>指代</strong>：<code>synchronized</code> 或 <code>ReentrantLock</code>。</li>
<li><strong>解决</strong>：<strong>单个 JVM 进程内</strong>，多线程访问共享资源的数据一致性问题。</li>
</ul>
<h3 id="24-分布式锁解决的什么问题？"><a href="#24-分布式锁解决的什么问题？" class="headerlink" title="24. 分布式锁解决的什么问题？"></a>24. 分布式锁解决的什么问题？</h3><ul>
<li><strong>解决</strong>：<strong>跨进程&#x2F;跨服务器</strong>（集群环境）下，多个服务同时访问共享资源（如数据库、Redis）的一致性问题。</li>
<li><strong>实现</strong>：Redis (<code>setnx</code> + lua), Zookeeper (临时顺序节点), Redisson。</li>
</ul>
<h3 id="25-MySQL-中-InnoDB-引擎中行级锁的类型"><a href="#25-MySQL-中-InnoDB-引擎中行级锁的类型" class="headerlink" title="25. MySQL 中 InnoDB 引擎中行级锁的类型"></a>25. MySQL 中 InnoDB 引擎中行级锁的类型</h3><ol>
<li><strong>Record Lock</strong>：锁记录本身。</li>
<li><strong>Gap Lock</strong>：间隙锁，锁范围，防止幻读。</li>
<li><strong>Next-Key Lock</strong>：Record + Gap，默认隔离级别（RR）下使用。</li>
</ol>
<h3 id="26-MySQL-中锁和事务是否有相关性？"><a href="#26-MySQL-中锁和事务是否有相关性？" class="headerlink" title="26. MySQL 中锁和事务是否有相关性？"></a>26. MySQL 中锁和事务是否有相关性？</h3><ul>
<li><strong>强相关</strong>。</li>
<li>事务的<strong>隔离性 (Isolation)</strong> 主要就是通过<strong>锁机制</strong>（配合 MVCC）来实现的。事务提交或回滚时才会释放锁。</li>
</ul>
<h3 id="27-死锁是什么？"><a href="#27-死锁是什么？" class="headerlink" title="27. 死锁是什么？"></a>27. 死锁是什么？</h3><ul>
<li><strong>定义</strong>：两个或多个线程互相持有对方需要的资源，并等待对方释放，导致无限期等待。</li>
<li><strong>四个必要条件</strong>：互斥、占有且等待、不可抢占、循环等待。</li>
</ul>
<hr>
<h2 id="🌿-七、-Spring-框架与-AOP"><a href="#🌿-七、-Spring-框架与-AOP" class="headerlink" title="🌿 七、 Spring 框架与 AOP"></a>🌿 七、 Spring 框架与 AOP</h2><h3 id="28-Spring-中-AOP-代理分为几大类和区别？"><a href="#28-Spring-中-AOP-代理分为几大类和区别？" class="headerlink" title="28. Spring 中 AOP 代理分为几大类和区别？"></a>28. Spring 中 AOP 代理分为几大类和区别？</h3><ol>
<li><strong>JDK 动态代理</strong>：基于接口实现，只能代理实现了接口的类。</li>
<li><strong>CGLIB 动态代理</strong>：基于继承实现，通过 ASM 字节码技术生成子类，不能代理 <code>final</code> 类。</li>
</ol>
<ul>
<li><em>注：Spring Boot 2.x 后默认倾向于使用 CGLIB。</em></li>
</ul>
<h3 id="29-自己有没有使用过代理来完成业务开发？"><a href="#29-自己有没有使用过代理来完成业务开发？" class="headerlink" title="29. 自己有没有使用过代理来完成业务开发？"></a>29. 自己有没有使用过代理来完成业务开发？</h3><ul>
<li><strong>回答思路</strong>：除了使用框架特性，自己可能写过：<ul>
<li><strong>拦截器 (Interceptor)</strong> 或 <strong>过滤器 (Filter)</strong>。</li>
<li><strong>自定义注解 + AOP 切面</strong>：用于实现统一日志记录、接口权限校验、全局异常处理、方法耗时统计等。</li>
</ul>
</li>
</ul>
<h3 id="30-Spring-框架里用到-AOP-的地方"><a href="#30-Spring-框架里用到-AOP-的地方" class="headerlink" title="30. Spring 框架里用到 AOP 的地方"></a>30. Spring 框架里用到 AOP 的地方</h3><ul>
<li><strong>声明式事务</strong> (<code>@Transactional</code>)。</li>
<li><strong>Spring Security</strong> (权限控制)。</li>
<li><strong>统一缓存</strong> (<code>@Cacheable</code>)。</li>
<li><strong>统一日志</strong>。</li>
</ul>
<hr>
<h2 id="📈-八、-开放性问题-Personal-Growth"><a href="#📈-八、-开放性问题-Personal-Growth" class="headerlink" title="📈 八、 开放性问题 (Personal Growth)"></a>📈 八、 开放性问题 (Personal Growth)</h2><h3 id="31-平时自身成长通过哪些途径进行学习？"><a href="#31-平时自身成长通过哪些途径进行学习？" class="headerlink" title="31. 平时自身成长通过哪些途径进行学习？"></a>31. 平时自身成长通过哪些途径进行学习？</h3><ul>
<li><strong>官方文档</strong>（最权威）。</li>
<li><strong>技术社区</strong>：掘金、CSDN、StackOverflow、V2EX。</li>
<li><strong>源码阅读</strong>：GitHub 上阅读优秀开源项目（如 Spring, MyBatis, Netty）。</li>
<li><strong>书籍</strong>：《深入理解Java虚拟机》、《Java并发编程实战》、《高性能MySQL》等。</li>
<li><strong>视频课程</strong>：B站、Coursera、极客时间。</li>
</ul>
<h3 id="32-有没有参加过一些开源的社区？"><a href="#32-有没有参加过一些开源的社区？" class="headerlink" title="32. 有没有参加过一些开源的社区？"></a>32. 有没有参加过一些开源的社区？</h3><ul>
<li><strong>诚实作答</strong>。</li>
<li><strong>如果有</strong>：提到具体的 PR (Pull Request) 或 Issue 经历。</li>
<li><strong>如果没有</strong>：可以这样说：“虽然还没有提交过代码，但我经常在 GitHub 上阅读开源项目源码，并关注 Issues 区的讨论，学习开发者解决 bug 和设计架构的思路。”</li>
</ul>
<hr>
<h3 id="💡-复习建议"><a href="#💡-复习建议" class="headerlink" title="💡 复习建议"></a>💡 复习建议</h3><p>面试时不要死记硬背，建议结合<strong>自己的项目经验</strong>，用自己的话把技术原理讲出来。遇到不会的问题（如具体算法细节），可以尝试关联到相关的知识点，或者诚实回答并表示出学习意愿。祝面试顺利！</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/11/29/%E5%85%AB%E8%82%A1%E6%96%B9%E5%90%9101/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/11/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E5%85%B3%E4%BA%8E%E8%A7%86%E9%A2%91%E8%BF%9B%E5%BA%A6%E8%AE%B0%E5%BD%95%E6%96%B9%E9%9D%A2%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86/">
        <h2 class="post-title">微服务教育平台项目关于视频进度记录方面的高并发处理</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/11/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <ul>
<li>对查库查表比较频繁的功能接口使用了redis中间件作为缓存，提高性能，防止数据库压力过大宕机以及查询过多速度变慢，影响用户体验。</li>
</ul>
<h4 id="两个功能进行优化"><a href="#两个功能进行优化" class="headerlink" title="两个功能进行优化"></a>两个功能进行优化</h4><ul>
<li><p>1.提交学习视频记录，判断是否是第一次提交</p>
<ul>
<li>大概思路：先去缓存查询是否有该学习记录，如果有直接返回缓存里的学习记录，缓存没有则取数据库进行查询，如果数据库有则返回，并将其写入缓存。不是第一次则返回null，然后新增</li>
</ul>
</li>
<li><p>2.再次提交，判断视频是否第一次学完,是的话更新数据库并清理缓存，不是第一次，将数据写入缓存（不要写入数据库这里，因为业务设定是每15秒来一次视频观看记录提交，高频操作），设定延时队列-阻塞20秒。</p>
<ul>
<li>当用户还在观看视频的时候，15秒就更新一次缓存，所以阻塞队列检测执行的时候与redis数据进行比较是否一致的时候，如果不一致说明还在继续看视频，当停止观看视频后缓存更新数据不变，阻塞队列提交任务发现数据一致时，再将具体数据写入数据库。</li>
</ul>
<p>  用户观看视频（每15秒上报进度）<br>  ↓</p>
</li>
</ul>
<p>LearningRecordServiceImpl.addVideoRecord()<br>    ↓<br>┌─────────────────────────────────────┐<br>│  1. readCacheRecord()               │ ← Redis Hash 读取<br>│     - 缓存命中 → 直接返回           │<br>│     - 缓存未命中 → 查DB → 写缓存    │<br>└─────────────────────────────────────┘<br>    ↓<br>┌─────────────────────────────────────┐<br>│  2. addLearningRecordTask()         │<br>│     - writeRecordToRedis()          │ ← 更新Redis缓存<br>│     - queue.put(DelayTask)          │ ← 提交延时队列（20秒）<br>└─────────────────────────────────────┘<br>    ↓<br>┌─────────────────────────────────────┐<br>│  3. handleRecordTask() [异步线程]    │<br>│     - queue.take() [阻塞等待]       │ ← DelayQueue 延时队列<br>│     - 比较缓存与队列数据            │<br>│     - 一致 → 写入数据库              │<br>│     - 不一致 → 跳过（用户仍在观看）  │<br>└─────────────────────────────────────┘<br>    ↓<br>┌─────────────────────────────────────┐<br>│  4. cleanCacheRecord()              │ ← 视频完成时清理缓存<br>│     - 数据库已更新                   │<br>│     - 删除Redis缓存                  │<br>└─────────────────────────────────────┘</p>
<h4 id="对延时队列工具类的封装–原理"><a href="#对延时队列工具类的封装–原理" class="headerlink" title="对延时队列工具类的封装–原理"></a>对延时队列工具类的封装–原理</h4><ul>
<li><p>@PostConstruct + CompletableFuture.runAsync(this::handleRecordTask)来启动处理队列这个线程</p>
<ul>
<li>放在 @PostConstruct 里：保证此时 redisTemplate、recordMapper、lessonMapper 等依赖已经通过构造函数注入完毕，Bean 是一个“准备就绪”的单例。pring 容器启动完成时自动调用一次 init()，不会重复启动多个处理线程。</li>
<li>CompletableFuture.runAsync(this::handleRecordTask) ，因为while(true)是个死循环， while (begin) + queue.take() 阻塞，如果直接在主线程或 Web 请求线程里调用，会把线程卡死。runAsync 会把 handleRecordTask() 丢到线程池里的后台线程去跑，不阻塞 Spring 容器启动线程，也不阻塞任何请求线程。</li>
</ul>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/11/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E5%85%B3%E4%BA%8E%E8%A7%86%E9%A2%91%E8%BF%9B%E5%BA%A6%E8%AE%B0%E5%BD%95%E6%96%B9%E9%9D%A2%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/11/25/Gemini3%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%EF%BC%9A%E4%B8%80%E4%BA%9B%E9%A1%B9%E7%9B%AE%E7%9A%84idea/">
        <h2 class="post-title">Gemini3使用体验：对应电商项目的些许idea</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/11/25
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="回答背景："><a href="#回答背景：" class="headerlink" title="回答背景："></a>回答背景：</h4><ul>
<li><p>1.mcp+llm+rag一个项目 根据用户在一个商场购买的课程的 根据用户的各类信息结合他的购买习惯 学习课程的哪个更久一些 他的学习计划习惯  能够有一些推荐课程和总结建议的助手 我商场项目是Java springcloud那一套生态 mcp+llm+rag 用Python吧  告诉我实现流程和思路落地 根据用户在一个商场购买的课程的 根据用户的各类信息结合他的购买习惯 学习课程的哪个更久一些 他的学习计划习惯  能够有一些推荐课程和总结建议的助手 </p>
</li>
<li><p>2.详细说一下python侧的技术栈 3.两个疑问： 一 langchain和langgraph应用在mcpserver封装当中吗 rag知识库构建有没有应用到  二 rag知识库存储的信息主要是什么 当用户个人信息携带请求打过来 会实时更新rag吗 如果rag是之前预热存储了许多课程信息 </p>
</li>
<li><p>3.那么第一次rag知识库为空 java侧应用启动了 python侧启动 设计自动（无需用户或者管理员交互）自动将对应数据库的课表库以及其他预热数据传入rag知识库当中</p>
</li>
</ul>
<h4 id="Gemini3Pro的回答"><a href="#Gemini3Pro的回答" class="headerlink" title="Gemini3Pro的回答"></a>Gemini3Pro的回答</h4><h4 id="项目架构笔记：个性化课程推荐助手-MCP-LLM-RAG"><a href="#项目架构笔记：个性化课程推荐助手-MCP-LLM-RAG" class="headerlink" title="项目架构笔记：个性化课程推荐助手 (MCP + LLM + RAG)"></a>项目架构笔记：个性化课程推荐助手 (MCP + LLM + RAG)</h4><h4 id="1-项目背景与核心理念"><a href="#1-项目背景与核心理念" class="headerlink" title="1. 项目背景与核心理念"></a>1. 项目背景与核心理念</h4><ul>
<li><strong>目标：</strong> 构建一个智能助手，能够根据用户在商场（Java侧）的购买记录、学习时长、学习习惯等数据，结合课程内容库，提供个性化的课程推荐和学习建议。</li>
<li><strong>角色分工：</strong><ul>
<li><strong>Java (Spring Cloud)：</strong> <strong>业务中台</strong>。负责存储核心业务数据（用户、订单、日志）、提供原子API能力。</li>
<li><strong>Python (MCP + AI)：</strong> <strong>智能大脑</strong>。负责语义理解、逻辑编排、RAG检索、以及通过MCP协议调用Java侧数据。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-业务实现流程与落地思路"><a href="#2-业务实现流程与落地思路" class="headerlink" title="2. 业务实现流程与落地思路"></a>2. 业务实现流程与落地思路</h4><h5 id="2-1-核心架构逻辑"><a href="#2-1-核心架构逻辑" class="headerlink" title="2.1 核心架构逻辑"></a>2.1 核心架构逻辑</h5><ul>
<li>用户提问 -&gt; <strong>Python Agent (大脑)</strong> -&gt; <strong>拆解任务</strong> -&gt; <strong>并发&#x2F;顺序调用数据源</strong> -&gt; <strong>汇总推理</strong> -&gt; 返回建议。</li>
</ul>
<h5 id="2-2-详细交互步骤-Step-by-Step"><a href="#2-2-详细交互步骤-Step-by-Step" class="headerlink" title="2.2 详细交互步骤 (Step-by-Step)"></a>2.2 详细交互步骤 (Step-by-Step)</h5><ol>
<li><p><strong>用户发起请求</strong></p>
<ul>
<li>前端携带 <code>userId</code> 和自然语言问题（例如：“我学Java多线程很吃力，接下来咋办？”）请求 Python 服务。</li>
</ul>
</li>
<li><p><strong>Agent 规划 (LLM)</strong></p>
<ul>
<li>Python端的 LLM 接收请求，分析出需要获取两类信息：<ul>
<li><strong>用户信息：</strong> 确认用户买了什么课、哪里学得久、哪里卡住了。</li>
<li><strong>课程知识：</strong> 寻找能解决“多线程吃力”的课程资料。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>获取用户画像 (动态数据 - Tool Call)</strong></p>
<ul>
<li><strong>动作：</strong> Agent 调用 MCP 工具 <code>get_user_learning_profile(userId)</code>。</li>
<li><strong>实现：</strong> Python MCP Client 发送 HTTP 请求 $\rightarrow$ Java Spring Cloud 接口。</li>
<li><strong>返回结果：</strong> 结构化 JSON（如：<code>&#123;&quot;购买&quot;: &quot;Java高并发&quot;, &quot;多线程章节停留&quot;: &quot;5小时(异常)&quot;, &quot;习惯&quot;: &quot;晚间学习&quot;&#125;</code>）。</li>
<li><em>注意：此类数据实时性强，不走RAG，走API直连。</em></li>
</ul>
</li>
<li><p><strong>检索课程方案 (静态数据 - RAG)</strong></p>
<ul>
<li><strong>动作：</strong> Agent 根据痛点“Java多线程”，在 Python 内部查询向量数据库。</li>
<li><strong>实现：</strong> RAG 检索课程库。</li>
<li><strong>返回结果：</strong> 课程大纲片段（如：《Java基础进阶-线程篇》简介、目录）。</li>
</ul>
</li>
<li><p><strong>生成建议 (LLM Synthesis)</strong></p>
<ul>
<li><strong>输入：</strong> 用户画像 JSON + RAG 检索到的课程资料。</li>
<li><strong>Prompt 策略：</strong> “用户A在[画像数据]中显示遇到困难，请根据[课程资料]为他制定计划。”</li>
<li><strong>输出：</strong> 最终建议文本。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-Python-侧详细技术栈"><a href="#3-Python-侧详细技术栈" class="headerlink" title="3. Python 侧详细技术栈"></a>3. Python 侧详细技术栈</h4><table>
<thead>
<tr>
<th align="left">模块</th>
<th align="left">推荐技术&#x2F;库</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Web 框架</strong></td>
<td align="left"><strong>FastAPI</strong></td>
<td align="left">高性能，原生支持异步，适合做 AI 服务网关。</td>
</tr>
<tr>
<td align="left"><strong>MCP 协议</strong></td>
<td align="left"><strong>mcp (Python SDK)</strong></td>
<td align="left">Anthropic 官方 SDK，用于封装 Tools 和 Resources。</td>
</tr>
<tr>
<td align="left"><strong>Agent 编排</strong></td>
<td align="left"><strong>LangGraph</strong></td>
<td align="left"><strong>强烈推荐</strong>。相比 LangChain 更适合处理有状态、多步循环的复杂逻辑（如：先查用户，不够再查课，再反思）。</td>
</tr>
<tr>
<td align="left"><strong>LLM 接口</strong></td>
<td align="left"><strong>LangChain &#x2F; OpenAI SDK</strong></td>
<td align="left">对接 GPT-4, DeepSeek, Claude 等大模型。</td>
</tr>
<tr>
<td align="left"><strong>向量数据库</strong></td>
<td align="left"><strong>ChromaDB</strong> (轻量) <br> <strong>Milvus</strong> (生产级)</td>
<td align="left">ChromaDB 适合快速开发和中小规模；Milvus 适合海量数据。</td>
</tr>
<tr>
<td align="left"><strong>Embedding</strong></td>
<td align="left"><strong>Sentence-Transformers</strong></td>
<td align="left">推荐 <code>bge-m3</code> 或 <code>m3e-base</code> 等中文效果好的嵌入模型。</td>
</tr>
<tr>
<td align="left"><strong>数据处理</strong></td>
<td align="left"><strong>Pandas</strong></td>
<td align="left">用于处理从 Java 端拉取的大批量数据（ETL）。</td>
</tr>
</tbody></table>
<hr>
<h4 id="4-核心疑问解答-Q-A"><a href="#4-核心疑问解答-Q-A" class="headerlink" title="4. 核心疑问解答 (Q&amp;A)"></a>4. 核心疑问解答 (Q&amp;A)</h4><h5 id="Q1-LangChain-LangGraph-和-RAG-在-MCP-Server-中如何定位？"><a href="#Q1-LangChain-LangGraph-和-RAG-在-MCP-Server-中如何定位？" class="headerlink" title="Q1: LangChain&#x2F;LangGraph 和 RAG 在 MCP Server 中如何定位？"></a>Q1: LangChain&#x2F;LangGraph 和 RAG 在 MCP Server 中如何定位？</h5><ul>
<li><strong>定位：</strong> 它们是 MCP Server 内部的<strong>实现逻辑</strong>。</li>
<li><strong>LangGraph：</strong> 是“脑子”。当 MCP Server 接收到请求时，是 LangGraph 在控制流程（是先去查库，还是先去调 API）。</li>
<li><strong>RAG：</strong> 是 MCP Server 内部的一个“私有工具”。可以将其封装为一个内部函数，供 Agent 在思考时随时调用。</li>
</ul>
<h5 id="Q2-RAG-知识库存储什么？是否需要实时更新？"><a href="#Q2-RAG-知识库存储什么？是否需要实时更新？" class="headerlink" title="Q2: RAG 知识库存储什么？是否需要实时更新？"></a>Q2: RAG 知识库存储什么？是否需要实时更新？</h5><ul>
<li><strong>存什么（慢数据）：</strong><ul>
<li>课程详情（标题、简介、大纲、讲师信息）。</li>
<li>通用学习路线图、学科知识点关联。</li>
<li><em>切记：不要存用户的实时日志（如购买记录），这些数据变化太快，向量化成本高，应该用 API 实时获取。</em></li>
</ul>
</li>
<li><strong>更新频率：</strong><ul>
<li><strong>不需要</strong>用户请求时实时更新。</li>
<li>仅当 Java 端上架新课程或修改课程大纲时，才触发更新（通常是 T+1 或管理员手动触发，或如下文的自动同步）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-自动化数据预热方案-Cold-Start"><a href="#5-自动化数据预热方案-Cold-Start" class="headerlink" title="5. 自动化数据预热方案 (Cold Start)"></a>5. 自动化数据预热方案 (Cold Start)</h4><p><strong>场景：</strong> Java 端已启动，Python 端第一次启动，RAG 库为空。如何自动同步数据？</p>
<h5 id="5-1-设计思路"><a href="#5-1-设计思路" class="headerlink" title="5.1 设计思路"></a>5.1 设计思路</h5><p>利用 Python 应用的<strong>生命周期钩子 (Lifecycle Hooks)</strong>，在服务启动但在接收流量之前，主动向 Java 端拉取数据。</p>
<h5 id="5-2-详细流程"><a href="#5-2-详细流程" class="headerlink" title="5.2 详细流程"></a>5.2 详细流程</h5><ol>
<li><strong>Java 端准备：</strong> 提供全量课程导出接口（如 <code>GET /api/internal/courses/export</code>）。</li>
<li><strong>Python 端启动自检：</strong><ul>
<li>应用启动 (<code>startup</code> 事件)。</li>
<li>检查向量数据库 (<code>VectorDB.count()</code>)。</li>
</ul>
</li>
<li><strong>判断逻辑：</strong><ul>
<li><strong>若 Count &#x3D;&#x3D; 0 (空库)：</strong> 进入全量同步模式。<ul>
<li>Call Java 接口拉取所有课程 JSON。</li>
<li>文本清洗与拼接 (Title + Desc + Syllabus)。</li>
<li>Embedding 向量化。</li>
<li>批量写入向量库 (Bulk Insert)。</li>
</ul>
</li>
<li><strong>若 Count &gt; 0 (非空)：</strong> 跳过或执行增量检查（对比 ID）。</li>
</ul>
</li>
<li><strong>服务就绪：</strong> 数据加载完毕后，FastAPI 开始监听端口，对外提供服务。</li>
</ol>
<h5 id="5-3-伪代码参考-FastAPI"><a href="#5-3-伪代码参考-FastAPI" class="headerlink" title="5.3 伪代码参考 (FastAPI)"></a>5.3 伪代码参考 (FastAPI)</h5><pre><code class="language-python">#### main.py 相关的伪代码思路

	from fastapi import FastAPI
	from contextlib import asynccontextmanager
	import requests

	# 模拟向量数据库的客户端
	vector_db = ChromaDBClient() 

	@asynccontextmanager
	async def lifespan(app: FastAPI):
    # --- [启动阶段] ---
    print(&quot;&gt;&gt;&gt; Python AI服务启动，开始自检...&quot;)
    
    current_count = vector_db.count()
    if current_count == 0:
        print(f&quot;&gt;&gt;&gt; 检测到知识库为空，开始从 Java 端同步数据...&quot;)
        
        # 1. 调 Java 接口获取数据
        try:
            # 假设 Java 服务名为 java-mall-service
            response = requests.get(&quot;http://java-mall-service/api/internal/export/courses&quot;)
            courses_data = response.json()
            
            # 2. 处理并存入 RAG
            documents = []
            for course in courses_data:
                # 拼接为适合检索的文本
                text = f&quot;课程名：&#123;course[&#39;name&#39;]&#125;\\n简介：&#123;course[&#39;description&#39;]&#125;\\n目录：&#123;course[&#39;catalog&#39;]&#125;&quot;
                documents.append(text)
            
            # 3. 写入数据库
            vector_db.add_documents(documents)
            print(f&quot;&gt;&gt;&gt; 预热完成！共导入 &#123;len(documents)&#125; 门课程数据。&quot;)
            
        except Exception as e:
            print(f&quot;&gt;&gt;&gt; 警告：数据同步失败，原因：&#123;e&#125;&quot;)
    else:
        print(f&quot;&gt;&gt;&gt; 知识库状态正常，包含 &#123;current_count&#125; 条数据。&quot;)

    yield # 服务正式运行
    
    # --- [关闭阶段] ---
    print(&quot;&gt;&gt;&gt; 服务关闭&quot;)
	app = FastAPI(lifespan=lifespan)
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/11/25/Gemini3%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%EF%BC%9A%E4%B8%80%E4%BA%9B%E9%A1%B9%E7%9B%AE%E7%9A%84idea/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/10/19/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9301%EF%BC%9A%E7%BA%B7%E4%BA%AB%E9%94%80%E5%AE%A2%E4%B8%80%E9%9D%A2/">
        <h2 class="post-title">面试总结01：纷享销客一面</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/10/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>采用的线上腾讯会议电话面，面试了大概十多分钟吧，这是本人第二次参加java开发实习岗的日常实习面试，仍对整套八股文体系知识细节的了解有所欠缺，估计是挂了（（ </p>
<h4 id="面试内容"><a href="#面试内容" class="headerlink" title="面试内容"></a>面试内容</h4><h5 id="1-HashMap的具体实现（采用了什么数据结构，原理等），JDK源码思路"><a href="#1-HashMap的具体实现（采用了什么数据结构，原理等），JDK源码思路" class="headerlink" title="1.HashMap的具体实现（采用了什么数据结构，原理等），JDK源码思路"></a>1.HashMap的具体实现（采用了什么数据结构，原理等），JDK源码思路</h5><ul>
<li><p><strong>JDK1.7</strong>:采用<strong>数组+链表</strong>的数据结构，通过哈希算法将新增的元素映射到数组的槽位当中（bucket）,若有哈希冲突产生（即hash()值相同）则通过链表这一数据结构解决在同一槽位的元素，因为链表的查询性能是O（n），所以查询效率比较低。</p>
</li>
<li><p><strong>JDK1.8</strong>:采用<strong>数组+链表+红黑树</strong>的数据结构，因为声明一个HashMap&lt;&gt;()时初始值是16（这时候是数组+链表的数据结构），当插入的数据超过设置的负载因子（默认是0.75，定义是存放元素个数占总元素个数的比重）会进行扩容机制，当链表长度超过8个，数组长度超过64个这两个条件同时满足，则会采用红黑树来存储数组上同一槽位的元素，使用红黑树的时间复杂度是O（log n）。</p>
</li>
<li><p><strong>扩展：HashMap的扩容机制</strong></p>
<ul>
<li><p>hashMap默认的负载因子是0.75，即如果hashmap中的元素个数超过了总容量75%，则会触发扩容机制。第一步，<strong>将哈希表（数组）长度扩大到原来的两倍得到新的哈希表</strong>，第二步，<strong>将原哈希表的数据迁移到新的哈希表</strong>。</p>
</li>
<li><p><strong>JDK1.7和JDK1.8之间扩容原理的区别</strong>：</p>
</li>
<li><p>在 JDK1.7 中，HashMap 整个扩容过程就是分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，，依据每个被遍历元素的 hash 值（%新的长度，例如16扩大到32，则进行和32的取模运算得到的哈希值）计算其在新数组中的下标，然后进行交换。这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。</p>
</li>
<li><p>而在 JDK 1.8 中，HashMap 对扩容操作做了优化。利用高低位运算进行判断，如果判断是高位运算则移动到新的哈希值位置，低位则保持原来相对位置不变，大大提升了扩容的性能，然后采用的是尾插法，之所以能通过这种“与运算“来重新分配索引，是因为 hash 值本来就是随机的，而 hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处）就是随机的，所以扩容的过程就能把之前哈希冲突的元素再随机分布到不同的索引中去。</p>
</li>
</ul>
</li>
</ul>
<h5 id="2-线程池的参数有哪些"><a href="#2-线程池的参数有哪些" class="headerlink" title="2.线程池的参数有哪些"></a>2.线程池的参数有哪些</h5><ul>
<li><p><strong>corePoolSize</strong>:线程池核心线程数量。默认情况下，线程池中线程的数量如果 &lt;&#x3D; corePoolSize，那么即使这些线程处于空闲状态，那也不会被销毁。</p>
</li>
<li><p><strong>maxmiumPoolSize</strong>:限制了线程池能创建的<strong>最大线程总数</strong>（包括核心线程和非核心线程），当 corePoolSize 已满并且尝试将新任务加入阻塞队列失败（即队列已满）并且 当前线程数 &lt; maximumPoolSize，就会创建新线程执行此任务，但是当 corePoolSize 满 并且 队列满 并且线程数已达 maximumPoolSize并且 又有新任务提交时，就会触发拒绝策略。</p>
</li>
<li><p><strong>keepAliveTime</strong>:当线程池中线程的数量大于corePoolSize，并且某个线程的空闲时间超过keepAliveTime，那么这个线程就会被销毁。</p>
</li>
<li><p><strong>unit</strong>:就是keepAliveTime时间的单位。</p>
</li>
<li><p><strong>workQueue</strong>:工作队列。当没有空闲的线程执行新任务时，该任务就会被放入工作队列中，等待执行。</p>
</li>
<li><p><strong>threadFactory</strong>:线程工厂。可以用来给线程取名字等等</p>
</li>
<li><p><strong>handler</strong>:拒绝策略。当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，如果没有空闲的线程，就会将该任务加入到阻塞队列中，如果阻塞队列满了，就会创建一个新线程，从阻塞队列头部取出一个任务来执行，并将新任务加入到阻塞队列末尾。如果当前线程池中线程的数量等于maximumPoolSize，就不会创建新线程，就会去执行拒绝策略。</p>
</li>
</ul>
<h5 id="3-实战当中如何开启一个新的线程，代码细节"><a href="#3-实战当中如何开启一个新的线程，代码细节" class="headerlink" title="3.实战当中如何开启一个新的线程，代码细节"></a>3.实战当中如何开启一个新的线程，代码细节</h5><h5 id="4-具体讲讲Spring当中AOP的底层"><a href="#4-具体讲讲Spring当中AOP的底层" class="headerlink" title="4.具体讲讲Spring当中AOP的底层"></a>4.具体讲讲Spring当中AOP的底层</h5><ul>
<li>Spring AOP的实现依赖于**动态代理技术。**动态代理是在运行时动态生成代理对象，而不是在编译时。它允许开发者在运行时指定要代理的接口和行为，从而实现在不修改源码的情况下增强方法的功能。主要用于在不修改原始类的情况下对方法调用进行拦截和增强。<ul>
<li><p><strong>基于接口的代理</strong>（JDK动态代理）： 这种类型的代理要求目标对象必须实现至少一个接口。Java动态代理会创建一个实现了相同接口的代理类，然后在运行时动态生成该类的实例。这种代理的实现核心是java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口。每一个动态代理类都必须实现InvocationHandler接口，并且每个代理类的实例都关联到一个handler。当通过代理对象调用一个方法时，这个方法的调用会被转发为由InvocationHandler接口的invoke()方法来进行调用。</p>
</li>
<li><p><strong>基于类的代理</strong>（CGLIB动态代理）： CGLIB（Code Generation Library）是一个强大的高性能的代码生成库，它可以在运行时动态生成一个目标类的子类。CGLIB代理不需要目标类实现接口，而是通过继承的方式创建代理类。因此，如果目标对象没有实现任何接口，可以使用CGLIB来创建动态代理。</p>
</li>
</ul>
</li>
</ul>
<h5 id="5-bean的生命周期"><a href="#5-bean的生命周期" class="headerlink" title="5.bean的生命周期"></a>5.bean的生命周期</h5><ul>
<li><p>1.Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</p>
</li>
<li><p>2.Bean实例化后对将Bean的引入和值注入到Bean的属性中</p>
</li>
<li><p>3.如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</p>
</li>
<li><p>4.如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</p>
</li>
<li><p>5.如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</p>
</li>
<li><p>6.如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</p>
</li>
<li><p>7如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</p>
</li>
<li><p>8.如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</p>
</li>
<li><p>9.此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</p>
</li>
<li><p>10.如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</p>
</li>
</ul>
<h5 id="6-spring是怎么解决循环依赖的"><a href="#6-spring是怎么解决循环依赖的" class="headerlink" title="6.spring是怎么解决循环依赖的"></a>6.spring是怎么解决循环依赖的</h5><ul>
<li><p>循环依赖指的是两个类中的属性相互依赖对方：例如 A 类中有 B 属性，B 类中有 A属性，从而形成依赖闭环</p>
</li>
<li><p>循环依赖问题在Spring中主要有三种情况：</p>
<ul>
<li><p>第一种：通过构造方法进行依赖注入时产生的循环依赖问题</p>
</li>
<li><p>第二种：通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题</p>
</li>
<li><p>第三种：通过setter方法进行依赖注入在单例模式下产生的循环依赖问题</p>
</li>
<li><p>只有【第三种方式】的循环依赖问题被 Spring 解决了，其他两种方式在遇到循环依赖问题时，Spring都会抛出异常</p>
</li>
</ul>
</li>
<li><p>Spring通过三级缓存机制来解决，在DefaultSingletonBeanRegistry 类中维护了三个重要的缓存 (Map)：</p>
<ul>
<li><p>singletonObjects (一级缓存)：存放的是完全初始化好的、可用的 Bean 实例，getBean() 方法最终返回的就是这里面的 Bean。此时 Bean 已实例化、属性已填充、初始化方法已执行、AOP 代理（如果需要）也已生成。</p>
</li>
<li><p>earlySingletonObjects (二级缓存)：存放的是提前暴露的 Bean 的原始对象引用或早期代理对象引用，专门用来处理循环依赖。当一个 Bean 还在创建过程中（尚未完成属性填充和初始化），但它的引用需要被注入到另一个 Bean 时，此时 Bean 已实例化（调用了构造函数），但属性尚未填充，初始化方法尚未执行，它可能是一个原始对象，也可能是一个为了解决 AOP 代理问题而提前生成的代理对象。</p>
</li>
<li><p>singletonFactories (三级缓存)：存放的是 Bean 的 ObjectFactory 工厂对象。这是解决循环依赖和 AOP 代理协同工作的关键。当 Bean 被实例化后（刚调完构造函数），Spring 会创建一个 ObjectFactory 并将其放入三级缓存。这个工厂的 getObject() 方法负责返回该 Bean 的早期引用（可能是原始对象，也可能是提前生成的代理对象），当检测到循环依赖需要注入一个尚未完全初始化的 Bean 时，就会调用这个工厂来获取早期引用。</p>
</li>
<li><p>Spring 通过<strong>三级缓存</strong>和<strong>提前暴露未完全初始化的对象引用</strong>的机制来解决单例作用域 Bean 的 sette注入方式的循环依赖问题。</p>
</li>
</ul>
</li>
<li><p>Spring三级缓存机制的详细步骤</p>
<ul>
<li><p>第一步：<strong>创建BeanA的实例并提前暴露工厂</strong>。Spring首先调用BeanA的构造函数进行实例化，此时得到一个原始对象（尚未填充属性）。紧接着，Spring会将一个特殊的ObjectFactory工厂对象存入第三级缓存（singletonFactories）。    这个工厂的使命是：当其他Bean需要引用BeanA时，它能动态返回当前这个半成品的BeanA（可能是原始对象，也可能是为应对AOP而提前生成的代理对象）。此时BeanA的状态是”已实例化但未初始化”，像一座刚搭好钢筋骨架的大楼。</p>
</li>
<li><p>第二步：<strong>填充BeanA的属性时触发BeanB的创建</strong>。Spring开始为BeanA注入属性，发现它依赖BeanB。于是容器转向创建BeanB，同样先调用其构造函数实例化，并将BeanB对应的ObjectFactory工厂存入三级缓存。至此，三级缓存中同时存在BeanA和BeanB的工厂，它们都代表未完成初始化的半成品。</p>
</li>
<li><p>第三步：<strong>BeanB属性注入时发现循环依赖</strong>。当Spring试图填充BeanB的属性时，检测到它需要注入BeanA。此时容器启动依赖查找：</p>
<ul>
<li>1.在一级缓存（存放完整Bean）中未找到BeanA；</li>
</ul>
</li>
<li><p>2.在二级缓存（存放已暴露的早期引用）中同样未命中；</p>
</li>
<li><p>3.最终在三级缓存中定位到BeanA的工厂。</p>
</li>
<li><p>Spring立即调用该工厂的getObject()方法。这个方法会执行关键决策：若BeanA需要AOP代理，则动态生成代理对象（即使BeanA还未初始化）；若无需代理，则直接返回原始对象。得到的这个早期引用（可能是代理）被放入二级缓存（earlySingletonObjects），同时从三级缓存清理工厂条目。最后，Spring将这个早期引用注入到BeanB的属性中。至此，BeanB成功持有BeanA的引用–尽管BeanA此时仍是个半成品。</p>
</li>
<li><p>第四步：<strong>完成BeanB的生命周期</strong>。BeanB获得所有依赖后，Spring执行其初始化方法（如@PostConstruct），将其转化为完整可用的Bean。随后，BeanB被提升至一级缓存（singletonObjects），二级和三级缓存中关于BeanB的临时条目均被清除。此时BeanB已准备就绪，可被其他对象使用。</p>
</li>
<li><p>第五步：<strong>回溯完成BeanA的构建</strong>。随着BeanB创建完毕，流程回溯到最初中断的BeanA属性注入环节。Spring将已完备的BeanB实例注入BeanA，接着执行BeanA的初始化方法。这里有个精妙细节：若之前为BeanA生成过早期代理，Spring会直接复用二级缓存中的代理对象作为最终Bean，而非重复构建。最终，完全初始化的BeanA（可能是原始对象或代理）入驻一级缓存，其早期引用从二级缓存当中移除。至此循环闭环完成，两个Bean皆可用。</p>
</li>
</ul>
</li>
<li><p>三级缓存的设计的精髓：</p>
<ul>
<li>三级缓存工厂（singletonFactories）负责实例化后立刻暴露对象生成能力，兼顾AOP代理的提前生成；</li>
</ul>
</li>
<li><p>二级缓存（earlySingletonObjects）临时存储已确定的早期引用，避免重复生成代理；</p>
</li>
<li><p>一级缓存（singletonObjects）最终交付完整Bean。</p>
</li>
<li><p>整个机制通过中断<strong>初始化流程</strong>、<strong>逆向注入半成品</strong>、<strong>延迟代理生成</strong>三大策略，将循环依赖的死结转化为有序的接力协作。值得注意的是，此方案仅适用于Setter&#x2F;Field注入的单例Bean；构造器注入因必须在实例化前获得依赖，仍会导致无解的死锁。</p>
</li>
</ul>
<h5 id="7-采用spring当中构造函数方法注入，会产生循环依赖吗"><a href="#7-采用spring当中构造函数方法注入，会产生循环依赖吗" class="headerlink" title="7.采用spring当中构造函数方法注入，会产生循环依赖吗"></a>7.采用spring当中构造函数方法注入，会产生循环依赖吗</h5><ul>
<li>根据上面回答，会。</li>
</ul>
<h5 id="8-计算机网络模型有哪几层，TCP是哪一层，IP是哪一层"><a href="#8-计算机网络模型有哪几层，TCP是哪一层，IP是哪一层" class="headerlink" title="8.计算机网络模型有哪几层，TCP是哪一层，IP是哪一层"></a>8.计算机网络模型有哪几层，TCP是哪一层，IP是哪一层</h5><ul>
<li>五层：应用层–运输层–网络层–数据链路层–物理层，TCP协议是运输层，IP是网络层</li>
</ul>
<h5 id="9-详细介绍一下TCP三次握手"><a href="#9-详细介绍一下TCP三次握手" class="headerlink" title="9.详细介绍一下TCP三次握手"></a>9.详细介绍一下TCP三次握手</h5><ul>
<li><p>TCP是面向连接的协议，是遵循可靠运输这一特性的。所以使用 TCP 前必须先建立连接，而建立连接是通过三次握手来进行的</p>
</li>
<li><p>一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态</p>
</li>
<li><p>客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。</p>
</li>
<li><p>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。</p>
</li>
<li><p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。</p>
</li>
<li><p>服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。</p>
</li>
<li><p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，一旦完成三次握手，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
</li>
</ul>
<h5 id="10-那TCP四次握手呢"><a href="#10-那TCP四次握手呢" class="headerlink" title="10.那TCP四次握手呢"></a>10.那TCP四次握手呢</h5><ul>
<li><p>TCP断开连接的过程是通过<strong>四次挥手</strong>的方式，双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</p>
</li>
<li><p>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</p>
</li>
<li><p>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSE_WAIT 状态。</p>
</li>
<li><p>客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。</p>
</li>
<li><p>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</p>
</li>
<li><p>客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态</p>
</li>
<li><p>服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。</p>
</li>
<li><p>客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。</p>
</li>
<li><p>你可以看到，每个方向都需要<strong>一个 FIN</strong> 和<strong>一个 ACK</strong>，因此通常被称为四次挥手。这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态</strong>。</p>
</li>
</ul>
<h4 id="反问环节"><a href="#反问环节" class="headerlink" title="反问环节"></a>反问环节</h4><h5 id="1-通过这次面试，能否给我一些建议"><a href="#1-通过这次面试，能否给我一些建议" class="headerlink" title="1.通过这次面试，能否给我一些建议"></a>1.通过这次面试，能否给我一些建议</h5><ul>
<li>对于java一整套生态，不仅要会用这些工具，还要懂得其中的原理</li>
</ul>
<h5 id="2-你们公司是做什么业务的"><a href="#2-你们公司是做什么业务的" class="headerlink" title="2.你们公司是做什么业务的"></a>2.你们公司是做什么业务的</h5><ul>
<li>我们公司做crm系统的，我所在的组是营销组，平时你在网上看到那些广告类似招聘，都是我们业务相关的</li>
</ul>
<p> 总结一下，只能答出来一半多点，还是对其中细节记忆太少了，只能记得大概和关键字，面试官一旦追究里面的细节立马哑口无言</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/10/19/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9301%EF%BC%9A%E7%BA%B7%E4%BA%AB%E9%94%80%E5%AE%A2%E4%B8%80%E9%9D%A2/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/10/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%8701%EF%BC%9A%E7%B4%A2%E5%BC%95/">
        <h2 class="post-title">数据库篇01：索引</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/10/16
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><ul>
<li>**索引是帮助MySQL高效获取库内数据的数据结构。**举个例子，当我们想查询书的具体内容时，难不成一页一页的翻看吗？-肯定不是，正常人都会先去书中的目录查看内容的大体位置，在这个场景当中，目录就相当于数据库的索引</li>
</ul>
<h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><ul>
<li><p>按<strong>数据结构</strong>进行分类：<strong>B++树索引</strong>（InnoDB引擎默认），哈希索引，Full-text索引</p>
</li>
<li><p>按<strong>物理存储</strong>进行分类：聚簇索引（主键索引），二级索引</p>
</li>
<li><p>按<strong>字段特性</strong>分类：主键索引，唯一索引，普通索引，前缀索引</p>
</li>
<li><p>按<strong>字段个数</strong>分类：单列索引，联合索引</p>
</li>
</ul>
<h5 id="MySQL的默认引擎InnoDB为什么采用B-树结构作为索引"><a href="#MySQL的默认引擎InnoDB为什么采用B-树结构作为索引" class="headerlink" title="MySQL的默认引擎InnoDB为什么采用B++树结构作为索引"></a>MySQL的默认引擎InnoDB为什么采用B++树结构作为索引</h5><ul>
<li><p>因为相比较B树而言，B++树只在叶子节点存储实际的数据，非叶子节点仅存储引用键值和指针，因此占用在页的空间会比较小，所需的层级比较少，提高了搜索的效率</p>
</li>
<li><p>叶子节点之间各自增加了指向相邻节点的链表指针，提高区间内访问的性能</p>
</li>
<li><p>相较于Hash索引，支持区间范围查询，因为叶子节点是双向链表</p>
</li>
</ul>
<h4 id="索引会失效的场景有哪些"><a href="#索引会失效的场景有哪些" class="headerlink" title="索引会失效的场景有哪些"></a>索引会失效的场景有哪些</h4><ul>
<li><p>1.<strong>违反最左前缀法则</strong>：该法则指的是查询从索引的最左列开始，中间不要跳过索引中的列。</p>
</li>
<li><p>2.<strong>范围查询右边的列不能使用索引</strong></p>
</li>
<li><p>3.<strong>不要在索引上进行运算操作</strong></p>
</li>
<li><p>4.<strong>字符串不加单引号</strong>（原本索引是有的），导致类型发生了转换</p>
</li>
<li><p>5.<strong>以%开头的like模糊查询</strong></p>
</li>
</ul>
<h5 id="聚簇索引，非聚簇索引，回表查询"><a href="#聚簇索引，非聚簇索引，回表查询" class="headerlink" title="聚簇索引，非聚簇索引，回表查询"></a>聚簇索引，非聚簇索引，回表查询</h5><ul>
<li><p><strong>聚簇索引</strong>：数据与索引放在一块，B+树的叶子节点保存了整行数据，有且只有一个</p>
</li>
<li><p><strong>非聚簇索引</strong>（二级索引）：数据与索引分开存储，B++树的叶子节点保存对应的主键，可以有多个</p>
</li>
<li><p><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚簇索引中查找整行数据，这个过程就是回表</p>
</li>
</ul>
<h5 id="MySQL分页处理优化"><a href="#MySQL分页处理优化" class="headerlink" title="MySQL分页处理优化"></a>MySQL分页处理优化</h5><ul>
<li><p>首先明白，MySQL进行分页查询所使用的字段是limit，对应 limit offset, size 和 limit size 两种方式。也就是说，两种方式的区别在于<strong>offset是否为0</strong>。	</p>
<ul>
<li><p>例如sql语句：select * from page order by id limit 0, 10; –server层会调用innodb的接口，在innodb里的主键索引中获取到第0到10条完整行数据，依次返回给server层，并放到server层的结果集中，返回给客户端。</p>
</li>
<li><p>但是如果执行的sql语句是select * from page order by id limit 6000000, 10; –server层会调用innodb的接口，由于这次的offset&#x3D;6000000，会在innodb里的主键索引中获取到第0到（6000000 + 10）条完整行数据，返回给server层之后根据offset的值挨个抛弃，最后只留下最后面的size条，也就是10条数据，放到server层的结果集中，返回给客户端。可以看出，当offset非0时，server层会从引擎层获取到很多无用的数据，而获取的这些无用数据都是要耗时的。</p>
</li>
<li><p><strong>因此，mysql查询中 limit 1000,10 会比 limit 10 更慢。原因是 limit 1000,10 会取出1000+10条数据，并抛弃前1000条，这部分耗时更大</strong></p>
</li>
</ul>
</li>
<li><p>如何优化？使用覆盖索引</p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/10/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%8701%EF%BC%9A%E7%B4%A2%E5%BC%95/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/10/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%9702%EF%BC%9A%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E9%97%AE%E9%A2%98/">
        <h2 class="post-title">消息队列02：个人总结问题</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/10/13
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="消息队列的使用场景有哪些"><a href="#消息队列的使用场景有哪些" class="headerlink" title="消息队列的使用场景有哪些"></a>消息队列的使用场景有哪些</h4><ul>
<li><p><strong>解耦</strong>：可以在多个系统之间进行解耦，将原本通过网络之间的调用的方式改为使用MQ进行消息的异步通讯，只要该操作不是需要同步的，就可以改为使用MQ进行不同系统之间的联系，这样项目之间不会存在耦合，系统之间不会产生太大的影响，就算一个系统挂了，也只是消息挤压在MQ里面没人进行消费而已，不会对其他的系统产生影响。</p>
</li>
<li><p><strong>异步</strong>：加入一个操作设计到好几个步骤，这些步骤之间不需要同步完成，比如客户去创建了一个订单，还要去客户轨迹系统添加一条轨迹、去库存系统更新库存、去客户系统修改客户的状态等等。这样如果这个系统都直接进行调用，那么将会产生大量的时间，这样对于客户是无法接收的；并且像添加客户轨迹这种操作是不需要去同步操作的，如果使用MQ将客户创建订单时，将后面的轨迹、库存、状态等信息的更新全都放到MQ里面然后去异步操作，这样就可加快系统的访问速度，提供更好的客户体验。</p>
</li>
<li><p><strong>削峰</strong>：一个系统访问流量有高峰时期，也有低峰时期，比如说，中午整点有一个抢购活动等等。比如系统平时流量并不高，一秒钟只有100多个并发请求，系统处理没有任何压力，一切风平浪静，到了某个抢购活动时间，系统并发访问了剧增，比如达到了每秒5000个并发请求，而我们的系统每秒只能处理2000个请求，那么由于流量太大，我们的系统、数据库可能就会崩溃。这时如果使用MQ进行流量削峰，将用户的大量消息直接放到MQ里面，然后我们的系统去按自己的最大消费能力去消费这些消息，就可以保证系统的稳定，只是可能要跟进业务逻辑，给用户返回特定页面或者稍后通过其他方式通知其结果。</p>
</li>
</ul>
<h4 id="消息重复消费怎么解决"><a href="#消息重复消费怎么解决" class="headerlink" title="消息重复消费怎么解决"></a>消息重复消费怎么解决</h4><ul>
<li><p>生产端为了保证消息发送成功，可能会重复推送(直到收到成功ACK)，会产生重复消息。但是一个成熟的MQ Server框架一般会想办法解决，避免存储重复消息(比如：空间换时间，存储已处理过的message_id)，给生产端提供一个幂等性的发送消息接口。	</p>
</li>
<li><p>但是消费端却无法根本解决这个问题，在高并发标准要求下，拉取消息+业务处理+提交消费位移需要做事务处理，另外消费端服务可能宕机，很可能会拉取到重复消息。</p>
</li>
<li><p>所以，只能业务端自己做控制，<strong>对于已经消费成功的消息，本地数据库表或Redis缓存业务标识，每次处理前先进行校验，保证幂等。</strong></p>
</li>
</ul>
<h4 id="如何保证幂等写"><a href="#如何保证幂等写" class="headerlink" title="如何保证幂等写"></a>如何保证幂等写</h4><ul>
<li><p>幂等性是指**同一操作的多次执行对系统状态的影响与一次执行结果一致。**例如，支付接口若因网络重试被多次调用，最终应确保仅扣款一次。实现幂等写的核心方案：</p>
<ul>
<li><p>唯一标识（幂等键）：客户端为每个请求生成全局唯一ID（如 UUID、业务主键），服务端校验该ID是否已处理，适用场景接口调用、消息消费等。</p>
</li>
<li><p>数据库事务 + 乐观锁：通过版本号或状态字段控制并发更新，确保多次更新等同于单次操作，适用场景数据库记录更新（如余额扣减、订单状态变更）。</p>
</li>
<li><p>数据库唯一约束：利用数据库唯一索引防止重复数据写入，适用于数据插入场景（如订单创建）。</p>
</li>
<li><p>分布式锁：通过锁机制保证同一时刻仅有一个请求执行关键操作，适用场景高并发下的资源抢夺（如秒杀）。</p>
</li>
<li><p>消息去重：消息队列生产者为每条消息生成唯一的消息 ID，消费者在处理消息前，先检查该消息 ID 是否已经处理过，如果已经处理过则丢弃该消息。</p>
</li>
</ul>
</li>
</ul>
<h4 id="消息挤压问题如何解决"><a href="#消息挤压问题如何解决" class="headerlink" title="消息挤压问题如何解决"></a>消息挤压问题如何解决</h4><ul>
<li><p>消息积压是因为生产者的生产速度，大于消费者的消费速度。</p>
</li>
<li><p>从消费者角度出发：</p>
<ul>
<li><p>增加多个消费者，保证消息接受速度大于生产者发送消息的速度</p>
</li>
<li><p>消费者模块使用线程池开启多线程进行并发处理，提高消息处理速度</p>
</li>
</ul>
</li>
<li><p>队列进行水平扩容，增加Topic的队列数，和消费组机器的数量，提升整体消费能力。</p>
</li>
<li><p>使用惰性队列，惰性队列将接收的信息直接存入磁盘而非内存当中，只有当消费者要消费信息的时候才将信息从磁盘当中读取并加载到内存当中，支持数百万条级别的消息存储。</p>
</li>
</ul>
<h4 id="RocketMQ和RabbitMQ的特性和区别"><a href="#RocketMQ和RabbitMQ的特性和区别" class="headerlink" title="RocketMQ和RabbitMQ的特性和区别"></a>RocketMQ和RabbitMQ的特性和区别</h4><h5 id="RocketMQ："><a href="#RocketMQ：" class="headerlink" title="RocketMQ："></a>RocketMQ：</h5><ul>
<li><p><strong>开发语言优势</strong>：首先，它是阿里巴巴开源的消息中间件，支持功能比较多，比如延迟队列、消息事务等等，吞吐量也高，单机吞吐量达到 10 万级，支持大规模集群部署，线性扩展方便，<strong>Java语言开发</strong>，在进行排查，阅读源码并进行分析的时候底层查询更方便，满足了国内绝大部分公司技术栈。</p>
</li>
<li><p><strong>社区氛围浓厚</strong>：RocketMQ 是阿里巴巴开源且内部在大量使用的消息队列，说明 RocketMQ 是的确经得起残酷的生产环境考验的，并且能够针对线上环境复杂的需求场景提供相应的解决方案。</p>
</li>
<li><p><strong>特性丰富</strong>：根据 RocketMQ 官方文档的列举，其高级特性达到了 12 种，能够为我们在复杂的业务场景下尽可能多地提供思路及解决方案。</p>
</li>
</ul>
<h5 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ul>
<li><p><strong>时效性</strong>：RabbitMQ的消息时效是微秒级别的，而RocketMQ是毫秒级别的。</p>
</li>
<li><p><strong>持久化机制</strong>：RabbitMQ 支持消息、队列和交换器的持久化。当启用持久化时，消息会被写入磁盘，即使 RabbitMQ 服务器重启，消息也不会丢失。例如，在声明队列时可以设置 durable 参数为 true 来实现队列的持久化</p>
</li>
<li><p><strong>支持主题数</strong>：RabbitMQ是百万级别的，RocketMQ是千级别的。</p>
</li>
<li><p>相比较而言，容易快速上手和部署</p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/10/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%9702%EF%BC%9A%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E9%97%AE%E9%A2%98/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/10/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9A%BE%E7%82%B901%EF%BC%9AMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
        <h2 class="post-title">消息队列难点01：MQ常见问题以及消息的可靠性</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/10/13
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="如何解决消息丢失问题"><a href="#如何解决消息丢失问题" class="headerlink" title="如何解决消息丢失问题"></a>如何解决消息丢失问题</h4><h5 id="消息可靠性问题"><a href="#消息可靠性问题" class="headerlink" title="消息可靠性问题"></a>消息可靠性问题</h5><ul>
<li><p>消息从生产者发送到交换机，再发送到对应的队列，最后才传递到消费者，有哪些导致消息丢失的情况？</p>
<ul>
<li><p>发送时丢失：</p>
<ul>
<li><p>发送的消息未到达交换机丢失</p>
</li>
<li><p>消息到达交换机后未发送到队列丢失</p>
</li>
</ul>
</li>
<li><p>队列丢失：</p>
<ul>
<li>MQ宕机了，队列中的消息丢失</li>
</ul>
</li>
<li><p>消费者丢失：</p>
<ul>
<li>消费者接受到消息未消费宕机丢失</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="如何保障消息的可靠性"><a href="#如何保障消息的可靠性" class="headerlink" title="如何保障消息的可靠性"></a>如何保障消息的可靠性</h5><ul>
<li><p><strong>消息确认机制</strong>：消费者在成功处理消息后，应该向消息队列发送确认ack信号。消息队列只有收到确认后，才会将消息从队列中移除。如果没有收到确认或者返回nack信号，消息队列可能会在一定时间后重新发送消息给其他消费者或者再次发送给同一个消费者。以 Kafka 为例，消费者通过commitSync或者commitAsync方法来提交偏移量（offset），从而确认消息的消费。</p>
</li>
<li><p><strong>消息持久化</strong>：在系统崩溃、重启或者网络故障等情况下，未处理的消息不应丢失。MQ默认情况下是用内存来存储信息，需要调用相关api来开启持久化功能。例如，像 RabbitMQ 可以通过配置将消息持久化到磁盘，通过将队列和消息都设置为持久化的方式（设置durable &#x3D; true），这样在服务器重启后，消息依然可以被重新读取和处理。</p>
</li>
<li><p><strong>消息重试策略</strong>：当消费者处理消息失败时，需要有合理的重试策略。默认情况下会不断requeue发送给消费者，给消息队列带来不必要巨大压力。可以利用spring的Retry机制进行本地重试。设置重试次数和重试间隔时间。例如，在第一次处理失败后，等待一段时间（如 5 秒）后进行第二次重试，如果重试多次（如 3 次）后仍然失败，默认情况是重试耗尽后直接丢弃信息，或者返回nack，也可以将消息发送到<strong>死信队列</strong>，以便后续人工排查或者采取其他特殊处理。</p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/10/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9A%BE%E7%82%B901%EF%BC%9AMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/09/23/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B05%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A802/">
        <h2 class="post-title">JUC并发编程05：java并发安全02</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/23
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="Java中是如何保证线程安全的"><a href="#Java中是如何保证线程安全的" class="headerlink" title="Java中是如何保证线程安全的"></a>Java中是如何保证线程安全的</h4><ul>
<li><p><strong>synchronized关键字</strong>:可以使用synchronized关键字来同步代码块或方法，确保同一时刻只有一个线程可以访问这些代码。对象锁是通过synchronized关键字锁定对象的监视器（monitor）来实现的。</p>
</li>
<li><p><strong>volatile关键字</strong>:volatile关键字用于变量，确保所有线程看到的是该变量的最新值，而不是可能存储在本地寄存器中的副本。</p>
</li>
<li><p><strong>Lock接口和ReentrantLock类</strong>:java.util.concurrent.locks.Lock接口提供了比synchronized更强大的锁定机制，ReentrantLock是一个实现该接口的例子，提供了更灵活的锁管理和更高的性能。</p>
</li>
<li><p><strong>原子类</strong>：Java并发库（java.util.concurrent.atomic）提供了原子类如AtomicInteger、AtomicLong等，这些类提供了原子操作，可以用于更新基本类型的变量而无需额外的同步。</p>
</li>
<li><p><strong>线程局部变量</strong>:ThreadLocal类可以为每个线程提供独立的变量副本，这样每个线程都拥有自己的变量，消除了竞争条件。</p>
</li>
<li><p><strong>并发集合</strong>:使用java.util.concurrent包中的线程安全集合，如ConcurrentHashMap、ConcurrentLinkedQueue等，这些集合内部已经实现了线程安全的逻辑。</p>
</li>
<li><p><strong>JUC工具类</strong>: 使用java.util.concurrent包中的一些工具类可以用于控制线程间的同步和协作。例如：Semaphore和CyclicBarrier等。</p>
</li>
</ul>
<h4 id="synchronized关键词"><a href="#synchronized关键词" class="headerlink" title="synchronized关键词"></a>synchronized关键词</h4><h5 id="synchronized关键词是什么-有什么用"><a href="#synchronized关键词是什么-有什么用" class="headerlink" title="synchronized关键词是什么?有什么用?"></a>synchronized关键词是什么?有什么用?</h5><ul>
<li><p>synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
</li>
<li><p>在 Java 早期版本中，synchronized 属于重量级锁，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
</li>
<li><p>不过，在 Java 6 之后， synchronized 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 synchronized 锁的效率提升了很多。因此， synchronized 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 synchronized 。</p>
</li>
</ul>
<h5 id="synchronized关键词的底层原理"><a href="#synchronized关键词的底层原理" class="headerlink" title="synchronized关键词的底层原理"></a>synchronized关键词的底层原理</h5><ul>
<li><p>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</p>
</li>
<li><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取而代之的是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。</p>
</li>
<li><p><strong>两个本质都是对锁监视器monitor的获取</strong></p>
</li>
</ul>
<h5 id="synchronized和volatile关键字有什么区别"><a href="#synchronized和volatile关键字有什么区别" class="headerlink" title="synchronized和volatile关键字有什么区别"></a>synchronized和volatile关键字有什么区别</h5><ul>
<li><strong>两者是互补的关系，不是对立的关系</strong><ul>
<li><p>volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。</p>
</li>
<li><p>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</p>
</li>
<li><p>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</p>
</li>
</ul>
</li>
</ul>
<h5 id="介绍ReentrantLock"><a href="#介绍ReentrantLock" class="headerlink" title="介绍ReentrantLock"></a>介绍ReentrantLock</h5><ul>
<li><p>ReentrantLock 实现了 Lock 接口，是一个可重入且独占式的锁，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>
</li>
<li><p>ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS，添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。</p>
</li>
</ul>
<h5 id="公平锁和非公平锁之间的区别"><a href="#公平锁和非公平锁之间的区别" class="headerlink" title="公平锁和非公平锁之间的区别"></a>公平锁和非公平锁之间的区别</h5><ul>
<li><p>公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p>
</li>
<li><p>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p>
</li>
</ul>
<h5 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h5><ul>
<li><p>相同点：<strong>都是可重入锁</strong>。</p>
<ul>
<li>可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</li>
</ul>
</li>
<li><p>不同点：<strong>synchronized依赖于JVM而ReentrantLock依赖于API</strong></p>
<ul>
<li><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p>
</li>
<li><p>ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
</li>
</ul>
</li>
</ul>
<h5 id="线程池常见的参数"><a href="#线程池常见的参数" class="headerlink" title="线程池常见的参数"></a>线程池常见的参数</h5><ul>
<li><p><strong>线程池的构造函数（ThreadPoolExecutor）有7个核心参数</strong>：</p>
<ul>
<li><p><strong>corePoolSize</strong> : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</p>
</li>
<li><p><strong>maximumPoolSize</strong> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</p>
</li>
<li><p><strong>workQueue</strong>: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
</li>
<li><p>keepAliveTime:当线程池中的线程数量大于 corePoolSize ，即有非核心线程（线程池中核心线程以外的线程）时，这些非核心线程空闲后不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime才会被回收销毁。</p>
</li>
<li><p>unit : keepAliveTime 参数的时间单位。</p>
</li>
<li><p>threadFactory :executor 创建新线程的时候会用到。</p>
</li>
<li><p>handler :拒绝策略（后面会单独详细介绍一下）。</p>
</li>
</ul>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/09/23/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B05%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A802/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    <a class="page-num" href="/page/2">
        2
    </a>
    
    
    <a class="page-num" href="/page/3">
        3
    </a>
    
    
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">David Huang</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 UNCEIR的个人博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;David Huang
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
