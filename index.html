
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>UNCEIR的个人博客</title>
    <meta name="author" content="David Huang" />
    <meta name="description" content="广东工业大学信息管理与信息系统专业的一名大三学生，未来想从事后端开发，请多指教。" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>UNCEIR的个人博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;UNCEIR的个人博客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>UNCEIR的个人博客</h1>
                <h3>欢迎光临www</h3>
                <h5>广东工业大学信息管理与信息系统专业的一名大三学生，未来想从事后端开发，请多指教。</h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2025/12/09/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%8306/">
        <h2 class="post-title">八股训练06</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/12/9
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>这是一个非常全面且经典的Java后端面试题库，涵盖了<strong>Java基础、并发编程、JVM、MySQL数据库、Redis、中间件（Kafka）、操作系统&#x2F;容器以及微服务架构</strong>。</p>
<p>以下是针对这37道题目的精简、核心的回答思路，适合面试时快速输出重点。</p>
<hr>
<h3 id="一、-Java基础与容器"><a href="#一、-Java基础与容器" class="headerlink" title="一、 Java基础与容器"></a>一、 Java基础与容器</h3><p><strong>1、StringBuilder和StringBuffer有什么区别？</strong></p>
<ul>
<li><strong>线程安全：</strong> <code>StringBuffer</code> 是线程安全的（方法加了 <code>synchronized</code>），<code>StringBuilder</code> 是非线程安全的。</li>
<li><strong>性能：</strong> <code>StringBuilder</code> 性能更高，因为没有锁的开销。</li>
<li><strong>场景：</strong> 单线程字符串拼接用 <code>StringBuilder</code>，多线程并发拼接用 <code>StringBuffer</code>。</li>
</ul>
<p><strong>2、关于线程安全，Java中还有哪些常用类是线程安全的？（如CopyOnWriteArrayList了解吗）</strong></p>
<ul>
<li><strong>常用类：</strong> <code>Vector</code>（老旧）、<code>Hashtable</code>（老旧）、<code>ConcurrentHashMap</code>（并发常用）。</li>
<li><strong>CopyOnWriteArrayList：</strong><ul>
<li><strong>原理：</strong> 写时复制。往容器添加元素时，不直接操作原数组，而是复制一个新的数组，在旧数组上读，在新数组上写，写完将引用指向新数组。</li>
<li><strong>场景：</strong> 读多写少（如白名单、黑名单配置），因为写操作开销大且数据一致性较弱（最终一致性）。</li>
</ul>
</li>
</ul>
<p><strong>3、finally中的代码无论什么情况下一定会执行吗？</strong></p>
<ul>
<li><strong>大部分情况：</strong> 是。</li>
<li><strong>不执行的情况：</strong><ul>
<li><code>try</code> 块执行前线程就结束了。</li>
<li><code>try</code> 或 <code>catch</code> 中调用了 <code>System.exit(0)</code> 退出JVM。</li>
<li>守护线程在非守护线程全部结束时可能来不及执行 <code>finally</code>。</li>
<li>物理断电或JVM崩溃。</li>
</ul>
</li>
</ul>
<p><strong>4、HashMap的底层数据结构说一下？</strong></p>
<ul>
<li><strong>JDK 1.7：</strong> 数组 + 链表（头插法，易造成死循环）。</li>
<li><strong>JDK 1.8：</strong> 数组 + 链表 + 红黑树（尾插法）。</li>
<li><strong>红黑树转换条件：</strong> 当链表长度 &gt; 8 且数组长度 &gt;&#x3D; 64 时，链表转为红黑树；当节点数 &lt; 6 时，退化为链表。</li>
</ul>
<p><strong>5、用过TreeMap吗？它和HashMap的区别是什么？</strong></p>
<ul>
<li><strong>有序性：</strong> <code>TreeMap</code> 是有序的（基于Key排序），<code>HashMap</code> 是无序的。</li>
<li><strong>底层：</strong> <code>TreeMap</code> 基于红黑树实现；<code>HashMap</code> 基于Hash表。</li>
<li><strong>复杂度：</strong> <code>TreeMap</code> 的增删改查是对数级 <code>O(log n)</code>；<code>HashMap</code> 理论上是常数级 <code>O(1)</code>。</li>
</ul>
<hr>
<h3 id="二、-并发编程"><a href="#二、-并发编程" class="headerlink" title="二、 并发编程"></a>二、 并发编程</h3><p><strong>6、volatile关键字的用途？</strong></p>
<ul>
<li><strong>保证可见性：</strong> 当一个线程修改变量时，其他线程能立即看到最新值（通过MESI协议&#x2F;嗅探机制）。</li>
<li><strong>禁止指令重排序：</strong> 加上内存屏障，保证有序性（如单例模式的双重检查锁）。</li>
<li><strong>注意：</strong> 它<strong>不保证原子性</strong>（如 <code>i++</code> 操作）。</li>
</ul>
<p><strong>7、创建线程池常用的几个参数？</strong></p>
<ul>
<li><code>corePoolSize</code>：核心线程数。</li>
<li><code>maximumPoolSize</code>：最大线程数。</li>
<li><code>keepAliveTime</code>：非核心线程空闲存活时间。</li>
<li><code>unit</code>：时间单位。</li>
<li><code>workQueue</code>：阻塞队列（如 <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>）。</li>
<li><code>threadFactory</code>：线程工厂（用于命名线程等）。</li>
<li><code>handler</code>：拒绝策略（Abort, CallerRuns, Discard, DiscardOldest）。</li>
</ul>
<p><strong>8、用过CountDownLatch吗？具体在什么场景会用到？</strong></p>
<ul>
<li><strong>作用：</strong> 倒计时锁存器，允许一个或多个线程等待其他线程完成操作。</li>
<li><strong>场景：</strong> 并行处理任务。例如解析一个大Excel，拆分为5个线程并行解析，主线程调用 <code>await()</code> 等待这5个线程都 <code>countDown()</code> 后，再进行汇总入库。</li>
</ul>
<p><strong>9、你在工作中遇见过死锁的问题吗？如果遇到的话怎么解决？</strong></p>
<ul>
<li><strong>场景：</strong> 两个线程互相持有对方需要的锁资源（A拿锁1等锁2，B拿锁2等锁1）。</li>
<li><strong>排查：</strong> 使用 <code>jps</code> 找进程ID，用 <code>jstack</code> 查看线程堆栈，或者用VisualVM检测。</li>
<li><strong>解决&#x2F;避免：</strong><ul>
<li>固定加锁顺序。</li>
<li>使用 <code>Lock.tryLock()</code> 设置超时时间，拿不到锁就放弃。</li>
<li>减少锁粒度。</li>
</ul>
</li>
</ul>
<p><strong>10、说一下什么是乐观锁？什么是悲观锁？</strong></p>
<ul>
<li><strong>悲观锁：</strong> 假设会发生冲突，操作前先加锁。如 <code>synchronized</code>, <code>ReentrantLock</code>, 数据库的 <code>select ... for update</code>。</li>
<li><strong>乐观锁：</strong> 假设不会发生冲突，只在更新时检查数据是否被修改。如 CAS（Compare and Swap）机制，数据库中的 <code>version</code> 版本号字段。</li>
</ul>
<p><strong>11、说一下ThreadLocal的原理？</strong></p>
<ul>
<li><strong>原理：</strong> 每个 <code>Thread</code> 对象内部维护了一个 <code>ThreadLocalMap</code>。<code>ThreadLocal</code> 对象本身作为 Key，线程私有的变量作为 Value。</li>
<li><strong>内存泄露：</strong> Key 是弱引用，Value 是强引用。如果 <code>ThreadLocal</code> 没被回收，Key 变为 null，但 Value 还在，导致内存泄漏。</li>
<li><strong>解决：</strong> 使用完后务必调用 <code>remove()</code> 方法。</li>
</ul>
<hr>
<h3 id="三、-网络与Netty"><a href="#三、-网络与Netty" class="headerlink" title="三、 网络与Netty"></a>三、 网络与Netty</h3><p><strong>12、说一下TCP的粘包问题？怎么解决？</strong></p>
<ul>
<li><strong>原因：</strong> TCP是面向流的协议，没有界限；发送方Nagle算法合并小包；接收方缓冲区堆积。</li>
<li><strong>解决：</strong><ul>
<li><strong>定长：</strong> 发送固定长度的数据包。</li>
<li><strong>分隔符：</strong> 如按换行符 <code>\n</code> 切分。</li>
<li><strong>Header+Body：</strong> 消息头定义长度，读取时先读头获取长度，再读Body（Netty常用方式）。</li>
</ul>
</li>
</ul>
<p><strong>13、你用过Netty框架吗？</strong></p>
<ul>
<li><strong>核心：</strong> 基于NIO的异步事件驱动网络框架。</li>
<li><strong>组件：</strong> Channel, EventLoop (Reactor线程模型), ChannelHandler, Pipeline, ByteBuf。</li>
</ul>
<p><strong>14、说一下零拷贝？</strong></p>
<ul>
<li><strong>概念：</strong> 减少CPU在用户态和内核态之间的数据拷贝次数。</li>
<li><strong>实现：</strong><ul>
<li>Linux: <code>mmap</code> (内存映射), <code>sendfile</code>。</li>
<li>Java&#x2F;Netty: <code>FileChannel.transferTo</code>, Netty的 <code>Direct Memory</code> 和 <code>CompositeByteBuf</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四、-JVM"><a href="#四、-JVM" class="headerlink" title="四、 JVM"></a>四、 JVM</h3><p><strong>15、JVM的数据区包括哪几个部分？分别存放什么？</strong></p>
<ul>
<li><strong>堆 (Heap)：</strong> 存放对象实例（最大的一块，GC主要区域）。</li>
<li><strong>方法区 (Method Area&#x2F;Metaspace)：</strong> 类信息、常量、静态变量。</li>
<li><strong>虚拟机栈 (VM Stack)：</strong> 局部变量表、操作数栈（线程私有）。</li>
<li><strong>本地方法栈 (Native Stack)：</strong> Native方法。</li>
<li><strong>程序计数器 (PC Register)：</strong> 当前线程执行的字节码行号。</li>
</ul>
<p><strong>16、JVM的堆空间是如何划分的？（经典的分代）</strong></p>
<ul>
<li><strong>新生代 (Young)：</strong> 占堆的1&#x2F;3。分为 Eden, Survivor 0 (S0), Survivor 1 (S1) —— 比例 8:1:1。</li>
<li><strong>老年代 (Old)：</strong> 占堆的2&#x2F;3。存放生命周期长的对象。</li>
</ul>
<p><strong>17、G1的堆空间是如何划分的？</strong></p>
<ul>
<li>取消了物理上的新生代和老年代隔离。</li>
<li>将堆划分为多个大小相等的 <strong>Region</strong>。</li>
<li>Region 动态地充当 Eden, Survivor, Old, 或 Humongous (大对象区域)。</li>
</ul>
<p><strong>18、说一下双亲委派模型？</strong></p>
<ul>
<li><strong>流程：</strong> 类加载器收到请求 -&gt; 向上委托给父类 -&gt; 直到启动类加载器 (Bootstrap) -&gt; 父类能加载就加载 -&gt; 不能加载才由子类自己尝试加载。</li>
<li><strong>作用：</strong> 保证Java核心类的安全（避免用户自定义 <code>java.lang.String</code> 覆盖核心类），避免重复加载。</li>
</ul>
<p><strong>19、你在项目开发中遇到过OOM相关问题吗？如何定位？如何解决？</strong></p>
<ul>
<li><strong>常见OOM：</strong> <code>Java heap space</code> (堆溢出), <code>StackOverflowError</code> (栈溢出&#x2F;死递归)。</li>
<li><strong>定位：</strong><ul>
<li>配置启动参数 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 导出Dump文件。</li>
<li>使用 MAT (Memory Analyzer Tool) 或 VisualVM 分析 Dump 文件。</li>
<li>查看大对象，查找 GC Roots 引用链。</li>
</ul>
</li>
<li><strong>解决：</strong> 优化代码（如死循环、大列表未清理），调整堆内存大小（-Xmx, -Xms）。</li>
</ul>
<hr>
<h3 id="五、-MySQL数据库"><a href="#五、-MySQL数据库" class="headerlink" title="五、 MySQL数据库"></a>五、 MySQL数据库</h3><p><strong>20、说一下mysql，什么是回表？</strong></p>
<ul>
<li><strong>概念：</strong> 通过普通索引（非聚簇索引）查询时，只找到了主键ID，需要拿着主键ID再去主键索引树（聚簇索引）中查找完整的行记录，这个过程叫回表。</li>
<li><strong>优化：</strong> 使用<strong>覆盖索引</strong>（查询的字段刚好都在索引中），避免回表。</li>
</ul>
<p><strong>21、说一下mysql的底层数据结构？</strong></p>
<ul>
<li><strong>B+树。</strong></li>
<li><strong>为什么用B+树：</strong><ul>
<li>非叶子节点只存索引，叶子节点存数据 -&gt; 树更矮胖，IO次数少。</li>
<li>叶子节点之间有双向指针 -&gt; 适合范围查询（Range Scan）。</li>
</ul>
</li>
</ul>
<p><strong>22、说一下mysql的事务隔离级别？</strong></p>
<ul>
<li><strong>读未提交 (RU)：</strong> 脏读。</li>
<li><strong>读已提交 (RC)：</strong> 解决脏读，不可重复读。</li>
<li><strong>可重复读 (RR)：</strong> MySQL默认。解决不可重复读，通过Next-Key Lock解决幻读。</li>
<li><strong>串行化：</strong> 效率最低，完全锁住。</li>
</ul>
<p><strong>23、Mysql的MVCC是如何工作的？</strong></p>
<ul>
<li><strong>MVCC (多版本并发控制)：</strong> 允许读取时不加锁，实现读写并行。</li>
<li><strong>核心：</strong> Undo Log（版本链） + Read View（一致性视图）。</li>
<li><strong>机制：</strong> 每一行数据有隐藏列（事务ID、回滚指针）。事务读取时根据 Read View 规则判断哪个版本的数据对当前事务可见。</li>
</ul>
<p><strong>24、如果向mysql插入一条数据，关于bin log和redo log，具体是怎么工作的？</strong></p>
<ul>
<li><strong>Redo Log (重做日志)：</strong> InnoDB特有，物理日志，保证事务持久性（Crash-safe）。</li>
<li><strong>Bin Log (归档日志)：</strong> Server层，逻辑日志，用于主从复制和恢复。</li>
<li><strong>两阶段提交：</strong><ol>
<li>引擎写 Redo Log (Prepare状态)。</li>
<li>Server写 Bin Log。</li>
<li>引擎提交 Redo Log (Commit状态)。</li>
</ol>
<ul>
<li><em>目的：保证两份日志逻辑一致。</em></li>
</ul>
</li>
</ul>
<p><strong>25、在项目过程中遇到慢sql该如何优化？思路是什么？</strong></p>
<ul>
<li>开启慢查询日志定位SQL。</li>
<li>使用 <code>EXPLAIN</code> 分析执行计划（看 <code>type</code>, <code>key</code>, <code>rows</code>, <code>extra</code>）。</li>
<li><strong>优化手段：</strong><ul>
<li>加索引、优化索引（最左前缀原则）。</li>
<li>避免 <code>select *</code>，使用覆盖索引。</li>
<li>小表驱动大表（Join优化）。</li>
<li>分库分表（数据量太大时）。</li>
</ul>
</li>
</ul>
<p><strong>26、把select * 换成查询具体字段，它解决了什么问题？</strong></p>
<ul>
<li>减少网络传输带宽。</li>
<li>减少数据库解析成本。</li>
<li><strong>最重要：</strong> 增加了使用<strong>覆盖索引</strong>的机会，避免回表。</li>
</ul>
<p><strong>27、索引失效的情况说一下？</strong></p>
<ul>
<li>未遵循最左前缀原则（联合索引）。</li>
<li>在索引列上做计算、函数操作。</li>
<li>类型转换（如字符串不加引号）。</li>
<li><code>like</code> 以 <code>%</code> 开头（<code>%abc</code>）。</li>
<li>使用 <code>!=</code> 或 <code>OR</code>（某些情况下）。</li>
</ul>
<hr>
<h3 id="六、-Redis与缓存"><a href="#六、-Redis与缓存" class="headerlink" title="六、 Redis与缓存"></a>六、 Redis与缓存</h3><p><strong>28、说一下redis的持久化机制？</strong></p>
<ul>
<li><strong>RDB (快照)：</strong> 定时将内存数据dump到磁盘。恢复快，但可能丢数据。</li>
<li><strong>AOF (追加日志)：</strong> 记录每次写命令。数据安全，文件大，恢复慢。</li>
<li><strong>混合持久化：</strong> RDB + AOF（Redis 4.0+），结合两者优点。</li>
</ul>
<p><strong>29、了解过redis和mysql的主从同步过程吗？</strong></p>
<ul>
<li><strong>Redis主从：</strong><ul>
<li><strong>全量复制：</strong> Slave发送 <code>PSYNC</code>，Master生成RDB发给Slave，Slave加载，Master再发缓冲区命令。</li>
<li><strong>增量复制：</strong> 断线重连后，根据偏移量（Offset）在积压缓冲区内同步。</li>
</ul>
</li>
<li><strong>MySQL主从：</strong><ul>
<li>Master写 Binlog。</li>
<li>Slave I&#x2F;O线程拉取 Binlog 写入 Relay Log（中继日志）。</li>
<li>Slave SQL线程重放 Relay Log。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="七、-Kafka"><a href="#七、-Kafka" class="headerlink" title="七、 Kafka"></a>七、 Kafka</h3><p><strong>30、Kafka了解的多吗？说一下Kafka默认的分区策略？</strong></p>
<ul>
<li>如果指定了 Partition，则直接使用。</li>
<li>如果没指定 Partition 但有 Key，按 Key 的 Hash 值取模。</li>
<li>如果都没指定，采用轮询（Round-Robin）或 粘性分区（Sticky Partitioning，性能优化）。</li>
</ul>
<p><strong>31、了解过Kafka的ack机制吗，说一下它的几个取值和用途？</strong></p>
<ul>
<li><strong>acks&#x3D;0：</strong> 发送不管结果。最快，丢数据风险最大。</li>
<li><strong>acks&#x3D;1：</strong> Leader 收到即成功。折中。</li>
<li><strong>acks&#x3D;all&#x2F;-1：</strong> ISR列表中的所有副本都收到才算成功。最安全，最慢。</li>
</ul>
<p><strong>32、说一下Kafka消费者具体是怎么消费的？</strong></p>
<ul>
<li><strong>Pull模式：</strong> 消费者主动去Broker拉取数据。</li>
<li><strong>消费组：</strong> 组内消费者共同消费一个Topic，每个Partition只能被组内一个消费者消费。</li>
<li><strong>Offset：</strong> 消费完提交 Offset（自动提交或手动提交），记录消费进度。</li>
</ul>
<hr>
<h3 id="八、-Linux与容器"><a href="#八、-Linux与容器" class="headerlink" title="八、 Linux与容器"></a>八、 Linux与容器</h3><p><strong>33、Linux常用的一些命令了解吗？</strong></p>
<ul>
<li><strong>文件：</strong> <code>ls</code>, <code>cd</code>, <code>cat</code>, <code>tail -f</code> (看日志), <code>grep</code> (搜索), <code>chmod</code>, <code>tar</code>.</li>
<li><strong>进程&#x2F;网络：</strong> <code>ps -ef</code> (看进程), <code>top</code> (看负载), <code>netstat -nlp</code> 或 <code>ss</code> (看端口), <code>kill -9</code>.</li>
</ul>
<p><strong>34、你们项目是直接在虚拟机上部署，还是在docker或者k8s？能说一下docker的常用命令吗？</strong></p>
<ul>
<li><code>docker pull</code> (拉镜像)</li>
<li><code>docker run</code> (启动容器, 常用参数 <code>-d</code>, <code>-p</code>, <code>-v</code>)</li>
<li><code>docker ps</code> (看运行容器)</li>
<li><code>docker exec -it &lt;id&gt; /bin/bash</code> (进入容器)</li>
<li><code>docker logs</code> (看日志)</li>
<li><code>docker build</code> (构建镜像)</li>
</ul>
<hr>
<h3 id="九、-微服务架构"><a href="#九、-微服务架构" class="headerlink" title="九、 微服务架构"></a>九、 微服务架构</h3><p><strong>35、你们服务架构是单体的还是微服务的？说一下微服务相关的组件？</strong></p>
<ul>
<li><strong>Spring Cloud Alibaba 体系：</strong><ul>
<li><strong>注册&#x2F;配置中心：</strong> Nacos</li>
<li><strong>负载均衡：</strong> Ribbon &#x2F; LoadBalancer</li>
<li><strong>服务调用：</strong> Feign &#x2F; OpenFeign</li>
<li><strong>熔断限流：</strong> Sentinel &#x2F; Hystrix</li>
<li><strong>网关：</strong> Spring Cloud Gateway</li>
</ul>
</li>
</ul>
<p><strong>36、Nacos除了配置还有什么作用？服务注册的目的是什么？</strong></p>
<ul>
<li><strong>Nacos作用：</strong> 配置中心（动态管理配置，无需重启）、注册中心。</li>
<li><strong>服务注册目的：</strong><ul>
<li><strong>解耦：</strong> 消费者不需要硬编码提供者的IP地址。</li>
<li><strong>动态感知：</strong> 服务上下线自动发现。</li>
<li><strong>负载均衡：</strong> 获取可用服务列表后进行轮询等策略调用。</li>
</ul>
</li>
</ul>
<p><strong>37、你有了解过分布式事务吗？</strong></p>
<ul>
<li><strong>理论：</strong> CAP定理，BASE理论。</li>
<li><strong>解决方案：</strong><ul>
<li><strong>2PC (两阶段)：</strong> Seata 的 AT 模式（常用，侵入性小）。</li>
<li><strong>TCC：</strong> Try-Confirm-Cancel（性能好，代码量大）。</li>
<li><strong>最终一致性：</strong> 本地消息表 + 定时任务；或者基于 MQ 的事务消息（如 RocketMQ）。</li>
</ul>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/12/09/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%8306/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/12/01/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%8305/">
        <h2 class="post-title">八股训练05</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/12/1
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h3 id="第一部分：Java-基础与并发"><a href="#第一部分：Java-基础与并发" class="headerlink" title="第一部分：Java 基础与并发"></a>第一部分：Java 基础与并发</h3><h4 id="1-Java进程之间是怎么沟通的？同一个进程里面，两个线程要怎么交流？"><a href="#1-Java进程之间是怎么沟通的？同一个进程里面，两个线程要怎么交流？" class="headerlink" title="1. Java进程之间是怎么沟通的？同一个进程里面，两个线程要怎么交流？"></a>1. Java进程之间是怎么沟通的？同一个进程里面，两个线程要怎么交流？</h4><ul>
<li><strong>进程间通信 (IPC)</strong>：<ul>
<li>Java 进程本质上是操作系统上的进程，通信依赖操作系统机制。</li>
<li><strong>Socket（最常用）</strong>：基于 TCP&#x2F;IP 网络通信（微服务调用、HTTP 请求都是这种）。</li>
<li><strong>RMI (Remote Method Invocation)</strong>：Java 原生的远程方法调用。</li>
<li><strong>信号量&#x2F;管道</strong>：操作系统层面的，Java 可以通过 JNI 或文件系统间接使用。</li>
<li><strong>共享内存 (MappedByteBuffer)</strong>：通过内存映射文件实现。</li>
</ul>
</li>
<li><strong>线程间通信</strong>：<ul>
<li><strong>共享内存</strong>：线程共享堆内存（Heap），通过读写同一个对象（变量）来交换数据。需配合锁机制。</li>
<li><strong>wait&#x2F;notify</strong>：基于 <code>Object</code> 类的等待&#x2F;唤醒机制。</li>
<li><strong>volatile</strong>：保证变量的可见性，一个线程改了，其他线程立马看到。</li>
<li><strong>JUC 工具类</strong>：<code>CountDownLatch</code>、<code>CyclicBarrier</code>、<strong><code>BlockingQueue</code></strong>（最常用，生产者-消费者模型）。</li>
</ul>
</li>
</ul>
<h4 id="2-Java数据结构知道吗，讲一讲数组的原理"><a href="#2-Java数据结构知道吗，讲一讲数组的原理" class="headerlink" title="2. Java数据结构知道吗，讲一讲数组的原理"></a>2. Java数据结构知道吗，讲一讲数组的原理</h4><ul>
<li><strong>数组 (Array)</strong>：<ul>
<li><strong>内存连续</strong>：在内存中开辟一段<strong>连续</strong>的空间。</li>
<li><strong>随机访问 (Random Access)</strong>：知道数组的首地址，根据索引下标可以直接计算出内存地址（<code>首地址 + 索引 * 数据类型大小</code>），所以查询时间复杂度是 <strong>O(1)</strong>。</li>
<li><strong>长度固定</strong>：一旦创建，长度不可变。</li>
</ul>
</li>
</ul>
<h4 id="3-ArrayList-和-LinkedList-有什么区别？（重点补救）"><a href="#3-ArrayList-和-LinkedList-有什么区别？（重点补救）" class="headerlink" title="3. ArrayList 和 LinkedList 有什么区别？（重点补救）"></a>3. ArrayList 和 LinkedList 有什么区别？（重点补救）</h4><ul>
<li><strong>底层结构</strong>：<code>ArrayList</code> 基于<strong>动态数组</strong>；<code>LinkedList</code> 基于<strong>双向链表</strong>。</li>
<li><strong>查询性能</strong>：<code>ArrayList</code> 支持随机访问（O(1)）；<code>LinkedList</code> 需要遍历节点（O(n)），查询慢。</li>
<li><strong>增删性能</strong>：<ul>
<li><code>ArrayList</code>：尾部增删快，但如果在中间增删，需要<strong>数据搬运</strong>（System.arraycopy），效率低。</li>
<li><code>LinkedList</code>：只要拿到了节点，增删只需要修改前后指针，效率高（O(1)），但寻找节点本身需要时间。</li>
</ul>
</li>
<li><strong>内存占用</strong>：<code>LinkedList</code> 每个节点要存 prev&#x2F;next 指针，比 <code>ArrayList</code> 更占内存。</li>
</ul>
<h4 id="4-ConcurrentHashMap-知道吗？"><a href="#4-ConcurrentHashMap-知道吗？" class="headerlink" title="4. ConcurrentHashMap 知道吗？"></a>4. ConcurrentHashMap 知道吗？</h4><ul>
<li><strong>JDK 1.7</strong>：<strong>分段锁 (Segment)</strong>。把大数组切分成很多段（Segment），每段配一把锁（ReentrantLock）。多线程访问不同段时互不干扰。</li>
<li><strong>JDK 1.8</strong>：<strong>Node 数组 + 链表&#x2F;红黑树</strong>。摒弃 Segment，直接用 <code>Node[]</code>。<ul>
<li><strong>锁粒度更细</strong>：使用 <strong>CAS + synchronized</strong>。只锁定当前链表&#x2F;红黑树的<strong>头节点</strong>。</li>
<li><strong>红黑树</strong>：当链表长度超过 8 时转为红黑树，提高查询效率（O(logn)）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第二部分：框架原理"><a href="#第二部分：框架原理" class="headerlink" title="第二部分：框架原理"></a>第二部分：框架原理</h3><h4 id="5-Spring-是怎么实现的？"><a href="#5-Spring-是怎么实现的？" class="headerlink" title="5. Spring 是怎么实现的？"></a>5. Spring 是怎么实现的？</h4><ul>
<li>核心是 <strong>IoC 容器</strong> 和 <strong>AOP</strong>。</li>
<li><strong>启动流程</strong>：解析配置（XML&#x2F;注解） -&gt; 封装成 <code>BeanDefinition</code> -&gt; 通过<strong>反射</strong>实例化对象 -&gt; <strong>依赖注入</strong>（属性赋值） -&gt; 初始化（Aware回调&#x2F;init-method） -&gt; 放入单例池（Map）。</li>
<li><strong>Bean 的获取</strong>：也就是 <code>getBean()</code>，本质是从 <code>ConcurrentHashMap</code> 中拿对象。</li>
</ul>
<h4 id="6-微服务会吗？"><a href="#6-微服务会吗？" class="headerlink" title="6. 微服务会吗？"></a>6. 微服务会吗？</h4><ul>
<li><strong>核心组件</strong>：注册中心（Nacos&#x2F;Eureka）、配置中心、网关（Gateway）、远程调用（OpenFeign&#x2F;Dubbo）、熔断降级（Sentinel&#x2F;Hystrix）。</li>
<li><strong>CAP 定理</strong>：一致性、可用性、分区容错性的权衡。</li>
</ul>
<h4 id="7-MyBatis-是怎么实现的？"><a href="#7-MyBatis-是怎么实现的？" class="headerlink" title="7. MyBatis 是怎么实现的？"></a>7. MyBatis 是怎么实现的？</h4><ul>
<li><strong>核心</strong>：<strong>动态代理</strong>。</li>
<li>你写的 Mapper 接口没有实现类，MyBatis 使用 JDK 动态代理生成了一个代理对象（<code>MapperProxy</code>）。</li>
<li>当你调用接口方法时，代理对象拦截请求，找到对应的 XML&#x2F;注解中的 SQL，解析参数，执行 SQL，最后把结果集（ResultSet）映射成 Java 对象。</li>
</ul>
<h4 id="8-IOC-和-AOP（参考上一条回答中的“Java基础与框架”第5题）。"><a href="#8-IOC-和-AOP（参考上一条回答中的“Java基础与框架”第5题）。" class="headerlink" title="8. IOC 和 AOP（参考上一条回答中的“Java基础与框架”第5题）。"></a>8. IOC 和 AOP（参考上一条回答中的“Java基础与框架”第5题）。</h4><h4 id="9-反射知道吗？"><a href="#9-反射知道吗？" class="headerlink" title="9. 反射知道吗？"></a>9. 反射知道吗？</h4><ul>
<li><strong>概念</strong>：运行时动态获取类的信息（属性、方法）并操作对象。</li>
<li><strong>应用</strong>：Spring 实例化 Bean、MyBatis 结果映射、JDBC 加载驱动。</li>
</ul>
<hr>
<h3 id="第三部分：数据库与-Redis"><a href="#第三部分：数据库与-Redis" class="headerlink" title="第三部分：数据库与 Redis"></a>第三部分：数据库与 Redis</h3><h4 id="10-MySQL-事务、索引、锁"><a href="#10-MySQL-事务、索引、锁" class="headerlink" title="10. MySQL 事务、索引、锁"></a>10. MySQL 事务、索引、锁</h4><ul>
<li><strong>事务</strong>：ACID（原子、一致、隔离、持久）。</li>
<li><strong>索引</strong>：B+树（数据在叶子节点，支持范围查询，层高低减少IO）。</li>
<li><strong>锁</strong>：行锁（Record Lock）、间隙锁（Gap Lock）、表锁。MVCC（多版本并发控制）解决读写冲突。</li>
</ul>
<h4 id="11-为什么要用-Redis？"><a href="#11-为什么要用-Redis？" class="headerlink" title="11. 为什么要用 Redis？"></a>11. 为什么要用 Redis？</h4><ul>
<li><strong>高性能</strong>：基于内存，读写速度极快（10w+ QPS）。</li>
<li><strong>减轻 DB 压力</strong>：作为缓存层。</li>
<li><strong>丰富的数据结构</strong>：支持 String, List, Set, ZSet, Hash，适合做排行榜、计数器、消息队列等。</li>
</ul>
<hr>
<h3 id="第四部分：项目拷打（核心难点）"><a href="#第四部分：项目拷打（核心难点）" class="headerlink" title="第四部分：项目拷打（核心难点）"></a>第四部分：项目拷打（核心难点）</h3><h4 id="12-乐观锁怎么用它处理多线程问题的？你是怎么实现的？"><a href="#12-乐观锁怎么用它处理多线程问题的？你是怎么实现的？" class="headerlink" title="12. 乐观锁怎么用它处理多线程问题的？你是怎么实现的？"></a>12. 乐观锁怎么用它处理多线程问题的？你是怎么实现的？</h4><ul>
<li><strong>原理</strong>：假设不会发生冲突，只在更新时检查一下数据有没有被别人改过。</li>
<li><strong>实现方式</strong>：<ol>
<li><strong>版本号机制（Version）</strong>：数据库表加一个 <code>version</code> 字段。</li>
<li><strong>SQL 逻辑</strong>：<ul>
<li>先查询：<code>SELECT id, salary, version FROM user WHERE id=1</code> (假设查出 version&#x3D;1)。</li>
<li>更新时带上 version 条件：<code>UPDATE user SET salary=200, version=version+1 WHERE id=1 AND version=1</code>。</li>
<li>如果影响行数为 0，说明被别人改过了，更新失败（可以重试或抛错）。</li>
</ul>
</li>
<li><strong>MyBatisPlus</strong>：提供了 <code>@Version</code> 注解自动实现这个逻辑。</li>
</ol>
</li>
</ul>
<h4 id="13-看过-Redis-底层源码吗？C-能看懂吗？（陷阱题）"><a href="#13-看过-Redis-底层源码吗？C-能看懂吗？（陷阱题）" class="headerlink" title="13. 看过 Redis 底层源码吗？C++ 能看懂吗？（陷阱题）"></a>13. 看过 Redis 底层源码吗？C++ 能看懂吗？（陷阱题）</h4><ul>
<li><strong>应对策略</strong>：如果没看过源码，千万别硬撑说看过，会被问死。</li>
<li><strong>话术</strong>：“虽然我没有通读过 C++ 的源码，但我深入学习过 Redis <strong>底层数据结构的设计思想</strong>。”<ul>
<li><strong>ZSet</strong>：底层是 <strong>跳表 (SkipList)</strong> 和 <strong>压缩列表 (ZipList)</strong>。</li>
<li><strong>SkipList</strong>：在链表基础上增加多级索引，实现 O(logn) 的查询，比红黑树实现简单，并发下更易维护。</li>
<li><strong>String</strong>：SDS（简单动态字符串），支持动态扩容，二进制安全。</li>
</ul>
</li>
</ul>
<h4 id="14-为什么用消息队列，不用阻塞队列-BlockingQueue-？"><a href="#14-为什么用消息队列，不用阻塞队列-BlockingQueue-？" class="headerlink" title="14. 为什么用消息队列，不用阻塞队列 (BlockingQueue)？"></a>14. 为什么用消息队列，不用阻塞队列 (BlockingQueue)？</h4><ul>
<li><strong>阻塞队列的局限</strong>：<ol>
<li><strong>内存限制</strong>：它是 JVM 内存里的，容量有限，一旦堆满了会 OOM。</li>
<li><strong>数据丢失</strong>：服务重启或宕机，内存里的数据就没了。</li>
<li><strong>无法分布式</strong>：阻塞队列只能在当前 JVM 里的线程间通信，无法实现 A 服务发消息，B 服务收消息。</li>
</ol>
</li>
<li><strong>消息队列 (MQ) 的优势</strong>：<strong>解耦</strong>（服务拆分）、<strong>削峰填谷</strong>（流量缓冲）、<strong>异步处理</strong>、<strong>持久化</strong>。</li>
</ul>
<h4 id="15-消费者和消费者之间是怎么联系的？"><a href="#15-消费者和消费者之间是怎么联系的？" class="headerlink" title="15. 消费者和消费者之间是怎么联系的？"></a>15. 消费者和消费者之间是怎么联系的？</h4><ul>
<li><strong>通常不直接联系</strong>。它们通过 MQ 交互。</li>
<li><strong>竞争关系</strong>：如果是同一个消费者组（Consumer Group），它们竞争拉取消息（负载均衡），一条消息通常只被一个消费者消费。</li>
<li><strong>广播模式</strong>：如果是不同的消费者组，可以同时消费同一条消息（发布订阅）。</li>
</ul>
<h4 id="16-WebSocket-与-Http-的区别？"><a href="#16-WebSocket-与-Http-的区别？" class="headerlink" title="16. WebSocket 与 Http 的区别？"></a>16. WebSocket 与 Http 的区别？</h4><ul>
<li><strong>HTTP</strong>：短连接，无状态。<strong>单向通信</strong>（只能客户端发起请求，服务端响应）。</li>
<li><strong>WebSocket</strong>：长连接。<strong>全双工通信</strong>（建立连接后，服务端可以主动给客户端推消息）。</li>
<li><strong>场景</strong>：外卖订单状态变更提醒、聊天室，必须用 WebSocket 才能实现实时推送。</li>
</ul>
<h4 id="17-你这个项目是不是就是在做-CRUD？（压力测试）"><a href="#17-你这个项目是不是就是在做-CRUD？（压力测试）" class="headerlink" title="17. 你这个项目是不是就是在做 CRUD？（压力测试）"></a>17. 你这个项目是不是就是在做 CRUD？（压力测试）</h4><ul>
<li><strong>应对心态</strong>：不要慌，不要承认“只是 CRUD”。</li>
<li><strong>话术</strong>：“CRUD 确实是基础，但这个项目的难点在于<strong>具体场景下的技术选型和优化</strong>。”<ul>
<li>举例：</li>
<li>“虽然是点餐，但为了保证高并发下的库存扣减不超卖，我使用了 Redis + Lua 脚本。”</li>
<li>“为了解决数据库和缓存的一致性问题，我采用了 Cache Aside 模式并配合延时双删&#x2F;Canal。”</li>
<li>“为了提升搜索效率，我引入了 ElasticSearch。”</li>
<li><strong>总结</strong>：把重点引向你解决的<strong>并发、一致性、性能优化</strong>问题上。</li>
</ul>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/12/01/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%8305/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/12/01/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%8304/">
        <h2 class="post-title">八股训练04</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/12/1
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <hr>
<h3 id="1-2-开场与熟悉领域"><a href="#1-2-开场与熟悉领域" class="headerlink" title="1. &amp; 2. 开场与熟悉领域"></a>1. &amp; 2. 开场与熟悉领域</h3><ul>
<li><strong>回答策略</strong>：不要只罗列名词。建议按层级分类回答，体现条理。</li>
<li><strong>话术示例</strong>：“我比较熟悉 <strong>Java SE 基础</strong>（包括集合源码、多线程并发、IO模型）、<strong>JVM 原理</strong>（内存模型、GC算法）。在框架方面，熟悉 <strong>Spring 全家桶</strong>（包括 Spring Boot、Spring Cloud）以及常用的中间件如 <strong>Redis</strong> 和 <strong>MySQL</strong>。”</li>
</ul>
<hr>
<h3 id="3-说一下对-Spring-框架结构的了解"><a href="#3-说一下对-Spring-框架结构的了解" class="headerlink" title="3. 说一下对 Spring 框架结构的了解"></a>3. 说一下对 Spring 框架结构的了解</h3><ul>
<li><strong>解析</strong>：虽然核心是 IoC 和 AOP，但问“结构”时，最好能宏观描述一下模块。</li>
<li><strong>回答</strong>：<br>Spring 是一个轻量级的容器框架，它的结构可以分为几个核心模块：<ol>
<li><strong>Core Container（核心容器）</strong>：包含 Beans、Core、Context 和 SpEL，是 Spring 的基石，实现了 <strong>IoC</strong>。</li>
<li><strong>AOP（面向切面编程）</strong>：提供切面功能。</li>
<li><strong>Data Access（数据访问）</strong>：包括 JDBC、Transactions（事务）等。</li>
<li><strong>Web</strong>：包括 MVC、WebFlux 等。</li>
<li><strong>Test</strong>：提供测试支持。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-说一下-AOP-的原理怎么实现的？"><a href="#4-说一下-AOP-的原理怎么实现的？" class="headerlink" title="4. 说一下 AOP 的原理怎么实现的？"></a>4. 说一下 AOP 的原理怎么实现的？</h3><ul>
<li><strong>关键词</strong>：动态代理。</li>
<li><strong>回答</strong>：<br>AOP 的底层原理是 <strong>动态代理</strong>。Spring 会在运行期间，动态地生成代理对象，将切面逻辑（如日志、事务）织入到目标方法中。<br>主要有两种实现方式：<ol>
<li><strong>JDK 动态代理</strong>：如果目标类实现了<strong>接口</strong>，Spring 默认使用 JDK 代理（基于反射，生成接口的实现类）。</li>
<li><strong>CGLIB 动态代理</strong>：如果目标类<strong>没有实现接口</strong>，Spring 会使用 CGLIB（基于字节码生成技术，生成目标类的子类）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="5-动态代理怎么把配置植入到运行中间的？"><a href="#5-动态代理怎么把配置植入到运行中间的？" class="headerlink" title="5. 动态代理怎么把配置植入到运行中间的？"></a>5. 动态代理怎么把配置植入到运行中间的？</h3><ul>
<li><strong>解析</strong>：这是在问动态代理的具体执行流程。</li>
<li><strong>回答</strong>：<br>以 JDK 动态代理为例，核心是 <strong><code>InvocationHandler</code></strong> 接口。<ol>
<li>当我们调用代理对象的方法时，请求会被转发给 <code>InvocationHandler</code> 的 <strong><code>invoke()</code></strong> 方法。</li>
<li>在 <code>invoke()</code> 方法内部，我们可以先执行配置好的<strong>前置逻辑</strong>（比如开启事务）。</li>
<li>然后通过反射 <code>method.invoke()</code> 调用目标对象的原始方法。</li>
<li>最后执行<strong>后置逻辑</strong>（比如提交事务）。<br>这样就实现了在不修改源码的情况下，把配置逻辑“植入”到了方法执行过程中。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="6-什么是集合？把所有的集合全部说一遍"><a href="#6-什么是集合？把所有的集合全部说一遍" class="headerlink" title="6. 什么是集合？把所有的集合全部说一遍"></a>6. 什么是集合？把所有的集合全部说一遍</h3><ul>
<li><strong>回答</strong>：<br>Java 集合主要分为两大派系：<strong>Collection</strong>（单列）和 <strong>Map</strong>（双列&#x2F;键值对）。<ol>
<li><strong>Collection 接口</strong>下分三类：<ul>
<li><strong>List</strong>（有序、可重复）：<code>ArrayList</code>（数组）、<code>LinkedList</code>（链表）、<code>Vector</code>（线程安全但过时）。</li>
<li><strong>Set</strong>（无序、不可重复）：<code>HashSet</code>（基于HashMap）、<code>TreeSet</code>（可排序）、<code>LinkedHashSet</code>（有序）。</li>
<li><strong>Queue</strong>（队列）：<code>PriorityQueue</code>、<code>ArrayDeque</code>。</li>
</ul>
</li>
<li><strong>Map 接口</strong>：<ul>
<li><code>HashMap</code>（最常用）、<code>LinkedHashMap</code>（有序）、<code>TreeMap</code>（可排序）、<code>ConcurrentHashMap</code>（线程安全）、<code>Hashtable</code>（过时）。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="7-ArrayList-是动态数组，你说一下动态指的什么意思呢？"><a href="#7-ArrayList-是动态数组，你说一下动态指的什么意思呢？" class="headerlink" title="7. ArrayList 是动态数组，你说一下动态指的什么意思呢？"></a>7. ArrayList 是动态数组，你说一下动态指的什么意思呢？</h3><ul>
<li><strong>解析</strong>：考察扩容机制。</li>
<li><strong>回答</strong>：<br>“动态”指的是它<strong>能够自动扩容</strong>。<br>Java 的原生数组（Array）长度是固定的，一旦创建无法修改。而 <code>ArrayList</code> 在添加元素时，如果发现容量不足：<ol>
<li>会计算新的容量，通常是<strong>原容量的 1.5 倍</strong>（<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>）。</li>
<li>然后创建一个新的更大的数组。</li>
<li>使用 <code>Arrays.copyOf</code> 将旧数组的数据复制过去。<br>这个过程对使用者是透明的，看起来就像数组长度可以动态变化一样。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="8-I-O-是干嘛的？（让自己说）"><a href="#8-I-O-是干嘛的？（让自己说）" class="headerlink" title="8. I&#x2F;O 是干嘛的？（让自己说）"></a>8. I&#x2F;O 是干嘛的？（让自己说）</h3><ul>
<li><strong>回答</strong>：<br>I&#x2F;O 即 Input&#x2F;Output（输入&#x2F;输出）。它是计算机系统与外部世界（如磁盘文件、网络、键盘显示器）进行<strong>数据交换</strong>的过程。<br>在 Java 中，I&#x2F;O 主要负责把数据读入内存（Input）或者从内存写出到外部设备（Output）。</li>
</ul>
<hr>
<h3 id="9-IO-中-byte-字节流-和-char-字符流-有什么区别？"><a href="#9-IO-中-byte-字节流-和-char-字符流-有什么区别？" class="headerlink" title="9. IO 中 byte (字节流) 和 char (字符流) 有什么区别？"></a>9. IO 中 byte (字节流) 和 char (字符流) 有什么区别？</h3><ul>
<li><strong>回答</strong>：<ol>
<li><strong>处理单元不同</strong>：字节流（Stream结尾）按 <strong>8位二进制字节</strong> 处理；字符流（Reader&#x2F;Writer结尾）按 <strong>16位 Unicode 字符</strong> 处理。</li>
<li><strong>应用场景不同</strong>：<ul>
<li><strong>字节流</strong>：万能的。适合处理图片、视频、音频、PDF等二进制文件。</li>
<li><strong>字符流</strong>：专门处理纯文本数据（如 txt, xml, json）。</li>
</ul>
</li>
<li><strong>编码处理</strong>：字符流内部处理了字符集编码转换（如 UTF-8 转 Unicode），避免乱码；字节流需要手动处理。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="10-NIO，BIO-指的是什么？"><a href="#10-NIO，BIO-指的是什么？" class="headerlink" title="10. NIO，BIO 指的是什么？"></a>10. NIO，BIO 指的是什么？</h3><ul>
<li><strong>回答</strong>：<ul>
<li><strong>BIO (Blocking I&#x2F;O)</strong>：<strong>同步阻塞</strong>。传统的 IO 模型。一个连接对应一个线程。如果客户端发起请求但没发送数据，服务端的线程就会一直<strong>阻塞</strong>在那里傻等，资源浪费大，并发能力弱。</li>
<li><strong>NIO (Non-blocking I&#x2F;O)</strong>：<strong>同步非阻塞</strong>。引入了 <strong>Selector（选择器）、Channel（通道）、Buffer（缓冲区）</strong>。一个线程（Selector）可以轮询管理成千上万个连接（Channel）。只有当连接真正有数据读写时，线程才去处理，实现了<strong>多路复用</strong>，高并发性能好。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="11-什么是反射？"><a href="#11-什么是反射？" class="headerlink" title="11. 什么是反射？"></a>11. 什么是反射？</h3><ul>
<li><strong>回答</strong>：<br>反射是 Java 的一种机制，允许程序在<strong>运行时</strong>（Runtime）动态地获取类的信息（如属性、方法、构造器）并操作对象。<br>简单说就是：<strong>在程序运行期间，对于任意一个类，都能知道它有哪些方法和属性；对于任意一个对象，都能调用它的任意方法。</strong></li>
</ul>
<hr>
<h3 id="12-哪里用到了反射？"><a href="#12-哪里用到了反射？" class="headerlink" title="12. 哪里用到了反射？"></a>12. 哪里用到了反射？</h3><ul>
<li><strong>回答</strong>：<br>反射是框架的灵魂，平时写业务代码用得少，但框架里到处都是：<ol>
<li><strong>Spring IOC</strong>：解析 XML 或注解，利用反射实例化 Bean。</li>
<li><strong>JDBC</strong>：<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)</code> 加载驱动。</li>
<li><strong>AOP &#x2F; 动态代理</strong>：底层也是反射。</li>
<li><strong>MyBatis</strong>：将数据库查询结果映射到 Java 实体类对象。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="13-注解的含义是啥？"><a href="#13-注解的含义是啥？" class="headerlink" title="13. 注解的含义是啥？"></a>13. 注解的含义是啥？</h3><ul>
<li><strong>回答</strong>：<br>注解（Annotation）本质上是一种<strong>元数据（Metadata）</strong>，也就是“给代码打的标签”。<br>注解本身<strong>不会</strong>影响代码的逻辑执行。它需要配合<strong>注解处理器</strong>（通过反射机制）来读取这些标签，并根据标签触发相应的逻辑。<br>例如 <code>@Override</code> 是给编译器看的，<code>@Autowired</code> 是给 Spring 容器看的。</li>
</ul>
<hr>
<h3 id="14-说一下什么是泛型，什么时候会用到泛型？"><a href="#14-说一下什么是泛型，什么时候会用到泛型？" class="headerlink" title="14. 说一下什么是泛型，什么时候会用到泛型？"></a>14. 说一下什么是泛型，什么时候会用到泛型？</h3><ul>
<li><strong>回答</strong>：<ul>
<li><strong>什么是泛型</strong>：泛型就是“参数化类型”，把类型当作参数传递。</li>
<li><strong>作用</strong>：<ol>
<li><strong>类型安全</strong>：在编译阶段就能检查类型错误，避免运行时的 <code>ClassCastException</code>。</li>
<li><strong>代码复用</strong>：一套代码可以处理多种数据类型。</li>
</ol>
</li>
<li><strong>什么时候用</strong>：<ol>
<li><strong>集合类</strong>：如 <code>List&lt;String&gt;</code>，限制列表只能放字符串。</li>
<li><strong>通用工具类&#x2F;结果封装</strong>：如后端的统一返回对象 <code>Result&lt;T&gt;</code>，T 可以是 User，也可以是 Order。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="15-equal-和-区别"><a href="#15-equal-和-区别" class="headerlink" title="15. equal 和 &#x3D;&#x3D; 区别"></a>15. equal 和 &#x3D;&#x3D; 区别</h3><ul>
<li><strong>回答</strong>：<ul>
<li><strong><code>==</code></strong>：<ul>
<li>基本数据类型：比较的是<strong>值</strong>。</li>
<li>引用数据类型：比较的是<strong>内存地址</strong>（是不是同一个对象）。</li>
</ul>
</li>
<li><strong><code>equals</code></strong>：<ul>
<li>默认情况（Object类）：等价于 <code>==</code>，比较内存地址。</li>
<li><strong>重写后</strong>（如 String, Integer）：通常用来比较对象的<strong>内容</strong>是否相等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="16-我们在重写一个类为什么要重写他的-equal-方法和-tostring-方法？不写有什么影响？"><a href="#16-我们在重写一个类为什么要重写他的-equal-方法和-tostring-方法？不写有什么影响？" class="headerlink" title="16. 我们在重写一个类为什么要重写他的 equal 方法和 tostring 方法？不写有什么影响？"></a>16. 我们在重写一个类为什么要重写他的 equal 方法和 tostring 方法？不写有什么影响？</h3><ul>
<li><strong>回答</strong>：<ul>
<li><strong>关于 <code>equals</code></strong>：<ul>
<li>如果不重写，默认比较内存地址。业务上通常认为“ID相同”或“属性相同”就是同一个对象，所以必须重写。</li>
<li><strong>重要补充</strong>：重写 <code>equals</code> <strong>必须</strong>重写 <code>hashCode</code>。否则该对象在 HashMap&#x2F;HashSet 中会失效（存进去取不出来）。</li>
</ul>
</li>
<li><strong>关于 <code>toString</code></strong>：<ul>
<li>如果不重写，打印对象时显示的是 <code>类名@哈希码</code>（如 <code>User@1b6d3586</code>），看不懂。</li>
<li>重写后可以打印出具体的属性值，方便<strong>日志排查</strong>和<strong>调试</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="17-什么是事务，展开说一下？"><a href="#17-什么是事务，展开说一下？" class="headerlink" title="17. 什么是事务，展开说一下？"></a>17. 什么是事务，展开说一下？</h3><ul>
<li><strong>回答</strong>：<br>事务（Transaction）是数据库操作的<strong>最小逻辑单元</strong>，一组操作要么全部成功，要么全部失败，不能停留在中间状态。<br>事务必须满足 <strong>ACID</strong> 四大特性：<ol>
<li><strong>Atomicity（原子性）</strong>：同生共死，要么都做，要么都不做。</li>
<li><strong>Consistency（一致性）</strong>：事务前后，数据总量或状态必须守恒（如转账，A扣钱B必须加钱）。</li>
<li><strong>Isolation（隔离性）</strong>：并发事务之间互不干扰（涉及隔离级别：读未提交、读已提交、可重复读、串行化）。</li>
<li><strong>Durability（持久性）</strong>：一旦提交，数据就永久保存到磁盘，断电也不丢失。</li>
</ol>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/12/01/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%8304/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/12/01/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%8303/">
        <h2 class="post-title">八股训练03</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/12/1
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h3 id="第一部分：Java基础与框架"><a href="#第一部分：Java基础与框架" class="headerlink" title="第一部分：Java基础与框架"></a>第一部分：Java基础与框架</h3><h4 id="1-Java基础数据类型有几种？能说一下吗？"><a href="#1-Java基础数据类型有几种？能说一下吗？" class="headerlink" title="1. Java基础数据类型有几种？能说一下吗？"></a>1. Java基础数据类型有几种？能说一下吗？</h4><p>Java有 <strong>8种</strong> 基本数据类型，可以分为四类：</p>
<ul>
<li><strong>整数型</strong>：<code>byte</code> (1字节), <code>short</code> (2字节), <code>int</code> (4字节), <code>long</code> (8字节)</li>
<li><strong>浮点型</strong>：<code>float</code> (4字节), <code>double</code> (8字节)</li>
<li><strong>字符型</strong>：<code>char</code> (2字节，存储Unicode字符)</li>
<li><strong>布尔型</strong>：<code>boolean</code> (理论上占1位，但具体大小取决于JVM实现)</li>
</ul>
<h4 id="2-他们的包装类分别是什么？"><a href="#2-他们的包装类分别是什么？" class="headerlink" title="2. 他们的包装类分别是什么？"></a>2. 他们的包装类分别是什么？</h4><p>对应关系如下（注意 <code>int</code> 和 <code>char</code> 的变化）：</p>
<ul>
<li>byte -&gt; <strong>Byte</strong></li>
<li>short -&gt; <strong>Short</strong></li>
<li>int -&gt; <strong>Integer</strong></li>
<li>long -&gt; <strong>Long</strong></li>
<li>float -&gt; <strong>Float</strong></li>
<li>double -&gt; <strong>Double</strong></li>
<li>char -&gt; <strong>Character</strong></li>
<li>boolean -&gt; <strong>Boolean</strong></li>
</ul>
<h4 id="3-ArrayList为什么线程不安全？"><a href="#3-ArrayList为什么线程不安全？" class="headerlink" title="3. ArrayList为什么线程不安全？"></a>3. ArrayList为什么线程不安全？</h4><ul>
<li><strong>没有同步锁</strong>：ArrayList 的源码中，<code>add()</code>、<code>remove()</code> 等核心方法没有加 <code>synchronized</code> 关键字，也没有使用 Lock 锁。</li>
<li><strong>竞态条件</strong>：<ul>
<li><strong>扩容问题</strong>：当多线程同时添加元素且触发扩容时，可能导致数组下标越界或数据丢失。</li>
<li><strong>值覆盖</strong>：<code>elementData[size++] = e</code> 这一步操作不是原子的（分两步：赋值、size自增）。多线程并发下，可能两个线程拿到同一个 size 值，导致一个线程的数据覆盖了另一个线程的数据。</li>
</ul>
</li>
</ul>
<h4 id="4-如果我考虑用一个线程安全的List，应该用什么？"><a href="#4-如果我考虑用一个线程安全的List，应该用什么？" class="headerlink" title="4. 如果我考虑用一个线程安全的List，应该用什么？"></a>4. 如果我考虑用一个线程安全的List，应该用什么？</h4><p>主要有三种选择，推荐第三种：</p>
<ol>
<li><strong>Vector</strong>：老牌类，所有方法都加了 <code>synchronized</code>，效率极低，不推荐使用。</li>
<li><strong>Collections.synchronizedList(new ArrayList&lt;&gt;())</strong>：使用工具类将 ArrayList 包装成线程安全的，本质是在操作时加互斥锁，性能一般。</li>
<li><strong>CopyOnWriteArrayList</strong>（<strong>推荐</strong>）：<ul>
<li><strong>原理</strong>：写时复制（COW）。在进行写操作（add&#x2F;set）时，不直接修改原数组，而是复制一个新的数组进行修改，修改完后将引用指向新数组。</li>
<li><strong>场景</strong>：读多写少的并发场景，读取时无锁，性能很高。</li>
</ul>
</li>
</ol>
<h4 id="5-介绍下IoC和AOP"><a href="#5-介绍下IoC和AOP" class="headerlink" title="5. 介绍下IoC和AOP"></a>5. 介绍下IoC和AOP</h4><p>这是 Spring 的两大核心思想：</p>
<ul>
<li><strong>IoC (Inversion of Control) 控制反转</strong>：<ul>
<li><strong>概念</strong>：将对象的创建、管理和依赖关系的维护权，从代码中移除，交给 Spring 容器（Bean工厂）来管理。</li>
<li><strong>实现</strong>：主要通过 <strong>DI (Dependency Injection) 依赖注入</strong> 来实现（如 <code>@Autowired</code>）。</li>
<li><strong>好处</strong>：解耦，降低了类与类之间的耦合度。</li>
</ul>
</li>
<li><strong>AOP (Aspect Oriented Programming) 面向切面编程</strong>：<ul>
<li><strong>概念</strong>：将那些与业务无关，但多个业务模块都要调用的逻辑（如日志记录、事务管理、权限校验）封装起来，通过动态代理的方式插入到业务代码中。</li>
<li><strong>实现</strong>：基于 JDK 动态代理（接口）或 CGLIB（类继承）。</li>
<li><strong>好处</strong>：减少重复代码，专注于核心业务逻辑。</li>
</ul>
</li>
</ul>
<h4 id="6-SpringCloud了解吗？"><a href="#6-SpringCloud了解吗？" class="headerlink" title="6. SpringCloud了解吗？"></a>6. SpringCloud了解吗？</h4><p>（如果简历写了微服务必问，没写可以说了解概念）<br>Spring Cloud 是基于 Spring Boot 的微服务架构一站式解决方案。常见的组件（以 Spring Cloud Alibaba 为例）：</p>
<ul>
<li><strong>注册中心</strong>：Nacos &#x2F; Eureka（服务发现与注册）。</li>
<li><strong>配置中心</strong>：Nacos Config &#x2F; Spring Cloud Config（统一管理配置）。</li>
<li><strong>负载均衡</strong>：Ribbon &#x2F; Spring Cloud LoadBalancer。</li>
<li><strong>服务调用</strong>：OpenFeign（声明式 HTTP 客户端）。</li>
<li><strong>服务熔断&#x2F;降级</strong>：Sentinel &#x2F; Hystrix（防止雪崩效应）。</li>
<li><strong>网关</strong>：Spring Cloud Gateway（统一入口、鉴权、限流）。</li>
</ul>
<h4 id="7-Linux会吗，怎么查日志？"><a href="#7-Linux会吗，怎么查日志？" class="headerlink" title="7. Linux会吗，怎么查日志？"></a>7. Linux会吗，怎么查日志？</h4><ul>
<li><strong><code>tail -f filename.log</code></strong>：实时监控日志文件的末尾输出（最常用，看正在报错的信息）。</li>
<li><strong><code>grep &quot;关键字&quot; filename.log</code></strong>：根据关键字搜索日志（如搜索 “Exception” 或 “订单号”）。<ul>
<li>组合拳：<code>grep -C 10 &quot;Error&quot; app.log</code> （显示关键字前后10行）。</li>
</ul>
</li>
<li><strong><code>less filename.log</code></strong>：分页查看大文件（支持 <code>/</code> 向下搜索，<code>?</code> 向上搜索）。</li>
<li><strong><code>cat</code></strong>：查看小文件内容。</li>
</ul>
<h4 id="8-了解Redis的Hash吗，有什么用？"><a href="#8-了解Redis的Hash吗，有什么用？" class="headerlink" title="8. 了解Redis的Hash吗，有什么用？"></a>8. 了解Redis的Hash吗，有什么用？</h4><ul>
<li><strong>结构</strong>：类似于 Java 的 <code>HashMap&lt;String, HashMap&lt;String, String&gt;&gt;</code>，即 Key -&gt; (Field -&gt; Value)。</li>
<li><strong>用途</strong>：<ul>
<li><strong>存储对象</strong>：非常适合存储用户信息、商品详情等。例如 Key&#x3D;<code>user:1001</code>，Field&#x3D;<code>name</code> Value&#x3D;<code>Tom</code>，Field&#x3D;<code>age</code> Value&#x3D;<code>18</code>。</li>
<li><strong>优势</strong>：相比于 String 类型存储 JSON 字符串，Hash 可以<strong>单独修改</strong>对象的某个字段（如只改价格），而不需要序列化和反序列化整个对象，节省网络流量和内存。</li>
<li><strong>购物车</strong>：Key&#x3D;用户ID，Field&#x3D;商品ID，Value&#x3D;数量。</li>
</ul>
</li>
</ul>
<h4 id="9-编写MySQL语句的时候要遵循什么规范？"><a href="#9-编写MySQL语句的时候要遵循什么规范？" class="headerlink" title="9. 编写MySQL语句的时候要遵循什么规范？"></a>9. 编写MySQL语句的时候要遵循什么规范？</h4><ul>
<li><strong>避免 <code>SELECT *</code></strong>：按需查询字段，减少网络传输和回表操作，能利用覆盖索引最好。</li>
<li><strong>索引失效避坑</strong>：<ul>
<li>遵循<strong>最左前缀法则</strong>。</li>
<li>不在索引列上做运算（如 <code>WHERE year(create_time) = 2024</code>）。</li>
<li>避免使用 <code>!=</code> 或 <code>&lt;&gt;</code>。</li>
<li><code>LIKE</code> 查询不要以 <code>%</code> 开头。</li>
</ul>
</li>
<li><strong>分页优化</strong>：大数据量分页时，避免直接 <code>LIMIT 1000000, 10</code>，可以使用 <code>WHERE id &gt; 上一次最大ID LIMIT 10</code>。</li>
<li><strong>关键字大写</strong>：保持良好的 SQL 风格。</li>
</ul>
<hr>
<h3 id="第二部分：项目相关"><a href="#第二部分：项目相关" class="headerlink" title="第二部分：项目相关"></a>第二部分：项目相关</h3><h4 id="1-你登陆用户的Token如何设计的？"><a href="#1-你登陆用户的Token如何设计的？" class="headerlink" title="1. 你登陆用户的Token如何设计的？"></a>1. 你登陆用户的Token如何设计的？</h4><p>通常采用 <strong>JWT (JSON Web Token)</strong> 标准。</p>
<ul>
<li><strong>结构</strong>：Token 分为三部分：Header（头）、Payload（载荷，存 userId、过期时间等非敏感信息）、Signature（签名，防篡改）。</li>
<li><strong>流程</strong>：<ol>
<li>用户登录成功，服务端生成 JWT，包含 userId 和过期时间。</li>
<li>服务端返回 Token 给前端，前端存储在 LocalStorage 或 Cookie 中。</li>
<li>后续请求在 Header (<code>Authorization: Bearer &lt;token&gt;</code>) 中携带。</li>
<li>服务端校验签名是否正确、是否过期。</li>
</ol>
</li>
<li><strong>双Token方案（进阶）</strong>：设计 Access Token（短效，用于访问）和 Refresh Token（长效，用于刷新），提高安全性。</li>
</ul>
<h4 id="2-MyBatisPlus底层原理"><a href="#2-MyBatisPlus底层原理" class="headerlink" title="2. MyBatisPlus底层原理"></a>2. MyBatisPlus底层原理</h4><p>MyBatisPlus (MP) 本质上是 MyBatis 的<strong>增强工具</strong>，只做增强不做改变。</p>
<ul>
<li><strong>启动阶段</strong>：MP 会扫描实体类（Entity），根据注解（如 <code>@TableName</code>, <code>@TableId</code>）和反射机制，获取表名、字段名。</li>
<li><strong>SQL注入器 (ISqlInjector)</strong>：MP 内部有一个 <code>DefaultSqlInjector</code>，它预定义了通用的 CRUD SQL 模板（如 <code>selectById</code>, <code>insert</code>）。</li>
<li><strong>MappedStatement 注入</strong>：在启动时，MP 自动将生成的 SQL 语句注入到 MyBatis 的 Configuration 对象中。</li>
<li><strong>运行时</strong>：调用 Mapper 接口方法时，直接找到对应的 SQL 执行，无需手写 XML。</li>
<li><strong>插件机制</strong>：通过拦截器（Interceptor）实现分页、乐观锁、多租户等功能。</li>
</ul>
<h4 id="3-Cache-Aside（旁路缓存）为什么能保证数据一致性？"><a href="#3-Cache-Aside（旁路缓存）为什么能保证数据一致性？" class="headerlink" title="3. Cache Aside（旁路缓存）为什么能保证数据一致性？"></a>3. Cache Aside（旁路缓存）为什么能保证数据一致性？</h4><p>Cache Aside 是最常用的缓存读写策略。</p>
<ul>
<li><strong>读策略</strong>：先读缓存 -&gt; 命中返回；未命中读数据库 -&gt; 写入缓存 -&gt; 返回。</li>
<li><strong>写策略</strong>：<strong>先更新数据库，再删除缓存</strong>。</li>
<li><strong>为什么是删除而不是更新缓存？</strong><ul>
<li><strong>避免脏数据</strong>：如果是更新缓存，在并发写的情况下，可能出现“线程A改DB -&gt; 线程B改DB -&gt; 线程B改缓存 -&gt; 线程A改缓存”，导致缓存存的是旧值（脏数据）。</li>
<li><strong>懒加载</strong>：删除缓存后，下一次读取时才会去计算并放入缓存，避免频繁更新缓存但没人读的情况，节省性能。</li>
</ul>
</li>
<li><strong>一致性保证</strong>：<ul>
<li>它保证的是<strong>最终一致性</strong>，而非强一致性。</li>
<li><strong>极端情况</strong>：DB更新成功，缓存删除失败。解决方案是利用<strong>消息队列重试机制</strong>来删除缓存，或者使用<strong>Canal</strong>监听 Binlog 异步删除缓存。</li>
<li><strong>延时双删</strong>：为了防止在“读写并发”时，旧数据被读线程重新写入缓存，可以在删除缓存后，休眠一小段时间再次删除。</li>
</ul>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/12/01/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%8303/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/11/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6/">
        <h2 class="post-title">大模型开发如何自学</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/11/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>入门大模型（LLM）开发，<strong>不要一上来就去啃算法数学公式</strong>（那是科学家做的事），作为开发者，你应该从<strong>应用工程（AI Engineering）</strong> 角度切入。</p>
<p>现在的 LLM 开发主要分为三个阶段：<strong>Prompt 工程</strong> -&gt; <strong>RAG（外挂知识库）</strong> -&gt; <strong>微调（Fine-tuning）</strong>。</p>
<p>以下是保姆级的快速入门路径和文档推荐：</p>
<hr>
<h3 id="第一阶段：API-调用与-Prompt-工程（先跑通）"><a href="#第一阶段：API-调用与-Prompt-工程（先跑通）" class="headerlink" title="第一阶段：API 调用与 Prompt 工程（先跑通）"></a>第一阶段：API 调用与 Prompt 工程（先跑通）</h3><p>这是最简单的入门方式。你不需要显卡，只需要会写 Python（或者 Java，但 Python 生态最强）。</p>
<ul>
<li><p><strong>核心任务</strong>：学会申请 Key，调用 API，理解 <code>System Prompt</code>（系统提示词）、<code>Temperature</code>（随机性）等参数。</p>
</li>
<li><p><strong>推荐路线</strong>：</p>
<ol>
<li><strong>选一个模型</strong>：<ul>
<li><strong>国际标准</strong>：<a target="_blank" rel="noopener" href="https://platform.openai.com/docs/introduction">OpenAI</a> (ChatGPT)。文档是行业标杆，必读。</li>
<li><strong>国内首选</strong>：<a target="_blank" rel="noopener" href="https://platform.deepseek.com/">DeepSeek (深度求索)</a> 或 <a target="_blank" rel="noopener" href="https://open.bigmodel.cn/dev/howuse/introduction">智谱 AI (ChatGLM)</a>。国内访问快，送免费额度，API 兼容 OpenAI 格式。</li>
</ul>
</li>
<li><strong>看文档</strong>：<ul>
<li><strong>OpenAI Cookbook</strong>（必看）：官方出的“食谱”，里面有大量代码示例（怎么写摘要、怎么做翻译）。</li>
<li><em>Github地址</em>：<a target="_blank" rel="noopener" href="https://github.com/openai/openai-cookbook">openai-cookbook</a></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>你需要掌握的概念</strong>：</p>
<ul>
<li><strong>Prompt</strong>：你对 AI 说的话。</li>
<li><strong>Token</strong>：计费单位（约等于字数）。</li>
<li><strong>Context Window</strong>：上下文窗口（AI 能记住多少之前的对话）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第二阶段：应用框架开发（LangChain-LlamaIndex）"><a href="#第二阶段：应用框架开发（LangChain-LlamaIndex）" class="headerlink" title="第二阶段：应用框架开发（LangChain&#x2F;LlamaIndex）"></a>第二阶段：应用框架开发（LangChain&#x2F;LlamaIndex）</h3><p>当你觉得直接调 API 处理复杂逻辑很麻烦（比如要处理长文本、要联网搜索），你就需要框架了。</p>
<ul>
<li><p><strong>核心工具</strong>：</p>
<ol>
<li><strong>LangChain</strong>：目前最火的 LLM 开发框架。它把“读文件”、“切分文本”、“存数据库”、“调大模型”串成了一条链。<ul>
<li><em>缺点</em>：文档有点乱，概念多。</li>
<li><em>文档</em>：<a target="_blank" rel="noopener" href="https://python.langchain.com/docs/get_started/introduction">LangChain Python Docs</a></li>
</ul>
</li>
<li><strong>LlamaIndex</strong>：如果你主要想做“<strong>把我的私有数据喂给 AI</strong>”这件事，用它更简单高效。<ul>
<li><em>文档</em>：<a target="_blank" rel="noopener" href="https://docs.llamaindex.ai/en/stable/">LlamaIndex Docs</a></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>必做 Demo</strong>：写一个“<strong>基于本地 PDF 文档的问答机器人</strong>”。这能让你学会目前最主流的 <strong>RAG (检索增强生成)</strong> 技术。</p>
</li>
</ul>
<p>你看得很准！你列出的这套技术栈（<strong>LangGraph + DeepSeek&#x2F;GPT + Chroma&#x2F;Milvus + BGE-M3</strong>）是目前构建<strong>生产级、复杂 Agent 应用</strong>的**“黄金标准”**。</p>
<p>这套组合已经脱离了简单的“玩具 Demo”阶段，能够真正解决工业界遇到的痛点（如：逻辑死循环、上下文丢失、只会单向执行不懂反思）。</p>
<p>以下是对你这套技术栈的<strong>深度解析</strong>和<strong>落地建议</strong>，帮助你把它们串起来：</p>
<hr>
<h3 id="1-核心编排：LangGraph-Agent-的大脑"><a href="#1-核心编排：LangGraph-Agent-的大脑" class="headerlink" title="1. 核心编排：LangGraph (Agent 的大脑)"></a>1. 核心编排：LangGraph (Agent 的大脑)</h3><blockquote>
<p><strong>你的评价非常到位：</strong> 相比 LangChain 传统的 Chain（单向链表），LangGraph 是图（Graph）。</p>
</blockquote>
<ul>
<li><strong>为什么要换 LangGraph？</strong><ul>
<li><strong>有状态（Stateful）</strong>：传统的 Chain 跑完就忘。LangGraph 有一个全局的 <code>State</code>（状态对象），所有节点都能读写这个状态。这就像给了 AI 一个“短期记忆本”，它知道自己刚才查了什么，现在缺什么。</li>
<li><strong>循环与反思（Cyclic &amp; Reflection）</strong>：这是最强的点。<ul>
<li><em>Chain</em>：输入 -&gt; 步骤A -&gt; 步骤B -&gt; 结束。（一条路走到黑）</li>
<li><em>Graph</em>：输入 -&gt; 步骤A -&gt; 检查结果 -&gt; <strong>觉得不行</strong> -&gt; <strong>回到步骤A重做</strong> -&gt; 结束。</li>
</ul>
</li>
<li><strong>应用场景</strong>：比如写代码助手。写代码 -&gt; 运行报错 -&gt; 读取错误 -&gt; <strong>跳回写代码步骤修正</strong> -&gt; 再运行 -&gt; 成功。</li>
</ul>
</li>
</ul>
<h3 id="2-模型层：LLM-接口-动力源"><a href="#2-模型层：LLM-接口-动力源" class="headerlink" title="2. 模型层：LLM 接口 (动力源)"></a>2. 模型层：LLM 接口 (动力源)</h3><blockquote>
<p><strong>推荐</strong>：DeepSeek (性价比之王) &#x2F; GPT-4o (逻辑天花板)</p>
</blockquote>
<ul>
<li><strong>对接建议</strong>：<ul>
<li>虽然 LangChain 有封装好的 ChatOpenAI 类，但在 LangGraph 中，通常直接调用这些模型来做<strong>决策（Router）</strong>。</li>
<li><strong>工具调用（Function Calling）</strong>：这是 Agent 的核心。DeepSeek V3&#x2F;R1 和 GPT-4 的 Function Calling 能力最强，能精准地输出 JSON 格式来告诉程序该去查数据库还是该去搜索。</li>
</ul>
</li>
</ul>
<h3 id="3-RAG-核心：Embedding-与-向量库-海马体"><a href="#3-RAG-核心：Embedding-与-向量库-海马体" class="headerlink" title="3. RAG 核心：Embedding 与 向量库 (海马体)"></a>3. RAG 核心：Embedding 与 向量库 (海马体)</h3><h4 id="Embedding-模型：BGE-M3-vs-M3E"><a href="#Embedding-模型：BGE-M3-vs-M3E" class="headerlink" title="Embedding 模型：BGE-M3 vs M3E"></a>Embedding 模型：BGE-M3 vs M3E</h4><p>你提到的 <code>bge-m3</code> 是目前的<strong>中文最强开源 Embedding</strong>（智源出品）。</p>
<ul>
<li><strong>BGE-M3 的优势</strong>：它支持 <strong>混合检索</strong>（Dense + Sparse）。<ul>
<li><em>Dense (稠密)</em>：懂语义（比如搜“苹果”，它知道你想找“水果”或“手机”）。</li>
<li><em>Sparse (稀疏)</em>：懂关键词匹配（类似倒排索引，精准匹配专有名词）。</li>
<li><strong>落地建议</strong>：如果你的机器跑得动，<strong>无脑上 BGE-M3</strong>。如果资源受限（比如只有 CPU），用 <code>m3e-base</code> 或 <code>bge-small-zh</code>。</li>
</ul>
</li>
</ul>
<h4 id="向量数据库：Chroma-vs-Milvus"><a href="#向量数据库：Chroma-vs-Milvus" class="headerlink" title="向量数据库：Chroma vs Milvus"></a>向量数据库：Chroma vs Milvus</h4><ul>
<li><strong>ChromaDB</strong>：<ul>
<li><em>优点</em>：<code>pip install chromadb</code> 就能用，无需 Docker，数据存在本地文件，极其适合开发测试和单机应用。</li>
<li><em>缺点</em>：不支持分布式，数据量百万级以上性能下降。</li>
</ul>
</li>
<li><strong>Milvus</strong>：<ul>
<li><em>优点</em>：云原生，Kubernetes 友好，亿级数据毫秒响应，大厂标配。</li>
<li><em>缺点</em>：部署重（依赖 MinIO, Etcd 等组件）。</li>
</ul>
</li>
<li><strong>选型建议</strong>：<strong>开发阶段用 Chroma，上线前看数据量，超过 500万条再迁移到 Milvus。</strong></li>
</ul>
<hr>
<h3 id="4-实战架构：如何把它们串起来？"><a href="#4-实战架构：如何把它们串起来？" class="headerlink" title="4. 实战架构：如何把它们串起来？"></a>4. 实战架构：如何把它们串起来？</h3><p>假设你要做一个**“智能课程推荐助手”**，流程如下：</p>
<h4 id="第一步：定义状态-State"><a href="#第一步：定义状态-State" class="headerlink" title="第一步：定义状态 (State)"></a>第一步：定义状态 (State)</h4><p>在 LangGraph 中，先定义一个 Python 类（TypedDict）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgentState</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    query: <span class="built_in">str</span>          <span class="comment"># 用户原始问题</span></span><br><span class="line">    user_profile: <span class="built_in">dict</span>  <span class="comment"># 用户画像</span></span><br><span class="line">    documents: <span class="type">List</span>[<span class="built_in">str</span>]<span class="comment"># 查到的课程资料</span></span><br><span class="line">    answer: <span class="built_in">str</span>         <span class="comment"># 最终回复</span></span><br><span class="line">    retry_count: <span class="built_in">int</span>    <span class="comment"># 重试次数（防止死循环）</span></span><br></pre></td></tr></table></figure>

<h4 id="第二步：定义节点-Nodes"><a href="#第二步：定义节点-Nodes" class="headerlink" title="第二步：定义节点 (Nodes)"></a>第二步：定义节点 (Nodes)</h4><p>每个节点是一个函数，接收 State，修改 State，返回 State。</p>
<ol>
<li><strong>Node_Retrieve_User</strong>：去数据库查这个用户是谁（初学者还是专家？）。</li>
<li><strong>Node_Search_Course</strong>：拿着用户画像 + 问题，去 <strong>ChromaDB</strong> (用 BGE-M3 向量化) 检索相关课程。</li>
<li><strong>Node_Generate</strong>：调用 <strong>DeepSeek</strong>，根据资料生成回答。</li>
<li><strong>Node_Reflect (反思)</strong>：让 LLM 自己检查回答是否解决了用户问题。如果没解决，修改搜索关键词。</li>
</ol>
<h4 id="第三步：构建图-Graph-边缘-Edges"><a href="#第三步：构建图-Graph-边缘-Edges" class="headerlink" title="第三步：构建图 (Graph) &amp; 边缘 (Edges)"></a>第三步：构建图 (Graph) &amp; 边缘 (Edges)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> StateGraph, END</span><br><span class="line"></span><br><span class="line">workflow = StateGraph(AgentState)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加节点</span></span><br><span class="line">workflow.add_node(<span class="string">&quot;查用户&quot;</span>, retrieve_user_node)</span><br><span class="line">workflow.add_node(<span class="string">&quot;查课程&quot;</span>, search_course_node)</span><br><span class="line">workflow.add_node(<span class="string">&quot;生成&quot;</span>, generate_node)</span><br><span class="line">workflow.add_node(<span class="string">&quot;反思&quot;</span>, reflect_node)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义流程（边缘）</span></span><br><span class="line">workflow.set_entry_point(<span class="string">&quot;查用户&quot;</span>)</span><br><span class="line">workflow.add_edge(<span class="string">&quot;查用户&quot;</span>, <span class="string">&quot;查课程&quot;</span>)</span><br><span class="line">workflow.add_edge(<span class="string">&quot;查课程&quot;</span>, <span class="string">&quot;生成&quot;</span>)</span><br><span class="line">workflow.add_edge(<span class="string">&quot;生成&quot;</span>, <span class="string">&quot;反思&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重点：条件边（Conditional Edge）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_quality</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">if</span> state[<span class="string">&#x27;answer&#x27;</span>] == <span class="string">&quot;不知道&quot;</span> <span class="keyword">and</span> state[<span class="string">&#x27;retry_count&#x27;</span>] &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;查课程&quot;</span> <span class="comment"># 没查到，换个词跳回去重查</span></span><br><span class="line">    <span class="keyword">return</span> END <span class="comment"># 查到了，或者重试次数用完了，结束</span></span><br><span class="line"></span><br><span class="line">workflow.add_conditional_edges(</span><br><span class="line">    <span class="string">&quot;反思&quot;</span>,</span><br><span class="line">    check_quality,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;查课程&quot;</span>: <span class="string">&quot;查课程&quot;</span>,</span><br><span class="line">        END: END</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app = workflow.<span class="built_in">compile</span>()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-总结你的学习路径"><a href="#5-总结你的学习路径" class="headerlink" title="5. 总结你的学习路径"></a>5. 总结你的学习路径</h3><p>既然你已经到了这个阶段，接下来的重点不再是 API 怎么调，而是<strong>图的设计</strong>：</p>
<ol>
<li><strong>文档</strong>：<ul>
<li>去啃 <strong>LangGraph 官方文档</strong>（非常新，更新很快）。</li>
<li>去 HuggingFace 搜 <strong>BAAI&#x2F;bge-m3</strong> 查看它的用法。</li>
</ul>
</li>
<li><strong>实操</strong>：<ul>
<li>用 Docker 部署一个 Milvus（虽然重，但你需要熟悉一下 docker-compose）。</li>
<li>写一个简单的 <code>CRAG</code> (Corrective RAG) 架构：检索 -&gt; 评分 -&gt; (如果分低) -&gt; 联网搜索 -&gt; 生成。</li>
</ul>
</li>
</ol>
<p>这套架构学会了，你就是市面上稀缺的<strong>高级 AI 应用工程师</strong>。加油！</p>
<hr>
<h3 id="第三阶段：本地部署开源模型（Ollama）"><a href="#第三阶段：本地部署开源模型（Ollama）" class="headerlink" title="第三阶段：本地部署开源模型（Ollama）"></a>第三阶段：本地部署开源模型（Ollama）</h3><p>如果你不想花钱调 API，或者数据由于隐私不能上网，你需要在自己电脑上跑模型。</p>
<ul>
<li><p><strong>神器推荐：Ollama</strong></p>
<ul>
<li>这是目前最无脑、最简单的本地大模型运行工具。</li>
<li><em>操作</em>：下载安装 -&gt; 终端输入 <code>ollama run llama3</code> -&gt; 完事。</li>
<li><em>文档</em>：<a target="_blank" rel="noopener" href="https://github.com/ollama/ollama">Ollama Github</a></li>
</ul>
</li>
<li><p><strong>模型推荐</strong>：</p>
<ul>
<li><code>Llama 3</code> (Meta出品，开源最强)</li>
<li><code>Qwen</code> (通义千问，中文能力极强)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第四阶段：系统学习资源（最好的教程）"><a href="#第四阶段：系统学习资源（最好的教程）" class="headerlink" title="第四阶段：系统学习资源（最好的教程）"></a>第四阶段：系统学习资源（最好的教程）</h3><p>不要去B站乱翻视频，直接看吴恩达（Andrew Ng）的 DeepLearning.AI 出的短课程，<strong>免费、权威、极简</strong>（每门课只有 1-2 小时）。</p>
<ol>
<li><strong>入门必看</strong>：<ul>
<li><strong>ChatGPT Prompt Engineering for Developers</strong> (面向开发者的提示工程) —— 教你怎么写好 Prompt。</li>
</ul>
</li>
<li><strong>进阶必看</strong>：<ul>
<li><strong>LangChain for LLM Application Development</strong> —— LangChain 作者亲自教你怎么用。</li>
<li><strong>Building Systems with the ChatGPT API</strong> —— 教怎么构建系统。</li>
</ul>
</li>
</ol>
<ul>
<li><em>观看地址</em>：DeepLearning.AI 官网（英文），或者 B站搜索“吴恩达 大模型”有汉化搬运。</li>
</ul>
<hr>
<h3 id="总结：你的行动清单"><a href="#总结：你的行动清单" class="headerlink" title="总结：你的行动清单"></a>总结：你的行动清单</h3><ol>
<li><strong>第一天</strong>：注册一个 DeepSeek 或 OpenAI 账号，用 Python 写几行代码调用 API，让它给你讲个笑话。（感受 Input&#x2F;Output）。</li>
<li><strong>第二天</strong>：安装 <strong>Ollama</strong>，在本地跑一个 <code>qwen2:7b</code>，体验离线对话。</li>
<li><strong>第三天</strong>：看吴恩达的《Prompt Engineering》课程。</li>
<li><strong>第四天</strong>：学习 <strong>LangChain</strong>，尝试写一个脚本，让 AI 读取你的一个 <code>.txt</code> 笔记并总结内容。</li>
</ol>
<p><strong>避坑指南</strong>：</p>
<ul>
<li><strong>别去学怎么训练模型（Pre-training）</strong>，那需要几百万的显卡。</li>
<li><strong>别去死磕数学原理</strong>，Transformer 的架构图看懂个大概就行，把它当成一个“黑盒函数”去调用。</li>
<li><strong>文档优先看英文</strong>，AI 技术迭代太快，中文文档通常是滞后的。</li>
</ul>
<p>需要具体的 Python 代码示例（比如怎么调用 API）吗？我可以写给你。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/11/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/11/29/%E5%85%AB%E8%82%A1%E6%96%B9%E5%90%9102/">
        <h2 class="post-title">八股训练02</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/11/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <hr>
<h1 id="🚀-Java-后端高级面试备战指南：从“知道”到“精通”"><a href="#🚀-Java-后端高级面试备战指南：从“知道”到“精通”" class="headerlink" title="🚀 Java 后端高级面试备战指南：从“知道”到“精通”"></a>🚀 Java 后端高级面试备战指南：从“知道”到“精通”</h1><p>这份清单针对中高级开发岗位，重点在于<strong>源码理解</strong>、<strong>底层原理</strong>以及<strong>高并发场景下的实战解决方案</strong>。请务必按照“深挖&#x2F;避坑”部分的提示进行针对性复习。</p>
<h2 id="🏗️-一、-Java-基础：地基要稳"><a href="#🏗️-一、-Java-基础：地基要稳" class="headerlink" title="🏗️ 一、 Java 基础：地基要稳"></a>🏗️ 一、 Java 基础：地基要稳</h2><blockquote>
<p><strong>核心重点</strong>：HashMap 源码、线程池参数与运行流程。</p>
</blockquote>
<h3 id="🔍-深挖与避坑"><a href="#🔍-深挖与避坑" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>HashMap</strong>：<ul>
<li><strong>结构演变</strong>：熟背 JDK 1.7（数组+链表）与 1.8（数组+链表+红黑树）的区别。</li>
<li><strong>扩容机制</strong>：重点理解 1.8 的优化（利用高位 0&#x2F;1 判断，无需重新计算 Hash）。</li>
<li><strong>线程不安全</strong>：1.7 的死循环问题，1.8 的数据覆盖问题。</li>
</ul>
</li>
<li><strong>线程池 (ThreadPool)</strong>：<ul>
<li><strong>参数配置</strong>：7 大参数必背。</li>
<li><strong>场景化设置</strong>：<ul>
<li><strong>CPU 密集型</strong>：<code>CPU核数 + 1</code>。</li>
<li><strong>IO 密集型</strong>：<code>CPU核数 * 2</code> 或 <code>CPU / (1 - 阻塞系数)</code>。</li>
</ul>
</li>
<li><strong>拒绝策略</strong>：默认 <code>AbortPolicy</code>，生产环境如何自定义？</li>
<li><strong>队列区别</strong>：<code>ArrayBlockingQueue</code> (有界) vs <code>LinkedBlockingQueue</code> (默认无界，易 OOM) 的区别是必考点。</li>
</ul>
</li>
</ul>
<h2 id="⚡-二、-JUC-并发编程-：高薪分水岭"><a href="#⚡-二、-JUC-并发编程-：高薪分水岭" class="headerlink" title="⚡ 二、 JUC (并发编程)：高薪分水岭"></a>⚡ 二、 JUC (并发编程)：高薪分水岭</h2><blockquote>
<p><strong>核心重点</strong>：ReentrantLock 源码、AQS 核心原理。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-1"><a href="#🔍-深挖与避坑-1" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>AQS (AbstractQueuedSynchronizer)</strong>：<ul>
<li>JUC 的基石。必须理解 <strong>state 变量</strong>（锁状态）和 <strong>CLH 队列</strong>（双向链表，存储等待线程）的工作流程。</li>
</ul>
</li>
<li><strong>Synchronized vs Lock</strong>：<ul>
<li>不仅是 API 区别，要懂底层：<code>synchronized</code> 基于对象头 Mark Word 和 Monitor；Lock 是 Java 层面实现。</li>
</ul>
</li>
<li><strong>原子类与 CAS</strong>：<ul>
<li><strong>ABA 问题</strong>：值变了又变回来。解决方案：<strong>版本号</strong>或<strong>时间戳</strong>（<code>AtomicStampedReference</code>）。</li>
</ul>
</li>
</ul>
<h2 id="☕-三、-JVM：进阶必懂"><a href="#☕-三、-JVM：进阶必懂" class="headerlink" title="☕ 三、 JVM：进阶必懂"></a>☕ 三、 JVM：进阶必懂</h2><blockquote>
<p><strong>核心重点</strong>：类加载（双亲委派）、内存模型、GC。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-2"><a href="#🔍-深挖与避坑-2" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>GC (垃圾回收)</strong>：<em>(必补项)</em><ul>
<li><strong>算法</strong>：复制算法（新生代）、标记-整理（老年代）。</li>
<li><strong>收集器</strong>：CMS 和 G1 的区别（重点掌握 G1 的 Region 概念）。</li>
</ul>
</li>
<li><strong>OOM 排查实战</strong>：<ul>
<li>是否使用过 <code>jstat</code>, <code>jmap</code>, <code>MAT</code> 工具？</li>
<li>分析 Dump 文件的流程（定位大对象、泄漏点）是面试极大的加分项。</li>
</ul>
</li>
</ul>
<h2 id="🌱-四、-Spring-Boot：框架原理"><a href="#🌱-四、-Spring-Boot：框架原理" class="headerlink" title="🌱 四、 Spring Boot：框架原理"></a>🌱 四、 Spring Boot：框架原理</h2><blockquote>
<p><strong>核心重点</strong>：AOP&#x2F;IOC 原理、三级缓存、自动配置。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-3"><a href="#🔍-深挖与避坑-3" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>三级缓存</strong>：<ul>
<li>核心目的：解决<strong>循环依赖</strong>。</li>
<li>难点：为什么需要第三级？（为了在对象实例化后、初始化前，提前暴露 <strong>AOP 代理对象</strong>）。</li>
</ul>
</li>
<li><strong>Bean 的生命周期</strong>：<ul>
<li>流程：<code>实例化</code> -&gt; <code>属性赋值</code> -&gt; <code>初始化</code> -&gt; <code>销毁</code>。</li>
<li>关键点：<code>BeanPostProcessor</code> 在 AOP 中的作用。</li>
</ul>
</li>
<li><strong>事务失效场景</strong>：<ul>
<li>类内部自调用（<code>this.method()</code> 不走代理）。</li>
<li>方法非 <code>public</code>。</li>
<li>异常被 <code>try-catch</code> 吞掉，未抛出。</li>
</ul>
</li>
</ul>
<h2 id="💾-五、-数据库-MySQL-：重中之重"><a href="#💾-五、-数据库-MySQL-：重中之重" class="headerlink" title="💾 五、 数据库 (MySQL)：重中之重"></a>💾 五、 数据库 (MySQL)：重中之重</h2><blockquote>
<p><strong>核心重点</strong>：索引原理、事务 (MVCC)、三大日志、SQL 调优。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-4"><a href="#🔍-深挖与避坑-4" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>索引</strong>：<ul>
<li><strong>数据结构</strong>：为什么选 B+ 树（层高低、范围查询好）而不是 B 树？</li>
<li><strong>回表</strong>：聚簇索引 vs 非聚簇索引的区别。</li>
<li><strong>失效</strong>：最左前缀原则、索引列计算等场景。</li>
</ul>
</li>
<li><strong>MVCC (多版本并发控制)</strong>：<ul>
<li>不要死背定义。核心是 <strong>Read View (读视图)</strong> + <strong>Undo Log 版本链</strong> 如何配合实现“可重复读”隔离级别。</li>
</ul>
</li>
<li><strong>三大日志</strong>：<ul>
<li><strong>Binlog</strong>：主从复制，归档。</li>
<li><strong>Redo Log</strong>：物理日志，保证持久性 (Crash-safe)。</li>
<li><strong>Undo Log</strong>：逻辑日志，保证原子性 (回滚)。</li>
</ul>
</li>
</ul>
<h2 id="🚀-六、-Redis：性能利器"><a href="#🚀-六、-Redis：性能利器" class="headerlink" title="🚀 六、 Redis：性能利器"></a>🚀 六、 Redis：性能利器</h2><blockquote>
<p><strong>核心重点</strong>：数据结构、缓存异常、一致性、分布式锁。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-5"><a href="#🔍-深挖与避坑-5" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>缓存一致性</strong>：<em>(高频难点)</em><ul>
<li>方案对比：延时双删 vs 先删缓存再更新库。</li>
<li><strong>大厂方案</strong>：订阅 Binlog (Canal) -&gt; 消息队列 -&gt; 异步删除缓存（最终一致性）。</li>
</ul>
</li>
<li><strong>分布式锁</strong>：<ul>
<li><code>setnx</code> 缺陷：业务没跑完锁过期怎么办？</li>
<li><strong>解决方案</strong>：Redisson 的 <strong>WatchDog (看门狗)</strong> 机制自动续期。</li>
</ul>
</li>
<li><strong>底层结构</strong>：<ul>
<li><strong>跳表 (SkipList)</strong>：ZSet 为什么用跳表不用红黑树？（实现简单、并发好、范围查询效率高）。</li>
</ul>
</li>
</ul>
<h2 id="📨-七、-消息队列-MQ-：解耦削峰"><a href="#📨-七、-消息队列-MQ-：解耦削峰" class="headerlink" title="📨 七、 消息队列 (MQ)：解耦削峰"></a>📨 七、 消息队列 (MQ)：解耦削峰</h2><blockquote>
<p><strong>核心重点</strong>：Kafka&#x2F;RocketMQ 选型、消息丢失&#x2F;重复&#x2F;积压。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-6"><a href="#🔍-深挖与避坑-6" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>消息不丢失</strong>：<ul>
<li>涉及三端确认：生产者 ACK、Broker 同步刷盘&#x2F;多副本、消费者手动 ACK。</li>
</ul>
</li>
<li><strong>消息积压处理</strong>：<ul>
<li>线上事故应对：临时新建 Topic，将积压消息转发，开启多倍消费者进行消费。</li>
</ul>
</li>
</ul>
<h2 id="🛠️-八、-项目经验：面试的“胜负手”"><a href="#🛠️-八、-项目经验：面试的“胜负手”" class="headerlink" title="🛠️ 八、 项目经验：面试的“胜负手”"></a>🛠️ 八、 项目经验：面试的“胜负手”</h2><blockquote>
<p><strong>策略</strong>：面试官不关心普通的 CRUD，关心的是<strong>难点</strong>和<strong>思考</strong>。</p>
</blockquote>
<h3 id="🌟-STAR-原则准备法-准备-2-个技术难点"><a href="#🌟-STAR-原则准备法-准备-2-个技术难点" class="headerlink" title="🌟 STAR 原则准备法 (准备 2 个技术难点)"></a>🌟 STAR 原则准备法 (准备 2 个技术难点)</h3><ol>
<li><strong>S (Situation 情境)</strong>：高并发秒杀&#x2F;大流量&#x2F;复杂业务。</li>
<li><strong>T (Task 任务)</strong>：防止超卖、保证服务稳定性。</li>
<li><strong>A (Action 行动)</strong>：使用了 Redis 预减库存 + Lua 脚本保证原子性，配合 RabbitMQ 异步下单削峰。</li>
<li><strong>R (Result 结果)</strong>：最终支撑了 X QPS，响应时间降低了 Y%，且数据零丢失。</li>
</ol>
<h2 id="🌐-九、-计算机网络：基础素养"><a href="#🌐-九、-计算机网络：基础素养" class="headerlink" title="🌐 九、 计算机网络：基础素养"></a>🌐 九、 计算机网络：基础素养</h2><blockquote>
<p><strong>核心重点</strong>：TCP&#x2F;UDP、HTTP&#x2F;HTTPS、URL 请求流程。</p>
</blockquote>
<h3 id="🔍-深挖与避坑-7"><a href="#🔍-深挖与避坑-7" class="headerlink" title="🔍 深挖与避坑"></a>🔍 深挖与避坑</h3><ul>
<li><strong>HTTPS</strong>：SSL&#x2F;TLS 握手过程（公钥传输 -&gt; 协商 -&gt; 对称加密通信）。</li>
<li><strong>TCP 粘包&#x2F;拆包</strong>：在 Netty 中如何解决？（固定长度、分隔符、长度字段字段法）。</li>
</ul>
<hr>
<h2 id="🎁-补充：加分项-Bonus"><a href="#🎁-补充：加分项-Bonus" class="headerlink" title="🎁 补充：加分项 (Bonus)"></a>🎁 补充：加分项 (Bonus)</h2><h3 id="1-算法-LeetCode"><a href="#1-算法-LeetCode" class="headerlink" title="1. 算法 (LeetCode)"></a>1. 算法 (LeetCode)</h3><ul>
<li>虽然未列入必须，但大厂必考。</li>
<li><strong>底线</strong>：Top 100 题。重点刷：链表（反转）、二叉树（遍历&#x2F;深度）、动态规划、手写快排、二分查找。</li>
</ul>
<h3 id="2-Linux-Docker"><a href="#2-Linux-Docker" class="headerlink" title="2. Linux &#x2F; Docker"></a>2. Linux &#x2F; Docker</h3><ul>
<li><strong>常用命令</strong>：<code>top</code> (看负载), <code>awk</code>&#x2F;<code>grep</code> (查日志), <code>tail -f</code>。</li>
<li><strong>容器化</strong>：Docker 基本操作，K8s 概念了解。</li>
</ul>
<hr>
<h3 id="💡-最后建议"><a href="#💡-最后建议" class="headerlink" title="💡 最后建议"></a>💡 最后建议</h3><p><strong>不要只“看”，要“讲”</strong>。<br>每一个知识点，尝试对着镜子用自己的话完整的讲一遍逻辑。只有能流利地讲清楚原理和方案，才算真正拿下了这个知识点。<strong>祝你面试顺利，Offer 拿到手软！</strong></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/11/29/%E5%85%AB%E8%82%A1%E6%96%B9%E5%90%9102/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/11/29/%E5%85%AB%E8%82%A1%E6%96%B9%E5%90%9101/">
        <h2 class="post-title">八股训练01</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/11/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <hr>
<h1 id="☕-Java-后端经典面试题库-32题详解"><a href="#☕-Java-后端经典面试题库-32题详解" class="headerlink" title="☕ Java 后端经典面试题库 (32题详解)"></a>☕ Java 后端经典面试题库 (32题详解)</h1><p>这份题库涵盖了 Java 基础、集合框架、并发编程、JVM、数据库、中间件、Spring 框架以及个人成长等核心领域，适合面试前的查漏补缺和系统复习。</p>
<h2 id="📌-一、-Java-基础与面向对象"><a href="#📌-一、-Java-基础与面向对象" class="headerlink" title="📌 一、 Java 基础与面向对象"></a>📌 一、 Java 基础与面向对象</h2><h3 id="1-对-Java-面向对象怎么理解的？"><a href="#1-对-Java-面向对象怎么理解的？" class="headerlink" title="1. 对 Java 面向对象怎么理解的？"></a>1. 对 Java 面向对象怎么理解的？</h3><ul>
<li><strong>核心思想</strong>：将现实世界的事物抽象为“对象”，重点在于通过对象之间的<strong>交互</strong>来解决问题。</li>
<li><strong>对比面向过程</strong>：<ul>
<li>面向过程（如 C 语言）侧重于“步骤”和函数调用。</li>
<li>面向对象侧重于“谁来做”以及对象间的职责分配。</li>
</ul>
</li>
<li><strong>优势</strong>：代码复用性高、易维护、易扩展、低耦合。</li>
</ul>
<h3 id="2-Java-面向对象的特性有哪些？"><a href="#2-Java-面向对象的特性有哪些？" class="headerlink" title="2. Java 面向对象的特性有哪些？"></a>2. Java 面向对象的特性有哪些？</h3><ol>
<li><strong>封装 (Encapsulation)</strong>：隐藏对象的属性和实现细节，仅对外公开接口，提高安全性。</li>
<li><strong>继承 (Inheritance)</strong>：子类继承父类的特征和行为，实现代码复用。</li>
<li><strong>多态 (Polymorphism)</strong>：同一个接口，使用不同的实例而执行不同操作（实现条件：继承、重写、父类引用指向子类对象）。</li>
<li><em>(补充)</em> <strong>抽象 (Abstraction)</strong>：提取事物的共性，忽略细节。</li>
</ol>
<h3 id="3-String-类可以被继承吗？"><a href="#3-String-类可以被继承吗？" class="headerlink" title="3. String 类可以被继承吗？"></a>3. String 类可以被继承吗？</h3><ul>
<li><strong>回答</strong>：不能。</li>
<li><strong>原因</strong>：String 类被 <code>final</code> 关键字修饰。</li>
<li><strong>设计目的</strong>：<ol>
<li><strong>安全</strong>：防止核心类被恶意篡改（如数据库连接串、类加载机制）。</li>
<li><strong>效率</strong>：配合字符串常量池（String Pool），只有不可变才能实现池化。</li>
<li><strong>线程安全</strong>：不可变对象天生是线程安全的。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="📂-二、-集合框架-Collections"><a href="#📂-二、-集合框架-Collections" class="headerlink" title="📂 二、 集合框架 (Collections)"></a>📂 二、 集合框架 (Collections)</h2><h3 id="4-ArrayList-和-LinkedList-的区别"><a href="#4-ArrayList-和-LinkedList-的区别" class="headerlink" title="4. ArrayList 和 LinkedList 的区别"></a>4. ArrayList 和 LinkedList 的区别</h3><ul>
<li><strong>底层结构</strong>：<code>ArrayList</code> 是动态数组；<code>LinkedList</code> 是双向链表。</li>
<li><strong>随机访问</strong>：<code>ArrayList</code> 支持 $O(1)$ 的随机访问（通过下标）；<code>LinkedList</code> 需要 $O(n)$ 遍历。</li>
<li><strong>增删效率</strong>：<ul>
<li><code>ArrayList</code> 尾部增删快，但在中间增删需要数组扩容和内存拷贝，较慢。</li>
<li><code>LinkedList</code> 增删节点快（$O(1)$），但定位节点位置较慢。</li>
</ul>
</li>
<li><strong>内存空间</strong>：<code>ArrayList</code> 存在扩容时的预留空间浪费；<code>LinkedList</code> 每个节点需存储前后指针，单节点开销较大。</li>
</ul>
<h3 id="5-HashMap-的扩容原理"><a href="#5-HashMap-的扩容原理" class="headerlink" title="5. HashMap 的扩容原理"></a>5. HashMap 的扩容原理</h3><ul>
<li><strong>触发条件</strong>：当 <code>size &gt; capacity * loadFactor</code>（默认负载因子 0.75）时触发。</li>
<li><strong>过程</strong>：<ol>
<li>创建一个新的数组，容量是原来的 <strong>2倍</strong>。</li>
<li><strong>Rehash</strong>：将旧数组中的元素重新映射到新数组中。</li>
</ol>
</li>
<li><strong>JDK 1.8 优化</strong>：不需要重新计算 Hash，只需要判断原 Hash 值新增的那个 bit 是 0 还是 1，从而决定是在“原位置”还是“原位置 + 旧容量”。</li>
</ul>
<h3 id="6-7-HashMap-的-key-可以为空吗？若为空会怎么样？"><a href="#6-7-HashMap-的-key-可以为空吗？若为空会怎么样？" class="headerlink" title="6 &amp; 7. HashMap 的 key 可以为空吗？若为空会怎么样？"></a>6 &amp; 7. HashMap 的 key 可以为空吗？若为空会怎么样？</h3><ul>
<li><strong>回答</strong>：可以为空。</li>
<li><strong>处理机制</strong>：HashMap 会将 key 为 <code>null</code> 的元素存放在数组索引为 <strong>0</strong> 的位置（内部强制 hash 值为 0）。</li>
<li><strong>注意</strong>：只能有一个 key 为 <code>null</code>，但可以有多个 value 为 <code>null</code>。</li>
</ul>
<h3 id="8-Set-有了解吗，怎么保证数据不重复的？-重点"><a href="#8-Set-有了解吗，怎么保证数据不重复的？-重点" class="headerlink" title="8. Set 有了解吗，怎么保证数据不重复的？(重点)"></a>8. Set 有了解吗，怎么保证数据不重复的？(重点)</h3><ul>
<li><strong>底层实现</strong>：<code>HashSet</code> 底层其实就是一个 <code>HashMap</code>。数据存储在 HashMap 的 Key 上，Value 是一个固定的 <code>Object</code> 对象（PRESENT）。</li>
<li><strong>去重机制</strong>：<ol>
<li>计算元素的 <code>hashCode()</code>，定位到对应的桶（Bucket）。</li>
<li>如果桶无元素，直接存入。</li>
<li>如果桶有元素（Hash 冲突），调用 <code>equals()</code> 方法比较。</li>
<li>若 <code>equals()</code> 返回 true，视为重复，不添加；返回 false，则以链表&#x2F;红黑树形式追加。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="🚀-三、-并发编程-Concurrency"><a href="#🚀-三、-并发编程-Concurrency" class="headerlink" title="🚀 三、 并发编程 (Concurrency)"></a>🚀 三、 并发编程 (Concurrency)</h2><h3 id="9-进程和线程的区别"><a href="#9-进程和线程的区别" class="headerlink" title="9. 进程和线程的区别"></a>9. 进程和线程的区别</h3><ul>
<li><strong>定义</strong>：进程是<strong>资源分配</strong>的最小单位；线程是<strong>CPU调度</strong>的最小单位。</li>
<li><strong>关系</strong>：一个进程包含多个线程，线程共享进程的堆内存和方法区（元空间）。</li>
<li><strong>开销</strong>：进程切换开销大（独立内存空间），线程切换开销小。</li>
</ul>
<h3 id="10-操作系统的调度算法"><a href="#10-操作系统的调度算法" class="headerlink" title="10. 操作系统的调度算法"></a>10. 操作系统的调度算法</h3><ol>
<li><strong>先来先服务 (FCFS)</strong>。</li>
<li><strong>短作业优先 (SJF)</strong>。</li>
<li><strong>时间片轮转 (RR)</strong>（最常见，保证响应时间）。</li>
<li><strong>优先级调度</strong>。</li>
<li><strong>多级反馈队列调度</strong>。</li>
</ol>
<h3 id="11-Java-创建线程的方式"><a href="#11-Java-创建线程的方式" class="headerlink" title="11. Java 创建线程的方式"></a>11. Java 创建线程的方式</h3><ol>
<li>继承 <code>Thread</code> 类。</li>
<li>实现 <code>Runnable</code> 接口。</li>
<li>实现 <code>Callable</code> 接口（有返回值）。</li>
<li>使用线程池 (<code>ExecutorService</code>)。</li>
</ol>
<h3 id="12-Callable-和-Runnable-的区别"><a href="#12-Callable-和-Runnable-的区别" class="headerlink" title="12. Callable 和 Runnable 的区别"></a>12. Callable 和 Runnable 的区别</h3><ul>
<li><strong>返回值</strong>：<code>Runnable</code> 的 <code>run()</code> 返回 void；<code>Callable</code> 的 <code>call()</code> 有返回值（泛型）。</li>
<li><strong>异常</strong>：<code>Runnable</code> 不能抛出 Checked Exception；<code>Callable</code> 可以。</li>
<li><strong>执行</strong>：<code>Callable</code> 通常配合 <code>FutureTask</code> 或线程池使用，通过 <code>Future.get()</code> 获取结果。</li>
</ul>
<h3 id="13-线程池的核心参数"><a href="#13-线程池的核心参数" class="headerlink" title="13. 线程池的核心参数"></a>13. 线程池的核心参数</h3><ol>
<li><code>corePoolSize</code>：核心线程数（常驻）。</li>
<li><code>maximumPoolSize</code>：最大线程数。</li>
<li><code>keepAliveTime</code>：非核心线程空闲存活时间。</li>
<li><code>unit</code>：时间单位。</li>
<li><code>workQueue</code>：任务阻塞队列。</li>
<li><code>threadFactory</code>：线程工厂（用于命名线程等）。</li>
<li><code>handler</code>：拒绝策略（如 AbortPolicy, CallerRunsPolicy 等）。</li>
</ol>
<h3 id="14-线程池的-corePoolSize-大小的设置策略"><a href="#14-线程池的-corePoolSize-大小的设置策略" class="headerlink" title="14. 线程池的 corePoolSize 大小的设置策略"></a>14. 线程池的 corePoolSize 大小的设置策略</h3><ul>
<li><strong>CPU 密集型</strong>：CPU 核数 + 1（减少线程切换开销）。</li>
<li><strong>IO 密集型</strong>：CPU 核数 * 2 或 <code>CPU 核数 / (1 - 阻塞系数)</code>（因为 IO 操作不占用 CPU，可以多开线程）。</li>
</ul>
<hr>
<h2 id="☕-四、-JVM-Java-虚拟机"><a href="#☕-四、-JVM-Java-虚拟机" class="headerlink" title="☕ 四、 JVM (Java 虚拟机)"></a>☕ 四、 JVM (Java 虚拟机)</h2><h3 id="15-JVM-怎么判断对象是否是垃圾对象？"><a href="#15-JVM-怎么判断对象是否是垃圾对象？" class="headerlink" title="15. JVM 怎么判断对象是否是垃圾对象？"></a>15. JVM 怎么判断对象是否是垃圾对象？</h3><ul>
<li><strong>引用计数法</strong>（HotSpot 未采用）：有引用+1，失效-1。缺点：无法解决<strong>循环引用</strong>问题。</li>
<li><strong>可达性分析法</strong>（主流）：从 <strong>GC Roots</strong>（如栈帧中的局部变量、静态变量、常量引用等）出发，搜索引用的对象链。搜索不到的对象即为垃圾。</li>
</ul>
<h3 id="16-垃圾收集算法有哪些？"><a href="#16-垃圾收集算法有哪些？" class="headerlink" title="16. 垃圾收集算法有哪些？"></a>16. 垃圾收集算法有哪些？</h3><ol>
<li><strong>标记-清除 (Mark-Sweep)</strong>：容易产生内存碎片。</li>
<li><strong>标记-复制 (Copying)</strong>：新生代常用，效率高但浪费一半空间。</li>
<li><strong>标记-整理 (Mark-Compact)</strong>：老年代常用，解决碎片问题。</li>
<li><strong>分代收集</strong>：根据对象存活周期不同，新生代用复制算法，老年代用标记-整理算法。</li>
</ol>
<h3 id="17-对-Java-内存模型-JMM-有了解吗？"><a href="#17-对-Java-内存模型-JMM-有了解吗？" class="headerlink" title="17. 对 Java 内存模型 (JMM) 有了解吗？"></a>17. 对 Java 内存模型 (JMM) 有了解吗？</h3><ul>
<li><strong>目的</strong>：屏蔽硬件差异，解决并发中的<strong>原子性、可见性、有序性</strong>问题。</li>
<li><strong>结构</strong>：主内存（共享数据） vs 工作内存（线程私有缓存）。</li>
<li><strong>核心关键字</strong>：<ul>
<li><code>volatile</code>：保证可见性、禁止指令重排（有序性）。</li>
<li><code>synchronized</code>：保证原子性、可见性、有序性。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="💾-五、-数据库与中间件-MySQL-Redis"><a href="#💾-五、-数据库与中间件-MySQL-Redis" class="headerlink" title="💾 五、 数据库与中间件 (MySQL &amp; Redis)"></a>💾 五、 数据库与中间件 (MySQL &amp; Redis)</h2><h3 id="18-对-MySQL-中索引的理解、索引的分类"><a href="#18-对-MySQL-中索引的理解、索引的分类" class="headerlink" title="18. 对 MySQL 中索引的理解、索引的分类"></a>18. 对 MySQL 中索引的理解、索引的分类</h3><ul>
<li><strong>理解</strong>：索引是帮助快速查找数据的排好序的数据结构（通常是 <strong>B+树</strong>）。</li>
<li><strong>分类</strong>：<ul>
<li><strong>物理存储</strong>：聚簇索引（数据和索引在一起，如主键）、非聚簇索引（二级索引，叶子节点存主键）。</li>
<li><strong>逻辑约束</strong>：主键索引、唯一索引、普通索引、全文索引。</li>
<li><strong>字段个数</strong>：单列索引、联合索引（需遵循<strong>最左前缀原则</strong>）。</li>
</ul>
</li>
</ul>
<h3 id="19-Redis-数据结构有哪几种，应用场景？"><a href="#19-Redis-数据结构有哪几种，应用场景？" class="headerlink" title="19. Redis 数据结构有哪几种，应用场景？"></a>19. Redis 数据结构有哪几种，应用场景？</h3><ol>
<li><strong>String</strong>：缓存、计数器、分布式锁、Session 共享。</li>
<li><strong>List</strong>：消息队列、最新动态（时间轴）。</li>
<li><strong>Hash</strong>：存储对象（如用户信息、购物车）。</li>
<li><strong>Set</strong>：去重、抽奖、共同好友（交集操作）。</li>
<li><strong>ZSet (Sorted Set)</strong>：排行榜、带权重的队列。</li>
</ol>
<hr>
<h2 id="🔒-六、-高级并发与锁"><a href="#🔒-六、-高级并发与锁" class="headerlink" title="🔒 六、 高级并发与锁"></a>🔒 六、 高级并发与锁</h2><h3 id="20-阻塞队列和非阻塞队列的区别"><a href="#20-阻塞队列和非阻塞队列的区别" class="headerlink" title="20. 阻塞队列和非阻塞队列的区别"></a>20. 阻塞队列和非阻塞队列的区别</h3><ul>
<li><strong>阻塞队列</strong>（如 <code>ArrayBlockingQueue</code>）：基于锁和等待&#x2F;通知机制。当队列满时写阻塞，空时读阻塞。常用于生产者-消费者模型。</li>
<li><strong>非阻塞队列</strong>（如 <code>ConcurrentLinkedQueue</code>）：基于 <strong>CAS</strong> 机制（无锁），操作立即返回或重试，高并发下性能更好，但 CPU 开销可能较大。</li>
</ul>
<h3 id="21-CAS-的原理及其应用场景"><a href="#21-CAS-的原理及其应用场景" class="headerlink" title="21. CAS 的原理及其应用场景"></a>21. CAS 的原理及其应用场景</h3><ul>
<li><strong>原理</strong>：<strong>Compare And Swap</strong>（比较并交换）。包含三个操作数：内存地址 V、预期原值 A、新值 B。只有当 V&#x3D;&#x3D;A 时，才将 V 更新为 B。</li>
<li><strong>场景</strong>：<code>AtomicInteger</code> 等原子类、自旋锁、并发容器。</li>
</ul>
<h3 id="22-ABA-问题及其解决方法"><a href="#22-ABA-问题及其解决方法" class="headerlink" title="22. ABA 问题及其解决方法"></a>22. ABA 问题及其解决方法</h3><ul>
<li><strong>问题</strong>：值从 A 变为 B 又变回 A，CAS 检查时以为没变，实际中间经历了变化。</li>
<li><strong>解决</strong>：增加<strong>版本号</strong>（<code>AtomicStampedReference</code>），比较时同时比较值和版本号。</li>
</ul>
<h3 id="23-进程级别的锁解决的是什么问题？"><a href="#23-进程级别的锁解决的是什么问题？" class="headerlink" title="23. 进程级别的锁解决的是什么问题？"></a>23. 进程级别的锁解决的是什么问题？</h3><ul>
<li><strong>指代</strong>：<code>synchronized</code> 或 <code>ReentrantLock</code>。</li>
<li><strong>解决</strong>：<strong>单个 JVM 进程内</strong>，多线程访问共享资源的数据一致性问题。</li>
</ul>
<h3 id="24-分布式锁解决的什么问题？"><a href="#24-分布式锁解决的什么问题？" class="headerlink" title="24. 分布式锁解决的什么问题？"></a>24. 分布式锁解决的什么问题？</h3><ul>
<li><strong>解决</strong>：<strong>跨进程&#x2F;跨服务器</strong>（集群环境）下，多个服务同时访问共享资源（如数据库、Redis）的一致性问题。</li>
<li><strong>实现</strong>：Redis (<code>setnx</code> + lua), Zookeeper (临时顺序节点), Redisson。</li>
</ul>
<h3 id="25-MySQL-中-InnoDB-引擎中行级锁的类型"><a href="#25-MySQL-中-InnoDB-引擎中行级锁的类型" class="headerlink" title="25. MySQL 中 InnoDB 引擎中行级锁的类型"></a>25. MySQL 中 InnoDB 引擎中行级锁的类型</h3><ol>
<li><strong>Record Lock</strong>：锁记录本身。</li>
<li><strong>Gap Lock</strong>：间隙锁，锁范围，防止幻读。</li>
<li><strong>Next-Key Lock</strong>：Record + Gap，默认隔离级别（RR）下使用。</li>
</ol>
<h3 id="26-MySQL-中锁和事务是否有相关性？"><a href="#26-MySQL-中锁和事务是否有相关性？" class="headerlink" title="26. MySQL 中锁和事务是否有相关性？"></a>26. MySQL 中锁和事务是否有相关性？</h3><ul>
<li><strong>强相关</strong>。</li>
<li>事务的<strong>隔离性 (Isolation)</strong> 主要就是通过<strong>锁机制</strong>（配合 MVCC）来实现的。事务提交或回滚时才会释放锁。</li>
</ul>
<h3 id="27-死锁是什么？"><a href="#27-死锁是什么？" class="headerlink" title="27. 死锁是什么？"></a>27. 死锁是什么？</h3><ul>
<li><strong>定义</strong>：两个或多个线程互相持有对方需要的资源，并等待对方释放，导致无限期等待。</li>
<li><strong>四个必要条件</strong>：互斥、占有且等待、不可抢占、循环等待。</li>
</ul>
<hr>
<h2 id="🌿-七、-Spring-框架与-AOP"><a href="#🌿-七、-Spring-框架与-AOP" class="headerlink" title="🌿 七、 Spring 框架与 AOP"></a>🌿 七、 Spring 框架与 AOP</h2><h3 id="28-Spring-中-AOP-代理分为几大类和区别？"><a href="#28-Spring-中-AOP-代理分为几大类和区别？" class="headerlink" title="28. Spring 中 AOP 代理分为几大类和区别？"></a>28. Spring 中 AOP 代理分为几大类和区别？</h3><ol>
<li><strong>JDK 动态代理</strong>：基于接口实现，只能代理实现了接口的类。</li>
<li><strong>CGLIB 动态代理</strong>：基于继承实现，通过 ASM 字节码技术生成子类，不能代理 <code>final</code> 类。</li>
</ol>
<ul>
<li><em>注：Spring Boot 2.x 后默认倾向于使用 CGLIB。</em></li>
</ul>
<h3 id="29-自己有没有使用过代理来完成业务开发？"><a href="#29-自己有没有使用过代理来完成业务开发？" class="headerlink" title="29. 自己有没有使用过代理来完成业务开发？"></a>29. 自己有没有使用过代理来完成业务开发？</h3><ul>
<li><strong>回答思路</strong>：除了使用框架特性，自己可能写过：<ul>
<li><strong>拦截器 (Interceptor)</strong> 或 <strong>过滤器 (Filter)</strong>。</li>
<li><strong>自定义注解 + AOP 切面</strong>：用于实现统一日志记录、接口权限校验、全局异常处理、方法耗时统计等。</li>
</ul>
</li>
</ul>
<h3 id="30-Spring-框架里用到-AOP-的地方"><a href="#30-Spring-框架里用到-AOP-的地方" class="headerlink" title="30. Spring 框架里用到 AOP 的地方"></a>30. Spring 框架里用到 AOP 的地方</h3><ul>
<li><strong>声明式事务</strong> (<code>@Transactional</code>)。</li>
<li><strong>Spring Security</strong> (权限控制)。</li>
<li><strong>统一缓存</strong> (<code>@Cacheable</code>)。</li>
<li><strong>统一日志</strong>。</li>
</ul>
<hr>
<h2 id="📈-八、-开放性问题-Personal-Growth"><a href="#📈-八、-开放性问题-Personal-Growth" class="headerlink" title="📈 八、 开放性问题 (Personal Growth)"></a>📈 八、 开放性问题 (Personal Growth)</h2><h3 id="31-平时自身成长通过哪些途径进行学习？"><a href="#31-平时自身成长通过哪些途径进行学习？" class="headerlink" title="31. 平时自身成长通过哪些途径进行学习？"></a>31. 平时自身成长通过哪些途径进行学习？</h3><ul>
<li><strong>官方文档</strong>（最权威）。</li>
<li><strong>技术社区</strong>：掘金、CSDN、StackOverflow、V2EX。</li>
<li><strong>源码阅读</strong>：GitHub 上阅读优秀开源项目（如 Spring, MyBatis, Netty）。</li>
<li><strong>书籍</strong>：《深入理解Java虚拟机》、《Java并发编程实战》、《高性能MySQL》等。</li>
<li><strong>视频课程</strong>：B站、Coursera、极客时间。</li>
</ul>
<h3 id="32-有没有参加过一些开源的社区？"><a href="#32-有没有参加过一些开源的社区？" class="headerlink" title="32. 有没有参加过一些开源的社区？"></a>32. 有没有参加过一些开源的社区？</h3><ul>
<li><strong>诚实作答</strong>。</li>
<li><strong>如果有</strong>：提到具体的 PR (Pull Request) 或 Issue 经历。</li>
<li><strong>如果没有</strong>：可以这样说：“虽然还没有提交过代码，但我经常在 GitHub 上阅读开源项目源码，并关注 Issues 区的讨论，学习开发者解决 bug 和设计架构的思路。”</li>
</ul>
<hr>
<h3 id="💡-复习建议"><a href="#💡-复习建议" class="headerlink" title="💡 复习建议"></a>💡 复习建议</h3><p>面试时不要死记硬背，建议结合<strong>自己的项目经验</strong>，用自己的话把技术原理讲出来。遇到不会的问题（如具体算法细节），可以尝试关联到相关的知识点，或者诚实回答并表示出学习意愿。祝面试顺利！</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/11/29/%E5%85%AB%E8%82%A1%E6%96%B9%E5%90%9101/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/11/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E5%85%B3%E4%BA%8E%E8%A7%86%E9%A2%91%E8%BF%9B%E5%BA%A6%E8%AE%B0%E5%BD%95%E6%96%B9%E9%9D%A2%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86/">
        <h2 class="post-title">微服务教育平台项目关于视频进度记录方面的高并发处理</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/11/29
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <ul>
<li>对查库查表比较频繁的功能接口使用了redis中间件作为缓存，提高性能，防止数据库压力过大宕机以及查询过多速度变慢，影响用户体验。</li>
</ul>
<h4 id="两个功能进行优化"><a href="#两个功能进行优化" class="headerlink" title="两个功能进行优化"></a>两个功能进行优化</h4><ul>
<li><p>1.提交学习视频记录，判断是否是第一次提交</p>
<ul>
<li>大概思路：先去缓存查询是否有该学习记录，如果有直接返回缓存里的学习记录，缓存没有则取数据库进行查询，如果数据库有则返回，并将其写入缓存。不是第一次则返回null，然后新增</li>
</ul>
</li>
<li><p>2.再次提交，判断视频是否第一次学完,是的话更新数据库并清理缓存，不是第一次，将数据写入缓存（不要写入数据库这里，因为业务设定是每15秒来一次视频观看记录提交，高频操作），设定延时队列-阻塞20秒。</p>
<ul>
<li>当用户还在观看视频的时候，15秒就更新一次缓存，所以阻塞队列检测执行的时候与redis数据进行比较是否一致的时候，如果不一致说明还在继续看视频，当停止观看视频后缓存更新数据不变，阻塞队列提交任务发现数据一致时，再将具体数据写入数据库。</li>
</ul>
<p>  用户观看视频（每15秒上报进度）<br>  ↓</p>
</li>
</ul>
<p>LearningRecordServiceImpl.addVideoRecord()<br>    ↓<br>┌─────────────────────────────────────┐<br>│  1. readCacheRecord()               │ ← Redis Hash 读取<br>│     - 缓存命中 → 直接返回           │<br>│     - 缓存未命中 → 查DB → 写缓存    │<br>└─────────────────────────────────────┘<br>    ↓<br>┌─────────────────────────────────────┐<br>│  2. addLearningRecordTask()         │<br>│     - writeRecordToRedis()          │ ← 更新Redis缓存<br>│     - queue.put(DelayTask)          │ ← 提交延时队列（20秒）<br>└─────────────────────────────────────┘<br>    ↓<br>┌─────────────────────────────────────┐<br>│  3. handleRecordTask() [异步线程]    │<br>│     - queue.take() [阻塞等待]       │ ← DelayQueue 延时队列<br>│     - 比较缓存与队列数据            │<br>│     - 一致 → 写入数据库              │<br>│     - 不一致 → 跳过（用户仍在观看）  │<br>└─────────────────────────────────────┘<br>    ↓<br>┌─────────────────────────────────────┐<br>│  4. cleanCacheRecord()              │ ← 视频完成时清理缓存<br>│     - 数据库已更新                   │<br>│     - 删除Redis缓存                  │<br>└─────────────────────────────────────┘</p>
<h4 id="对延时队列工具类的封装–原理"><a href="#对延时队列工具类的封装–原理" class="headerlink" title="对延时队列工具类的封装–原理"></a>对延时队列工具类的封装–原理</h4><ul>
<li><p>@PostConstruct + CompletableFuture.runAsync(this::handleRecordTask)来启动处理队列这个线程</p>
<ul>
<li>放在 @PostConstruct 里：保证此时 redisTemplate、recordMapper、lessonMapper 等依赖已经通过构造函数注入完毕，Bean 是一个“准备就绪”的单例。pring 容器启动完成时自动调用一次 init()，不会重复启动多个处理线程。</li>
<li>CompletableFuture.runAsync(this::handleRecordTask) ，因为while(true)是个死循环， while (begin) + queue.take() 阻塞，如果直接在主线程或 Web 请求线程里调用，会把线程卡死。runAsync 会把 handleRecordTask() 丢到线程池里的后台线程去跑，不阻塞 Spring 容器启动线程，也不阻塞任何请求线程。</li>
</ul>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/11/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E5%85%B3%E4%BA%8E%E8%A7%86%E9%A2%91%E8%BF%9B%E5%BA%A6%E8%AE%B0%E5%BD%95%E6%96%B9%E9%9D%A2%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/11/25/Gemini3%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%EF%BC%9A%E4%B8%80%E4%BA%9B%E9%A1%B9%E7%9B%AE%E7%9A%84idea/">
        <h2 class="post-title">Gemini3使用体验：对应电商项目的些许idea</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/11/25
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="回答背景："><a href="#回答背景：" class="headerlink" title="回答背景："></a>回答背景：</h4><ul>
<li><p>1.mcp+llm+rag一个项目 根据用户在一个商场购买的课程的 根据用户的各类信息结合他的购买习惯 学习课程的哪个更久一些 他的学习计划习惯  能够有一些推荐课程和总结建议的助手 我商场项目是Java springcloud那一套生态 mcp+llm+rag 用Python吧  告诉我实现流程和思路落地 根据用户在一个商场购买的课程的 根据用户的各类信息结合他的购买习惯 学习课程的哪个更久一些 他的学习计划习惯  能够有一些推荐课程和总结建议的助手 </p>
</li>
<li><p>2.详细说一下python侧的技术栈 3.两个疑问： 一 langchain和langgraph应用在mcpserver封装当中吗 rag知识库构建有没有应用到  二 rag知识库存储的信息主要是什么 当用户个人信息携带请求打过来 会实时更新rag吗 如果rag是之前预热存储了许多课程信息 </p>
</li>
<li><p>3.那么第一次rag知识库为空 java侧应用启动了 python侧启动 设计自动（无需用户或者管理员交互）自动将对应数据库的课表库以及其他预热数据传入rag知识库当中</p>
</li>
</ul>
<h4 id="Gemini3Pro的回答"><a href="#Gemini3Pro的回答" class="headerlink" title="Gemini3Pro的回答"></a>Gemini3Pro的回答</h4><h4 id="项目架构笔记：个性化课程推荐助手-MCP-LLM-RAG"><a href="#项目架构笔记：个性化课程推荐助手-MCP-LLM-RAG" class="headerlink" title="项目架构笔记：个性化课程推荐助手 (MCP + LLM + RAG)"></a>项目架构笔记：个性化课程推荐助手 (MCP + LLM + RAG)</h4><h4 id="1-项目背景与核心理念"><a href="#1-项目背景与核心理念" class="headerlink" title="1. 项目背景与核心理念"></a>1. 项目背景与核心理念</h4><ul>
<li><strong>目标：</strong> 构建一个智能助手，能够根据用户在商场（Java侧）的购买记录、学习时长、学习习惯等数据，结合课程内容库，提供个性化的课程推荐和学习建议。</li>
<li><strong>角色分工：</strong><ul>
<li><strong>Java (Spring Cloud)：</strong> <strong>业务中台</strong>。负责存储核心业务数据（用户、订单、日志）、提供原子API能力。</li>
<li><strong>Python (MCP + AI)：</strong> <strong>智能大脑</strong>。负责语义理解、逻辑编排、RAG检索、以及通过MCP协议调用Java侧数据。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-业务实现流程与落地思路"><a href="#2-业务实现流程与落地思路" class="headerlink" title="2. 业务实现流程与落地思路"></a>2. 业务实现流程与落地思路</h4><h5 id="2-1-核心架构逻辑"><a href="#2-1-核心架构逻辑" class="headerlink" title="2.1 核心架构逻辑"></a>2.1 核心架构逻辑</h5><ul>
<li>用户提问 -&gt; <strong>Python Agent (大脑)</strong> -&gt; <strong>拆解任务</strong> -&gt; <strong>并发&#x2F;顺序调用数据源</strong> -&gt; <strong>汇总推理</strong> -&gt; 返回建议。</li>
</ul>
<h5 id="2-2-详细交互步骤-Step-by-Step"><a href="#2-2-详细交互步骤-Step-by-Step" class="headerlink" title="2.2 详细交互步骤 (Step-by-Step)"></a>2.2 详细交互步骤 (Step-by-Step)</h5><ol>
<li><p><strong>用户发起请求</strong></p>
<ul>
<li>前端携带 <code>userId</code> 和自然语言问题（例如：“我学Java多线程很吃力，接下来咋办？”）请求 Python 服务。</li>
</ul>
</li>
<li><p><strong>Agent 规划 (LLM)</strong></p>
<ul>
<li>Python端的 LLM 接收请求，分析出需要获取两类信息：<ul>
<li><strong>用户信息：</strong> 确认用户买了什么课、哪里学得久、哪里卡住了。</li>
<li><strong>课程知识：</strong> 寻找能解决“多线程吃力”的课程资料。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>获取用户画像 (动态数据 - Tool Call)</strong></p>
<ul>
<li><strong>动作：</strong> Agent 调用 MCP 工具 <code>get_user_learning_profile(userId)</code>。</li>
<li><strong>实现：</strong> Python MCP Client 发送 HTTP 请求 $\rightarrow$ Java Spring Cloud 接口。</li>
<li><strong>返回结果：</strong> 结构化 JSON（如：<code>&#123;&quot;购买&quot;: &quot;Java高并发&quot;, &quot;多线程章节停留&quot;: &quot;5小时(异常)&quot;, &quot;习惯&quot;: &quot;晚间学习&quot;&#125;</code>）。</li>
<li><em>注意：此类数据实时性强，不走RAG，走API直连。</em></li>
</ul>
</li>
<li><p><strong>检索课程方案 (静态数据 - RAG)</strong></p>
<ul>
<li><strong>动作：</strong> Agent 根据痛点“Java多线程”，在 Python 内部查询向量数据库。</li>
<li><strong>实现：</strong> RAG 检索课程库。</li>
<li><strong>返回结果：</strong> 课程大纲片段（如：《Java基础进阶-线程篇》简介、目录）。</li>
</ul>
</li>
<li><p><strong>生成建议 (LLM Synthesis)</strong></p>
<ul>
<li><strong>输入：</strong> 用户画像 JSON + RAG 检索到的课程资料。</li>
<li><strong>Prompt 策略：</strong> “用户A在[画像数据]中显示遇到困难，请根据[课程资料]为他制定计划。”</li>
<li><strong>输出：</strong> 最终建议文本。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-Python-侧详细技术栈"><a href="#3-Python-侧详细技术栈" class="headerlink" title="3. Python 侧详细技术栈"></a>3. Python 侧详细技术栈</h4><table>
<thead>
<tr>
<th align="left">模块</th>
<th align="left">推荐技术&#x2F;库</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Web 框架</strong></td>
<td align="left"><strong>FastAPI</strong></td>
<td align="left">高性能，原生支持异步，适合做 AI 服务网关。</td>
</tr>
<tr>
<td align="left"><strong>MCP 协议</strong></td>
<td align="left"><strong>mcp (Python SDK)</strong></td>
<td align="left">Anthropic 官方 SDK，用于封装 Tools 和 Resources。</td>
</tr>
<tr>
<td align="left"><strong>Agent 编排</strong></td>
<td align="left"><strong>LangGraph</strong></td>
<td align="left"><strong>强烈推荐</strong>。相比 LangChain 更适合处理有状态、多步循环的复杂逻辑（如：先查用户，不够再查课，再反思）。</td>
</tr>
<tr>
<td align="left"><strong>LLM 接口</strong></td>
<td align="left"><strong>LangChain &#x2F; OpenAI SDK</strong></td>
<td align="left">对接 GPT-4, DeepSeek, Claude 等大模型。</td>
</tr>
<tr>
<td align="left"><strong>向量数据库</strong></td>
<td align="left"><strong>ChromaDB</strong> (轻量) <br> <strong>Milvus</strong> (生产级)</td>
<td align="left">ChromaDB 适合快速开发和中小规模；Milvus 适合海量数据。</td>
</tr>
<tr>
<td align="left"><strong>Embedding</strong></td>
<td align="left"><strong>Sentence-Transformers</strong></td>
<td align="left">推荐 <code>bge-m3</code> 或 <code>m3e-base</code> 等中文效果好的嵌入模型。</td>
</tr>
<tr>
<td align="left"><strong>数据处理</strong></td>
<td align="left"><strong>Pandas</strong></td>
<td align="left">用于处理从 Java 端拉取的大批量数据（ETL）。</td>
</tr>
</tbody></table>
<hr>
<h4 id="4-核心疑问解答-Q-A"><a href="#4-核心疑问解答-Q-A" class="headerlink" title="4. 核心疑问解答 (Q&amp;A)"></a>4. 核心疑问解答 (Q&amp;A)</h4><h5 id="Q1-LangChain-LangGraph-和-RAG-在-MCP-Server-中如何定位？"><a href="#Q1-LangChain-LangGraph-和-RAG-在-MCP-Server-中如何定位？" class="headerlink" title="Q1: LangChain&#x2F;LangGraph 和 RAG 在 MCP Server 中如何定位？"></a>Q1: LangChain&#x2F;LangGraph 和 RAG 在 MCP Server 中如何定位？</h5><ul>
<li><strong>定位：</strong> 它们是 MCP Server 内部的<strong>实现逻辑</strong>。</li>
<li><strong>LangGraph：</strong> 是“脑子”。当 MCP Server 接收到请求时，是 LangGraph 在控制流程（是先去查库，还是先去调 API）。</li>
<li><strong>RAG：</strong> 是 MCP Server 内部的一个“私有工具”。可以将其封装为一个内部函数，供 Agent 在思考时随时调用。</li>
</ul>
<h5 id="Q2-RAG-知识库存储什么？是否需要实时更新？"><a href="#Q2-RAG-知识库存储什么？是否需要实时更新？" class="headerlink" title="Q2: RAG 知识库存储什么？是否需要实时更新？"></a>Q2: RAG 知识库存储什么？是否需要实时更新？</h5><ul>
<li><strong>存什么（慢数据）：</strong><ul>
<li>课程详情（标题、简介、大纲、讲师信息）。</li>
<li>通用学习路线图、学科知识点关联。</li>
<li><em>切记：不要存用户的实时日志（如购买记录），这些数据变化太快，向量化成本高，应该用 API 实时获取。</em></li>
</ul>
</li>
<li><strong>更新频率：</strong><ul>
<li><strong>不需要</strong>用户请求时实时更新。</li>
<li>仅当 Java 端上架新课程或修改课程大纲时，才触发更新（通常是 T+1 或管理员手动触发，或如下文的自动同步）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-自动化数据预热方案-Cold-Start"><a href="#5-自动化数据预热方案-Cold-Start" class="headerlink" title="5. 自动化数据预热方案 (Cold Start)"></a>5. 自动化数据预热方案 (Cold Start)</h4><p><strong>场景：</strong> Java 端已启动，Python 端第一次启动，RAG 库为空。如何自动同步数据？</p>
<h5 id="5-1-设计思路"><a href="#5-1-设计思路" class="headerlink" title="5.1 设计思路"></a>5.1 设计思路</h5><p>利用 Python 应用的<strong>生命周期钩子 (Lifecycle Hooks)</strong>，在服务启动但在接收流量之前，主动向 Java 端拉取数据。</p>
<h5 id="5-2-详细流程"><a href="#5-2-详细流程" class="headerlink" title="5.2 详细流程"></a>5.2 详细流程</h5><ol>
<li><strong>Java 端准备：</strong> 提供全量课程导出接口（如 <code>GET /api/internal/courses/export</code>）。</li>
<li><strong>Python 端启动自检：</strong><ul>
<li>应用启动 (<code>startup</code> 事件)。</li>
<li>检查向量数据库 (<code>VectorDB.count()</code>)。</li>
</ul>
</li>
<li><strong>判断逻辑：</strong><ul>
<li><strong>若 Count &#x3D;&#x3D; 0 (空库)：</strong> 进入全量同步模式。<ul>
<li>Call Java 接口拉取所有课程 JSON。</li>
<li>文本清洗与拼接 (Title + Desc + Syllabus)。</li>
<li>Embedding 向量化。</li>
<li>批量写入向量库 (Bulk Insert)。</li>
</ul>
</li>
<li><strong>若 Count &gt; 0 (非空)：</strong> 跳过或执行增量检查（对比 ID）。</li>
</ul>
</li>
<li><strong>服务就绪：</strong> 数据加载完毕后，FastAPI 开始监听端口，对外提供服务。</li>
</ol>
<h5 id="5-3-伪代码参考-FastAPI"><a href="#5-3-伪代码参考-FastAPI" class="headerlink" title="5.3 伪代码参考 (FastAPI)"></a>5.3 伪代码参考 (FastAPI)</h5><pre><code class="language-python">#### main.py 相关的伪代码思路

	from fastapi import FastAPI
	from contextlib import asynccontextmanager
	import requests

	# 模拟向量数据库的客户端
	vector_db = ChromaDBClient() 

	@asynccontextmanager
	async def lifespan(app: FastAPI):
    # --- [启动阶段] ---
    print(&quot;&gt;&gt;&gt; Python AI服务启动，开始自检...&quot;)
    
    current_count = vector_db.count()
    if current_count == 0:
        print(f&quot;&gt;&gt;&gt; 检测到知识库为空，开始从 Java 端同步数据...&quot;)
        
        # 1. 调 Java 接口获取数据
        try:
            # 假设 Java 服务名为 java-mall-service
            response = requests.get(&quot;http://java-mall-service/api/internal/export/courses&quot;)
            courses_data = response.json()
            
            # 2. 处理并存入 RAG
            documents = []
            for course in courses_data:
                # 拼接为适合检索的文本
                text = f&quot;课程名：&#123;course[&#39;name&#39;]&#125;\\n简介：&#123;course[&#39;description&#39;]&#125;\\n目录：&#123;course[&#39;catalog&#39;]&#125;&quot;
                documents.append(text)
            
            # 3. 写入数据库
            vector_db.add_documents(documents)
            print(f&quot;&gt;&gt;&gt; 预热完成！共导入 &#123;len(documents)&#125; 门课程数据。&quot;)
            
        except Exception as e:
            print(f&quot;&gt;&gt;&gt; 警告：数据同步失败，原因：&#123;e&#125;&quot;)
    else:
        print(f&quot;&gt;&gt;&gt; 知识库状态正常，包含 &#123;current_count&#125; 条数据。&quot;)

    yield # 服务正式运行
    
    # --- [关闭阶段] ---
    print(&quot;&gt;&gt;&gt; 服务关闭&quot;)
	app = FastAPI(lifespan=lifespan)
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/11/25/Gemini3%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%EF%BC%9A%E4%B8%80%E4%BA%9B%E9%A1%B9%E7%9B%AE%E7%9A%84idea/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/10/19/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9301%EF%BC%9A%E7%BA%B7%E4%BA%AB%E9%94%80%E5%AE%A2%E4%B8%80%E9%9D%A2/">
        <h2 class="post-title">面试总结01：纷享销客一面</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/10/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>采用的线上腾讯会议电话面，面试了大概十多分钟吧，这是本人第二次参加java开发实习岗的日常实习面试，仍对整套八股文体系知识细节的了解有所欠缺，估计是挂了（（ </p>
<h4 id="面试内容"><a href="#面试内容" class="headerlink" title="面试内容"></a>面试内容</h4><h5 id="1-HashMap的具体实现（采用了什么数据结构，原理等），JDK源码思路"><a href="#1-HashMap的具体实现（采用了什么数据结构，原理等），JDK源码思路" class="headerlink" title="1.HashMap的具体实现（采用了什么数据结构，原理等），JDK源码思路"></a>1.HashMap的具体实现（采用了什么数据结构，原理等），JDK源码思路</h5><ul>
<li><p><strong>JDK1.7</strong>:采用<strong>数组+链表</strong>的数据结构，通过哈希算法将新增的元素映射到数组的槽位当中（bucket）,若有哈希冲突产生（即hash()值相同）则通过链表这一数据结构解决在同一槽位的元素，因为链表的查询性能是O（n），所以查询效率比较低。</p>
</li>
<li><p><strong>JDK1.8</strong>:采用<strong>数组+链表+红黑树</strong>的数据结构，因为声明一个HashMap&lt;&gt;()时初始值是16（这时候是数组+链表的数据结构），当插入的数据超过设置的负载因子（默认是0.75，定义是存放元素个数占总元素个数的比重）会进行扩容机制，当链表长度超过8个，数组长度超过64个这两个条件同时满足，则会采用红黑树来存储数组上同一槽位的元素，使用红黑树的时间复杂度是O（log n）。</p>
</li>
<li><p><strong>扩展：HashMap的扩容机制</strong></p>
<ul>
<li><p>hashMap默认的负载因子是0.75，即如果hashmap中的元素个数超过了总容量75%，则会触发扩容机制。第一步，<strong>将哈希表（数组）长度扩大到原来的两倍得到新的哈希表</strong>，第二步，<strong>将原哈希表的数据迁移到新的哈希表</strong>。</p>
</li>
<li><p><strong>JDK1.7和JDK1.8之间扩容原理的区别</strong>：</p>
</li>
<li><p>在 JDK1.7 中，HashMap 整个扩容过程就是分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，，依据每个被遍历元素的 hash 值（%新的长度，例如16扩大到32，则进行和32的取模运算得到的哈希值）计算其在新数组中的下标，然后进行交换。这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。</p>
</li>
<li><p>而在 JDK 1.8 中，HashMap 对扩容操作做了优化。利用高低位运算进行判断，如果判断是高位运算则移动到新的哈希值位置，低位则保持原来相对位置不变，大大提升了扩容的性能，然后采用的是尾插法，之所以能通过这种“与运算“来重新分配索引，是因为 hash 值本来就是随机的，而 hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处）就是随机的，所以扩容的过程就能把之前哈希冲突的元素再随机分布到不同的索引中去。</p>
</li>
</ul>
</li>
</ul>
<h5 id="2-线程池的参数有哪些"><a href="#2-线程池的参数有哪些" class="headerlink" title="2.线程池的参数有哪些"></a>2.线程池的参数有哪些</h5><ul>
<li><p><strong>corePoolSize</strong>:线程池核心线程数量。默认情况下，线程池中线程的数量如果 &lt;&#x3D; corePoolSize，那么即使这些线程处于空闲状态，那也不会被销毁。</p>
</li>
<li><p><strong>maxmiumPoolSize</strong>:限制了线程池能创建的<strong>最大线程总数</strong>（包括核心线程和非核心线程），当 corePoolSize 已满并且尝试将新任务加入阻塞队列失败（即队列已满）并且 当前线程数 &lt; maximumPoolSize，就会创建新线程执行此任务，但是当 corePoolSize 满 并且 队列满 并且线程数已达 maximumPoolSize并且 又有新任务提交时，就会触发拒绝策略。</p>
</li>
<li><p><strong>keepAliveTime</strong>:当线程池中线程的数量大于corePoolSize，并且某个线程的空闲时间超过keepAliveTime，那么这个线程就会被销毁。</p>
</li>
<li><p><strong>unit</strong>:就是keepAliveTime时间的单位。</p>
</li>
<li><p><strong>workQueue</strong>:工作队列。当没有空闲的线程执行新任务时，该任务就会被放入工作队列中，等待执行。</p>
</li>
<li><p><strong>threadFactory</strong>:线程工厂。可以用来给线程取名字等等</p>
</li>
<li><p><strong>handler</strong>:拒绝策略。当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，如果没有空闲的线程，就会将该任务加入到阻塞队列中，如果阻塞队列满了，就会创建一个新线程，从阻塞队列头部取出一个任务来执行，并将新任务加入到阻塞队列末尾。如果当前线程池中线程的数量等于maximumPoolSize，就不会创建新线程，就会去执行拒绝策略。</p>
</li>
</ul>
<h5 id="3-实战当中如何开启一个新的线程，代码细节"><a href="#3-实战当中如何开启一个新的线程，代码细节" class="headerlink" title="3.实战当中如何开启一个新的线程，代码细节"></a>3.实战当中如何开启一个新的线程，代码细节</h5><h5 id="4-具体讲讲Spring当中AOP的底层"><a href="#4-具体讲讲Spring当中AOP的底层" class="headerlink" title="4.具体讲讲Spring当中AOP的底层"></a>4.具体讲讲Spring当中AOP的底层</h5><ul>
<li>Spring AOP的实现依赖于**动态代理技术。**动态代理是在运行时动态生成代理对象，而不是在编译时。它允许开发者在运行时指定要代理的接口和行为，从而实现在不修改源码的情况下增强方法的功能。主要用于在不修改原始类的情况下对方法调用进行拦截和增强。<ul>
<li><p><strong>基于接口的代理</strong>（JDK动态代理）： 这种类型的代理要求目标对象必须实现至少一个接口。Java动态代理会创建一个实现了相同接口的代理类，然后在运行时动态生成该类的实例。这种代理的实现核心是java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口。每一个动态代理类都必须实现InvocationHandler接口，并且每个代理类的实例都关联到一个handler。当通过代理对象调用一个方法时，这个方法的调用会被转发为由InvocationHandler接口的invoke()方法来进行调用。</p>
</li>
<li><p><strong>基于类的代理</strong>（CGLIB动态代理）： CGLIB（Code Generation Library）是一个强大的高性能的代码生成库，它可以在运行时动态生成一个目标类的子类。CGLIB代理不需要目标类实现接口，而是通过继承的方式创建代理类。因此，如果目标对象没有实现任何接口，可以使用CGLIB来创建动态代理。</p>
</li>
</ul>
</li>
</ul>
<h5 id="5-bean的生命周期"><a href="#5-bean的生命周期" class="headerlink" title="5.bean的生命周期"></a>5.bean的生命周期</h5><ul>
<li><p>1.Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</p>
</li>
<li><p>2.Bean实例化后对将Bean的引入和值注入到Bean的属性中</p>
</li>
<li><p>3.如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</p>
</li>
<li><p>4.如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</p>
</li>
<li><p>5.如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</p>
</li>
<li><p>6.如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</p>
</li>
<li><p>7如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</p>
</li>
<li><p>8.如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</p>
</li>
<li><p>9.此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</p>
</li>
<li><p>10.如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</p>
</li>
</ul>
<h5 id="6-spring是怎么解决循环依赖的"><a href="#6-spring是怎么解决循环依赖的" class="headerlink" title="6.spring是怎么解决循环依赖的"></a>6.spring是怎么解决循环依赖的</h5><ul>
<li><p>循环依赖指的是两个类中的属性相互依赖对方：例如 A 类中有 B 属性，B 类中有 A属性，从而形成依赖闭环</p>
</li>
<li><p>循环依赖问题在Spring中主要有三种情况：</p>
<ul>
<li><p>第一种：通过构造方法进行依赖注入时产生的循环依赖问题</p>
</li>
<li><p>第二种：通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题</p>
</li>
<li><p>第三种：通过setter方法进行依赖注入在单例模式下产生的循环依赖问题</p>
</li>
<li><p>只有【第三种方式】的循环依赖问题被 Spring 解决了，其他两种方式在遇到循环依赖问题时，Spring都会抛出异常</p>
</li>
</ul>
</li>
<li><p>Spring通过三级缓存机制来解决，在DefaultSingletonBeanRegistry 类中维护了三个重要的缓存 (Map)：</p>
<ul>
<li><p>singletonObjects (一级缓存)：存放的是完全初始化好的、可用的 Bean 实例，getBean() 方法最终返回的就是这里面的 Bean。此时 Bean 已实例化、属性已填充、初始化方法已执行、AOP 代理（如果需要）也已生成。</p>
</li>
<li><p>earlySingletonObjects (二级缓存)：存放的是提前暴露的 Bean 的原始对象引用或早期代理对象引用，专门用来处理循环依赖。当一个 Bean 还在创建过程中（尚未完成属性填充和初始化），但它的引用需要被注入到另一个 Bean 时，此时 Bean 已实例化（调用了构造函数），但属性尚未填充，初始化方法尚未执行，它可能是一个原始对象，也可能是一个为了解决 AOP 代理问题而提前生成的代理对象。</p>
</li>
<li><p>singletonFactories (三级缓存)：存放的是 Bean 的 ObjectFactory 工厂对象。这是解决循环依赖和 AOP 代理协同工作的关键。当 Bean 被实例化后（刚调完构造函数），Spring 会创建一个 ObjectFactory 并将其放入三级缓存。这个工厂的 getObject() 方法负责返回该 Bean 的早期引用（可能是原始对象，也可能是提前生成的代理对象），当检测到循环依赖需要注入一个尚未完全初始化的 Bean 时，就会调用这个工厂来获取早期引用。</p>
</li>
<li><p>Spring 通过<strong>三级缓存</strong>和<strong>提前暴露未完全初始化的对象引用</strong>的机制来解决单例作用域 Bean 的 sette注入方式的循环依赖问题。</p>
</li>
</ul>
</li>
<li><p>Spring三级缓存机制的详细步骤</p>
<ul>
<li><p>第一步：<strong>创建BeanA的实例并提前暴露工厂</strong>。Spring首先调用BeanA的构造函数进行实例化，此时得到一个原始对象（尚未填充属性）。紧接着，Spring会将一个特殊的ObjectFactory工厂对象存入第三级缓存（singletonFactories）。    这个工厂的使命是：当其他Bean需要引用BeanA时，它能动态返回当前这个半成品的BeanA（可能是原始对象，也可能是为应对AOP而提前生成的代理对象）。此时BeanA的状态是”已实例化但未初始化”，像一座刚搭好钢筋骨架的大楼。</p>
</li>
<li><p>第二步：<strong>填充BeanA的属性时触发BeanB的创建</strong>。Spring开始为BeanA注入属性，发现它依赖BeanB。于是容器转向创建BeanB，同样先调用其构造函数实例化，并将BeanB对应的ObjectFactory工厂存入三级缓存。至此，三级缓存中同时存在BeanA和BeanB的工厂，它们都代表未完成初始化的半成品。</p>
</li>
<li><p>第三步：<strong>BeanB属性注入时发现循环依赖</strong>。当Spring试图填充BeanB的属性时，检测到它需要注入BeanA。此时容器启动依赖查找：</p>
<ul>
<li>1.在一级缓存（存放完整Bean）中未找到BeanA；</li>
</ul>
</li>
<li><p>2.在二级缓存（存放已暴露的早期引用）中同样未命中；</p>
</li>
<li><p>3.最终在三级缓存中定位到BeanA的工厂。</p>
</li>
<li><p>Spring立即调用该工厂的getObject()方法。这个方法会执行关键决策：若BeanA需要AOP代理，则动态生成代理对象（即使BeanA还未初始化）；若无需代理，则直接返回原始对象。得到的这个早期引用（可能是代理）被放入二级缓存（earlySingletonObjects），同时从三级缓存清理工厂条目。最后，Spring将这个早期引用注入到BeanB的属性中。至此，BeanB成功持有BeanA的引用–尽管BeanA此时仍是个半成品。</p>
</li>
<li><p>第四步：<strong>完成BeanB的生命周期</strong>。BeanB获得所有依赖后，Spring执行其初始化方法（如@PostConstruct），将其转化为完整可用的Bean。随后，BeanB被提升至一级缓存（singletonObjects），二级和三级缓存中关于BeanB的临时条目均被清除。此时BeanB已准备就绪，可被其他对象使用。</p>
</li>
<li><p>第五步：<strong>回溯完成BeanA的构建</strong>。随着BeanB创建完毕，流程回溯到最初中断的BeanA属性注入环节。Spring将已完备的BeanB实例注入BeanA，接着执行BeanA的初始化方法。这里有个精妙细节：若之前为BeanA生成过早期代理，Spring会直接复用二级缓存中的代理对象作为最终Bean，而非重复构建。最终，完全初始化的BeanA（可能是原始对象或代理）入驻一级缓存，其早期引用从二级缓存当中移除。至此循环闭环完成，两个Bean皆可用。</p>
</li>
</ul>
</li>
<li><p>三级缓存的设计的精髓：</p>
<ul>
<li>三级缓存工厂（singletonFactories）负责实例化后立刻暴露对象生成能力，兼顾AOP代理的提前生成；</li>
</ul>
</li>
<li><p>二级缓存（earlySingletonObjects）临时存储已确定的早期引用，避免重复生成代理；</p>
</li>
<li><p>一级缓存（singletonObjects）最终交付完整Bean。</p>
</li>
<li><p>整个机制通过中断<strong>初始化流程</strong>、<strong>逆向注入半成品</strong>、<strong>延迟代理生成</strong>三大策略，将循环依赖的死结转化为有序的接力协作。值得注意的是，此方案仅适用于Setter&#x2F;Field注入的单例Bean；构造器注入因必须在实例化前获得依赖，仍会导致无解的死锁。</p>
</li>
</ul>
<h5 id="7-采用spring当中构造函数方法注入，会产生循环依赖吗"><a href="#7-采用spring当中构造函数方法注入，会产生循环依赖吗" class="headerlink" title="7.采用spring当中构造函数方法注入，会产生循环依赖吗"></a>7.采用spring当中构造函数方法注入，会产生循环依赖吗</h5><ul>
<li>根据上面回答，会。</li>
</ul>
<h5 id="8-计算机网络模型有哪几层，TCP是哪一层，IP是哪一层"><a href="#8-计算机网络模型有哪几层，TCP是哪一层，IP是哪一层" class="headerlink" title="8.计算机网络模型有哪几层，TCP是哪一层，IP是哪一层"></a>8.计算机网络模型有哪几层，TCP是哪一层，IP是哪一层</h5><ul>
<li>五层：应用层–运输层–网络层–数据链路层–物理层，TCP协议是运输层，IP是网络层</li>
</ul>
<h5 id="9-详细介绍一下TCP三次握手"><a href="#9-详细介绍一下TCP三次握手" class="headerlink" title="9.详细介绍一下TCP三次握手"></a>9.详细介绍一下TCP三次握手</h5><ul>
<li><p>TCP是面向连接的协议，是遵循可靠运输这一特性的。所以使用 TCP 前必须先建立连接，而建立连接是通过三次握手来进行的</p>
</li>
<li><p>一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态</p>
</li>
<li><p>客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。</p>
</li>
<li><p>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。</p>
</li>
<li><p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。</p>
</li>
<li><p>服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。</p>
</li>
<li><p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，一旦完成三次握手，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
</li>
</ul>
<h5 id="10-那TCP四次握手呢"><a href="#10-那TCP四次握手呢" class="headerlink" title="10.那TCP四次握手呢"></a>10.那TCP四次握手呢</h5><ul>
<li><p>TCP断开连接的过程是通过<strong>四次挥手</strong>的方式，双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</p>
</li>
<li><p>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</p>
</li>
<li><p>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSE_WAIT 状态。</p>
</li>
<li><p>客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。</p>
</li>
<li><p>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</p>
</li>
<li><p>客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态</p>
</li>
<li><p>服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。</p>
</li>
<li><p>客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。</p>
</li>
<li><p>你可以看到，每个方向都需要<strong>一个 FIN</strong> 和<strong>一个 ACK</strong>，因此通常被称为四次挥手。这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态</strong>。</p>
</li>
</ul>
<h4 id="反问环节"><a href="#反问环节" class="headerlink" title="反问环节"></a>反问环节</h4><h5 id="1-通过这次面试，能否给我一些建议"><a href="#1-通过这次面试，能否给我一些建议" class="headerlink" title="1.通过这次面试，能否给我一些建议"></a>1.通过这次面试，能否给我一些建议</h5><ul>
<li>对于java一整套生态，不仅要会用这些工具，还要懂得其中的原理</li>
</ul>
<h5 id="2-你们公司是做什么业务的"><a href="#2-你们公司是做什么业务的" class="headerlink" title="2.你们公司是做什么业务的"></a>2.你们公司是做什么业务的</h5><ul>
<li>我们公司做crm系统的，我所在的组是营销组，平时你在网上看到那些广告类似招聘，都是我们业务相关的</li>
</ul>
<p> 总结一下，只能答出来一半多点，还是对其中细节记忆太少了，只能记得大概和关键字，面试官一旦追究里面的细节立马哑口无言</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2025/10/19/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9301%EF%BC%9A%E7%BA%B7%E4%BA%AB%E9%94%80%E5%AE%A2%E4%B8%80%E9%9D%A2/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    <a class="page-num" href="/page/2">
        2
    </a>
    
    
    <a class="page-num" href="/page/3">
        3
    </a>
    
    
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">David Huang</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 UNCEIR的个人博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;David Huang
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
