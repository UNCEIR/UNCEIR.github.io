
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>八股训练01 | UNCEIR的个人博客</title>
    <meta name="author" content="David Huang" />
    <meta name="description" content="广东工业大学信息管理与信息系统专业的一名大三学生，未来想从事后端开发，请多指教。" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>UNCEIR的个人博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;UNCEIR的个人博客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>八股训练01</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/11/29
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <hr>
<h1 id="☕-Java-后端经典面试题库-32题详解"><a href="#☕-Java-后端经典面试题库-32题详解" class="headerlink" title="☕ Java 后端经典面试题库 (32题详解)"></a>☕ Java 后端经典面试题库 (32题详解)</h1><p>这份题库涵盖了 Java 基础、集合框架、并发编程、JVM、数据库、中间件、Spring 框架以及个人成长等核心领域，适合面试前的查漏补缺和系统复习。</p>
<h2 id="📌-一、-Java-基础与面向对象"><a href="#📌-一、-Java-基础与面向对象" class="headerlink" title="📌 一、 Java 基础与面向对象"></a>📌 一、 Java 基础与面向对象</h2><h3 id="1-对-Java-面向对象怎么理解的？"><a href="#1-对-Java-面向对象怎么理解的？" class="headerlink" title="1. 对 Java 面向对象怎么理解的？"></a>1. 对 Java 面向对象怎么理解的？</h3><ul>
<li><strong>核心思想</strong>：将现实世界的事物抽象为“对象”，重点在于通过对象之间的<strong>交互</strong>来解决问题。</li>
<li><strong>对比面向过程</strong>：<ul>
<li>面向过程（如 C 语言）侧重于“步骤”和函数调用。</li>
<li>面向对象侧重于“谁来做”以及对象间的职责分配。</li>
</ul>
</li>
<li><strong>优势</strong>：代码复用性高、易维护、易扩展、低耦合。</li>
</ul>
<h3 id="2-Java-面向对象的特性有哪些？"><a href="#2-Java-面向对象的特性有哪些？" class="headerlink" title="2. Java 面向对象的特性有哪些？"></a>2. Java 面向对象的特性有哪些？</h3><ol>
<li><strong>封装 (Encapsulation)</strong>：隐藏对象的属性和实现细节，仅对外公开接口，提高安全性。</li>
<li><strong>继承 (Inheritance)</strong>：子类继承父类的特征和行为，实现代码复用。</li>
<li><strong>多态 (Polymorphism)</strong>：同一个接口，使用不同的实例而执行不同操作（实现条件：继承、重写、父类引用指向子类对象）。</li>
<li><em>(补充)</em> <strong>抽象 (Abstraction)</strong>：提取事物的共性，忽略细节。</li>
</ol>
<h3 id="3-String-类可以被继承吗？"><a href="#3-String-类可以被继承吗？" class="headerlink" title="3. String 类可以被继承吗？"></a>3. String 类可以被继承吗？</h3><ul>
<li><strong>回答</strong>：不能。</li>
<li><strong>原因</strong>：String 类被 <code>final</code> 关键字修饰。</li>
<li><strong>设计目的</strong>：<ol>
<li><strong>安全</strong>：防止核心类被恶意篡改（如数据库连接串、类加载机制）。</li>
<li><strong>效率</strong>：配合字符串常量池（String Pool），只有不可变才能实现池化。</li>
<li><strong>线程安全</strong>：不可变对象天生是线程安全的。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="📂-二、-集合框架-Collections"><a href="#📂-二、-集合框架-Collections" class="headerlink" title="📂 二、 集合框架 (Collections)"></a>📂 二、 集合框架 (Collections)</h2><h3 id="4-ArrayList-和-LinkedList-的区别"><a href="#4-ArrayList-和-LinkedList-的区别" class="headerlink" title="4. ArrayList 和 LinkedList 的区别"></a>4. ArrayList 和 LinkedList 的区别</h3><ul>
<li><strong>底层结构</strong>：<code>ArrayList</code> 是动态数组；<code>LinkedList</code> 是双向链表。</li>
<li><strong>随机访问</strong>：<code>ArrayList</code> 支持 $O(1)$ 的随机访问（通过下标）；<code>LinkedList</code> 需要 $O(n)$ 遍历。</li>
<li><strong>增删效率</strong>：<ul>
<li><code>ArrayList</code> 尾部增删快，但在中间增删需要数组扩容和内存拷贝，较慢。</li>
<li><code>LinkedList</code> 增删节点快（$O(1)$），但定位节点位置较慢。</li>
</ul>
</li>
<li><strong>内存空间</strong>：<code>ArrayList</code> 存在扩容时的预留空间浪费；<code>LinkedList</code> 每个节点需存储前后指针，单节点开销较大。</li>
</ul>
<h3 id="5-HashMap-的扩容原理"><a href="#5-HashMap-的扩容原理" class="headerlink" title="5. HashMap 的扩容原理"></a>5. HashMap 的扩容原理</h3><ul>
<li><strong>触发条件</strong>：当 <code>size &gt; capacity * loadFactor</code>（默认负载因子 0.75）时触发。</li>
<li><strong>过程</strong>：<ol>
<li>创建一个新的数组，容量是原来的 <strong>2倍</strong>。</li>
<li><strong>Rehash</strong>：将旧数组中的元素重新映射到新数组中。</li>
</ol>
</li>
<li><strong>JDK 1.8 优化</strong>：不需要重新计算 Hash，只需要判断原 Hash 值新增的那个 bit 是 0 还是 1，从而决定是在“原位置”还是“原位置 + 旧容量”。</li>
</ul>
<h3 id="6-7-HashMap-的-key-可以为空吗？若为空会怎么样？"><a href="#6-7-HashMap-的-key-可以为空吗？若为空会怎么样？" class="headerlink" title="6 &amp; 7. HashMap 的 key 可以为空吗？若为空会怎么样？"></a>6 &amp; 7. HashMap 的 key 可以为空吗？若为空会怎么样？</h3><ul>
<li><strong>回答</strong>：可以为空。</li>
<li><strong>处理机制</strong>：HashMap 会将 key 为 <code>null</code> 的元素存放在数组索引为 <strong>0</strong> 的位置（内部强制 hash 值为 0）。</li>
<li><strong>注意</strong>：只能有一个 key 为 <code>null</code>，但可以有多个 value 为 <code>null</code>。</li>
</ul>
<h3 id="8-Set-有了解吗，怎么保证数据不重复的？-重点"><a href="#8-Set-有了解吗，怎么保证数据不重复的？-重点" class="headerlink" title="8. Set 有了解吗，怎么保证数据不重复的？(重点)"></a>8. Set 有了解吗，怎么保证数据不重复的？(重点)</h3><ul>
<li><strong>底层实现</strong>：<code>HashSet</code> 底层其实就是一个 <code>HashMap</code>。数据存储在 HashMap 的 Key 上，Value 是一个固定的 <code>Object</code> 对象（PRESENT）。</li>
<li><strong>去重机制</strong>：<ol>
<li>计算元素的 <code>hashCode()</code>，定位到对应的桶（Bucket）。</li>
<li>如果桶无元素，直接存入。</li>
<li>如果桶有元素（Hash 冲突），调用 <code>equals()</code> 方法比较。</li>
<li>若 <code>equals()</code> 返回 true，视为重复，不添加；返回 false，则以链表&#x2F;红黑树形式追加。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="🚀-三、-并发编程-Concurrency"><a href="#🚀-三、-并发编程-Concurrency" class="headerlink" title="🚀 三、 并发编程 (Concurrency)"></a>🚀 三、 并发编程 (Concurrency)</h2><h3 id="9-进程和线程的区别"><a href="#9-进程和线程的区别" class="headerlink" title="9. 进程和线程的区别"></a>9. 进程和线程的区别</h3><ul>
<li><strong>定义</strong>：进程是<strong>资源分配</strong>的最小单位；线程是<strong>CPU调度</strong>的最小单位。</li>
<li><strong>关系</strong>：一个进程包含多个线程，线程共享进程的堆内存和方法区（元空间）。</li>
<li><strong>开销</strong>：进程切换开销大（独立内存空间），线程切换开销小。</li>
</ul>
<h3 id="10-操作系统的调度算法"><a href="#10-操作系统的调度算法" class="headerlink" title="10. 操作系统的调度算法"></a>10. 操作系统的调度算法</h3><ol>
<li><strong>先来先服务 (FCFS)</strong>。</li>
<li><strong>短作业优先 (SJF)</strong>。</li>
<li><strong>时间片轮转 (RR)</strong>（最常见，保证响应时间）。</li>
<li><strong>优先级调度</strong>。</li>
<li><strong>多级反馈队列调度</strong>。</li>
</ol>
<h3 id="11-Java-创建线程的方式"><a href="#11-Java-创建线程的方式" class="headerlink" title="11. Java 创建线程的方式"></a>11. Java 创建线程的方式</h3><ol>
<li>继承 <code>Thread</code> 类。</li>
<li>实现 <code>Runnable</code> 接口。</li>
<li>实现 <code>Callable</code> 接口（有返回值）。</li>
<li>使用线程池 (<code>ExecutorService</code>)。</li>
</ol>
<h3 id="12-Callable-和-Runnable-的区别"><a href="#12-Callable-和-Runnable-的区别" class="headerlink" title="12. Callable 和 Runnable 的区别"></a>12. Callable 和 Runnable 的区别</h3><ul>
<li><strong>返回值</strong>：<code>Runnable</code> 的 <code>run()</code> 返回 void；<code>Callable</code> 的 <code>call()</code> 有返回值（泛型）。</li>
<li><strong>异常</strong>：<code>Runnable</code> 不能抛出 Checked Exception；<code>Callable</code> 可以。</li>
<li><strong>执行</strong>：<code>Callable</code> 通常配合 <code>FutureTask</code> 或线程池使用，通过 <code>Future.get()</code> 获取结果。</li>
</ul>
<h3 id="13-线程池的核心参数"><a href="#13-线程池的核心参数" class="headerlink" title="13. 线程池的核心参数"></a>13. 线程池的核心参数</h3><ol>
<li><code>corePoolSize</code>：核心线程数（常驻）。</li>
<li><code>maximumPoolSize</code>：最大线程数。</li>
<li><code>keepAliveTime</code>：非核心线程空闲存活时间。</li>
<li><code>unit</code>：时间单位。</li>
<li><code>workQueue</code>：任务阻塞队列。</li>
<li><code>threadFactory</code>：线程工厂（用于命名线程等）。</li>
<li><code>handler</code>：拒绝策略（如 AbortPolicy, CallerRunsPolicy 等）。</li>
</ol>
<h3 id="14-线程池的-corePoolSize-大小的设置策略"><a href="#14-线程池的-corePoolSize-大小的设置策略" class="headerlink" title="14. 线程池的 corePoolSize 大小的设置策略"></a>14. 线程池的 corePoolSize 大小的设置策略</h3><ul>
<li><strong>CPU 密集型</strong>：CPU 核数 + 1（减少线程切换开销）。</li>
<li><strong>IO 密集型</strong>：CPU 核数 * 2 或 <code>CPU 核数 / (1 - 阻塞系数)</code>（因为 IO 操作不占用 CPU，可以多开线程）。</li>
</ul>
<hr>
<h2 id="☕-四、-JVM-Java-虚拟机"><a href="#☕-四、-JVM-Java-虚拟机" class="headerlink" title="☕ 四、 JVM (Java 虚拟机)"></a>☕ 四、 JVM (Java 虚拟机)</h2><h3 id="15-JVM-怎么判断对象是否是垃圾对象？"><a href="#15-JVM-怎么判断对象是否是垃圾对象？" class="headerlink" title="15. JVM 怎么判断对象是否是垃圾对象？"></a>15. JVM 怎么判断对象是否是垃圾对象？</h3><ul>
<li><strong>引用计数法</strong>（HotSpot 未采用）：有引用+1，失效-1。缺点：无法解决<strong>循环引用</strong>问题。</li>
<li><strong>可达性分析法</strong>（主流）：从 <strong>GC Roots</strong>（如栈帧中的局部变量、静态变量、常量引用等）出发，搜索引用的对象链。搜索不到的对象即为垃圾。</li>
</ul>
<h3 id="16-垃圾收集算法有哪些？"><a href="#16-垃圾收集算法有哪些？" class="headerlink" title="16. 垃圾收集算法有哪些？"></a>16. 垃圾收集算法有哪些？</h3><ol>
<li><strong>标记-清除 (Mark-Sweep)</strong>：容易产生内存碎片。</li>
<li><strong>标记-复制 (Copying)</strong>：新生代常用，效率高但浪费一半空间。</li>
<li><strong>标记-整理 (Mark-Compact)</strong>：老年代常用，解决碎片问题。</li>
<li><strong>分代收集</strong>：根据对象存活周期不同，新生代用复制算法，老年代用标记-整理算法。</li>
</ol>
<h3 id="17-对-Java-内存模型-JMM-有了解吗？"><a href="#17-对-Java-内存模型-JMM-有了解吗？" class="headerlink" title="17. 对 Java 内存模型 (JMM) 有了解吗？"></a>17. 对 Java 内存模型 (JMM) 有了解吗？</h3><ul>
<li><strong>目的</strong>：屏蔽硬件差异，解决并发中的<strong>原子性、可见性、有序性</strong>问题。</li>
<li><strong>结构</strong>：主内存（共享数据） vs 工作内存（线程私有缓存）。</li>
<li><strong>核心关键字</strong>：<ul>
<li><code>volatile</code>：保证可见性、禁止指令重排（有序性）。</li>
<li><code>synchronized</code>：保证原子性、可见性、有序性。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="💾-五、-数据库与中间件-MySQL-Redis"><a href="#💾-五、-数据库与中间件-MySQL-Redis" class="headerlink" title="💾 五、 数据库与中间件 (MySQL &amp; Redis)"></a>💾 五、 数据库与中间件 (MySQL &amp; Redis)</h2><h3 id="18-对-MySQL-中索引的理解、索引的分类"><a href="#18-对-MySQL-中索引的理解、索引的分类" class="headerlink" title="18. 对 MySQL 中索引的理解、索引的分类"></a>18. 对 MySQL 中索引的理解、索引的分类</h3><ul>
<li><strong>理解</strong>：索引是帮助快速查找数据的排好序的数据结构（通常是 <strong>B+树</strong>）。</li>
<li><strong>分类</strong>：<ul>
<li><strong>物理存储</strong>：聚簇索引（数据和索引在一起，如主键）、非聚簇索引（二级索引，叶子节点存主键）。</li>
<li><strong>逻辑约束</strong>：主键索引、唯一索引、普通索引、全文索引。</li>
<li><strong>字段个数</strong>：单列索引、联合索引（需遵循<strong>最左前缀原则</strong>）。</li>
</ul>
</li>
</ul>
<h3 id="19-Redis-数据结构有哪几种，应用场景？"><a href="#19-Redis-数据结构有哪几种，应用场景？" class="headerlink" title="19. Redis 数据结构有哪几种，应用场景？"></a>19. Redis 数据结构有哪几种，应用场景？</h3><ol>
<li><strong>String</strong>：缓存、计数器、分布式锁、Session 共享。</li>
<li><strong>List</strong>：消息队列、最新动态（时间轴）。</li>
<li><strong>Hash</strong>：存储对象（如用户信息、购物车）。</li>
<li><strong>Set</strong>：去重、抽奖、共同好友（交集操作）。</li>
<li><strong>ZSet (Sorted Set)</strong>：排行榜、带权重的队列。</li>
</ol>
<hr>
<h2 id="🔒-六、-高级并发与锁"><a href="#🔒-六、-高级并发与锁" class="headerlink" title="🔒 六、 高级并发与锁"></a>🔒 六、 高级并发与锁</h2><h3 id="20-阻塞队列和非阻塞队列的区别"><a href="#20-阻塞队列和非阻塞队列的区别" class="headerlink" title="20. 阻塞队列和非阻塞队列的区别"></a>20. 阻塞队列和非阻塞队列的区别</h3><ul>
<li><strong>阻塞队列</strong>（如 <code>ArrayBlockingQueue</code>）：基于锁和等待&#x2F;通知机制。当队列满时写阻塞，空时读阻塞。常用于生产者-消费者模型。</li>
<li><strong>非阻塞队列</strong>（如 <code>ConcurrentLinkedQueue</code>）：基于 <strong>CAS</strong> 机制（无锁），操作立即返回或重试，高并发下性能更好，但 CPU 开销可能较大。</li>
</ul>
<h3 id="21-CAS-的原理及其应用场景"><a href="#21-CAS-的原理及其应用场景" class="headerlink" title="21. CAS 的原理及其应用场景"></a>21. CAS 的原理及其应用场景</h3><ul>
<li><strong>原理</strong>：<strong>Compare And Swap</strong>（比较并交换）。包含三个操作数：内存地址 V、预期原值 A、新值 B。只有当 V&#x3D;&#x3D;A 时，才将 V 更新为 B。</li>
<li><strong>场景</strong>：<code>AtomicInteger</code> 等原子类、自旋锁、并发容器。</li>
</ul>
<h3 id="22-ABA-问题及其解决方法"><a href="#22-ABA-问题及其解决方法" class="headerlink" title="22. ABA 问题及其解决方法"></a>22. ABA 问题及其解决方法</h3><ul>
<li><strong>问题</strong>：值从 A 变为 B 又变回 A，CAS 检查时以为没变，实际中间经历了变化。</li>
<li><strong>解决</strong>：增加<strong>版本号</strong>（<code>AtomicStampedReference</code>），比较时同时比较值和版本号。</li>
</ul>
<h3 id="23-进程级别的锁解决的是什么问题？"><a href="#23-进程级别的锁解决的是什么问题？" class="headerlink" title="23. 进程级别的锁解决的是什么问题？"></a>23. 进程级别的锁解决的是什么问题？</h3><ul>
<li><strong>指代</strong>：<code>synchronized</code> 或 <code>ReentrantLock</code>。</li>
<li><strong>解决</strong>：<strong>单个 JVM 进程内</strong>，多线程访问共享资源的数据一致性问题。</li>
</ul>
<h3 id="24-分布式锁解决的什么问题？"><a href="#24-分布式锁解决的什么问题？" class="headerlink" title="24. 分布式锁解决的什么问题？"></a>24. 分布式锁解决的什么问题？</h3><ul>
<li><strong>解决</strong>：<strong>跨进程&#x2F;跨服务器</strong>（集群环境）下，多个服务同时访问共享资源（如数据库、Redis）的一致性问题。</li>
<li><strong>实现</strong>：Redis (<code>setnx</code> + lua), Zookeeper (临时顺序节点), Redisson。</li>
</ul>
<h3 id="25-MySQL-中-InnoDB-引擎中行级锁的类型"><a href="#25-MySQL-中-InnoDB-引擎中行级锁的类型" class="headerlink" title="25. MySQL 中 InnoDB 引擎中行级锁的类型"></a>25. MySQL 中 InnoDB 引擎中行级锁的类型</h3><ol>
<li><strong>Record Lock</strong>：锁记录本身。</li>
<li><strong>Gap Lock</strong>：间隙锁，锁范围，防止幻读。</li>
<li><strong>Next-Key Lock</strong>：Record + Gap，默认隔离级别（RR）下使用。</li>
</ol>
<h3 id="26-MySQL-中锁和事务是否有相关性？"><a href="#26-MySQL-中锁和事务是否有相关性？" class="headerlink" title="26. MySQL 中锁和事务是否有相关性？"></a>26. MySQL 中锁和事务是否有相关性？</h3><ul>
<li><strong>强相关</strong>。</li>
<li>事务的<strong>隔离性 (Isolation)</strong> 主要就是通过<strong>锁机制</strong>（配合 MVCC）来实现的。事务提交或回滚时才会释放锁。</li>
</ul>
<h3 id="27-死锁是什么？"><a href="#27-死锁是什么？" class="headerlink" title="27. 死锁是什么？"></a>27. 死锁是什么？</h3><ul>
<li><strong>定义</strong>：两个或多个线程互相持有对方需要的资源，并等待对方释放，导致无限期等待。</li>
<li><strong>四个必要条件</strong>：互斥、占有且等待、不可抢占、循环等待。</li>
</ul>
<hr>
<h2 id="🌿-七、-Spring-框架与-AOP"><a href="#🌿-七、-Spring-框架与-AOP" class="headerlink" title="🌿 七、 Spring 框架与 AOP"></a>🌿 七、 Spring 框架与 AOP</h2><h3 id="28-Spring-中-AOP-代理分为几大类和区别？"><a href="#28-Spring-中-AOP-代理分为几大类和区别？" class="headerlink" title="28. Spring 中 AOP 代理分为几大类和区别？"></a>28. Spring 中 AOP 代理分为几大类和区别？</h3><ol>
<li><strong>JDK 动态代理</strong>：基于接口实现，只能代理实现了接口的类。</li>
<li><strong>CGLIB 动态代理</strong>：基于继承实现，通过 ASM 字节码技术生成子类，不能代理 <code>final</code> 类。</li>
</ol>
<ul>
<li><em>注：Spring Boot 2.x 后默认倾向于使用 CGLIB。</em></li>
</ul>
<h3 id="29-自己有没有使用过代理来完成业务开发？"><a href="#29-自己有没有使用过代理来完成业务开发？" class="headerlink" title="29. 自己有没有使用过代理来完成业务开发？"></a>29. 自己有没有使用过代理来完成业务开发？</h3><ul>
<li><strong>回答思路</strong>：除了使用框架特性，自己可能写过：<ul>
<li><strong>拦截器 (Interceptor)</strong> 或 <strong>过滤器 (Filter)</strong>。</li>
<li><strong>自定义注解 + AOP 切面</strong>：用于实现统一日志记录、接口权限校验、全局异常处理、方法耗时统计等。</li>
</ul>
</li>
</ul>
<h3 id="30-Spring-框架里用到-AOP-的地方"><a href="#30-Spring-框架里用到-AOP-的地方" class="headerlink" title="30. Spring 框架里用到 AOP 的地方"></a>30. Spring 框架里用到 AOP 的地方</h3><ul>
<li><strong>声明式事务</strong> (<code>@Transactional</code>)。</li>
<li><strong>Spring Security</strong> (权限控制)。</li>
<li><strong>统一缓存</strong> (<code>@Cacheable</code>)。</li>
<li><strong>统一日志</strong>。</li>
</ul>
<hr>
<h2 id="📈-八、-开放性问题-Personal-Growth"><a href="#📈-八、-开放性问题-Personal-Growth" class="headerlink" title="📈 八、 开放性问题 (Personal Growth)"></a>📈 八、 开放性问题 (Personal Growth)</h2><h3 id="31-平时自身成长通过哪些途径进行学习？"><a href="#31-平时自身成长通过哪些途径进行学习？" class="headerlink" title="31. 平时自身成长通过哪些途径进行学习？"></a>31. 平时自身成长通过哪些途径进行学习？</h3><ul>
<li><strong>官方文档</strong>（最权威）。</li>
<li><strong>技术社区</strong>：掘金、CSDN、StackOverflow、V2EX。</li>
<li><strong>源码阅读</strong>：GitHub 上阅读优秀开源项目（如 Spring, MyBatis, Netty）。</li>
<li><strong>书籍</strong>：《深入理解Java虚拟机》、《Java并发编程实战》、《高性能MySQL》等。</li>
<li><strong>视频课程</strong>：B站、Coursera、极客时间。</li>
</ul>
<h3 id="32-有没有参加过一些开源的社区？"><a href="#32-有没有参加过一些开源的社区？" class="headerlink" title="32. 有没有参加过一些开源的社区？"></a>32. 有没有参加过一些开源的社区？</h3><ul>
<li><strong>诚实作答</strong>。</li>
<li><strong>如果有</strong>：提到具体的 PR (Pull Request) 或 Issue 经历。</li>
<li><strong>如果没有</strong>：可以这样说：“虽然还没有提交过代码，但我经常在 GitHub 上阅读开源项目源码，并关注 Issues 区的讨论，学习开发者解决 bug 和设计架构的思路。”</li>
</ul>
<hr>
<h3 id="💡-复习建议"><a href="#💡-复习建议" class="headerlink" title="💡 复习建议"></a>💡 复习建议</h3><p>面试时不要死记硬背，建议结合<strong>自己的项目经验</strong>，用自己的话把技术原理讲出来。遇到不会的问题（如具体算法细节），可以尝试关联到相关的知识点，或者诚实回答并表示出学习意愿。祝面试顺利！</p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 UNCEIR的个人博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;David Huang
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
