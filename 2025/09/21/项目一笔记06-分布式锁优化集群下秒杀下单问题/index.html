
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>项目一笔记06：分布式锁优化集群下秒杀下单问题 | UNCEIR的个人博客</title>
    <meta name="author" content="David Huang" />
    <meta name="description" content="广东工业大学信息管理与信息系统专业的一名大三学生，未来想从事后端开发，请多指教。" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>UNCEIR的个人博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;UNCEIR的个人博客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>项目一笔记06：分布式锁优化集群下秒杀下单问题</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/21
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <h4 id="集群下的环境条件改变"><a href="#集群下的环境条件改变" class="headerlink" title="集群下的环境条件改变"></a>集群下的环境条件改变</h4><h5 id="synchronized的局限性"><a href="#synchronized的局限性" class="headerlink" title="synchronized的局限性"></a>synchronized的局限性</h5><ul>
<li>当出现多个服务器集群时，不同端口的服务同时进行着，多用户重复下单就会依然存在着。这是由于synchronized是本地锁，只能提供线程级别的同步，<strong>每个JVM中都有一把synchronized锁，不能跨 JVM 进行上锁</strong>，当一个线程进入被 synchronized 关键字修饰的方法或代码块时，它会尝试获取对象的内置锁（也称为监视器锁）。如果该锁没有被其他线程占用，则当前线程获得锁，可以继续执行代码；否则，当前线程将进入阻塞状态，直到获取到锁为止。而多个节点也就意味着有多个JVM进程，所以synchronized会失效！</li>
</ul>
<h5 id="使用分布式锁"><a href="#使用分布式锁" class="headerlink" title="使用分布式锁"></a>使用分布式锁</h5><ul>
<li><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁</p>
<ul>
<li>前面sychronized锁失效的原因是由于每一个JVM都有一个独立的锁监视器，用于监视当前JVM中的sychronized锁，所以无法保障多个集群下只有一个线程访问一个代码块。所以我们直接将使用一个分布锁，在整个系统的全局中设置一个锁监视器，从而保障不同节点的JVM都能够识别，从而实现集群下只允许一个线程访问一个代码块。</li>
</ul>
</li>
<li><p>分布式锁的特点：</p>
<ul>
<li><strong>多线程可见</strong></li>
<li><strong>互斥</strong>。分布式锁必须能够确保在任何时刻只有一个节点能够获得锁，其他节点需要等待。</li>
<li><strong>高可用</strong>。分布式锁应该具备高可用性，即使在网络分区或节点故障的情况下，仍然能够正常工作。（容错性）当持有锁的节点发生故障或宕机时，系统需要能够自动释放该锁，以确保其他节点能够继续获取锁。</li>
<li><strong>高性能</strong>。分布式锁需要具备良好的性能，尽可能减少对共享资源的访问等待时间，以及减少锁竞争带来的开销。</li>
<li><strong>安全性</strong>。（可重入性）如果一个节点已经获得了锁，那么它可以继续请求获取该锁而不会造成死锁。（锁超时机制）为了避免某个节点因故障或其他原因无限期持有锁而影响系统正常运行，分布式锁通常应该设置超时机制，确保锁的自动释放。</li>
</ul>
</li>
<li><p>分布式锁的常见实现方式：</p>
<ul>
<li><p><strong>基于关系数据库</strong>：可以利用数据库的事务特性和唯一索引来实现分布式锁。通过向数据库插入一条具有唯一约束的记录作为锁，其他进程在获取锁时会受到数据库的并发控制机制限制。</p>
</li>
<li><p><strong>基于缓存</strong>：使用分布式缓存服务（如Redis）提供的原子操作来实现分布式锁。通过将锁信息存储在缓存中，其他进程可以通过检查缓存中的锁状态来判断是否可以获取锁。</p>
</li>
<li><p><strong>基于ZooKeeper</strong>：ZooKeeper是一个分布式协调服务，可以用于实现分布式锁。通过创建临时有序节点，每个请求都会尝试创建一个唯一的节点，并检查自己是否是最小节点，如果是则表示获取到了锁。</p>
</li>
<li><p><strong>基于分布式算法</strong>：还可以利用一些分布式算法来实现分布式锁，例如Chubby、DLM（Distributed Lock Manager）等。这些算法通过在分布式系统中协调进程之间的通信和状态变化，实现分布式锁的功能。</p>
</li>
</ul>
</li>
<li><p>setnx指令的特点：setnx只能设置key不存在的值，值不存在设置成功，返回 1 ；值存在设置失败，返回 0</p>
</li>
</ul>
<h4 id="分布式锁对相关集群超卖问题的优化"><a href="#分布式锁对相关集群超卖问题的优化" class="headerlink" title="分布式锁对相关集群超卖问题的优化"></a>分布式锁对相关集群超卖问题的优化</h4><ul>
<li><p><strong>相关问题和对应优化</strong>：</p>
<ul>
<li>1.实现了一个简单的分布式锁，但是会存在一个问题：当线程1获取锁后，由于业务阻塞，线程1的锁超时释放了，这时候线程2趁虚而入拿到了锁，然后此时线程1业务完成了，然后把线程2刚刚获取的锁给释放了，这时候线程3又趁虚而入拿到了锁，这就导致又出现了超卖问题！（但是这个在小项目（并发数不高）中出现的概率比较低，在大型项目（并发数高）情况下是有一定概率的）<strong>因此要为分布式锁添加一个线程标识，在释放锁时判断当前锁是否是自己的锁，是自己的就直接释放，不是自己的就不释放锁，从而解决多个线程同时获得锁的情况导致出现超卖</strong>。</li>
<li>2.虽然但是，上述情况虽然得到优化了，但是在高并发量的场景下下述例子概率任然有：当线程1获取锁，执行完业务然后并且判断完当前锁是自己的锁时，但就在此时发生了阻塞，结果锁被超时释放了，线程2立马就趁虚而入了，获得锁执行业务，但就在此时线程1阻塞完成，由于已经判断过锁，已经确定锁是自己的锁了，于是直接就删除了锁，结果删的是线程2的锁，这就又导致线程3趁虚而入了，从而继续发生超卖问题。</li>
<li>问题二的解决方案：该问题的关键之处在于，无法保证<strong>判断是自己锁</strong>和<strong>释放锁</strong>之间代码的原子性。<br>那么如何保障<strong>判断是自己锁</strong>和<strong>释放锁</strong>之间代码的原子性呢？答案便是使用<strong>Lua脚本</strong>。<ul>
<li><p>那么Lua脚本是如何确保原子性的呢？Redis使用（支持）相同的Lua解释器，来运行所有的命令。Redis还保证脚本以原子方式执行：在执行脚本时，不会执行其他脚本或Redis命令。这个语义类似于MULTI（开启事务）&#x2F;EXEC（触发事务，一并执行事务中的所有命令）。从所有其他客户端的角度来看，脚本的效果要么仍然不可见，要么已经完成。Redis自身的MULTI&#x2F;EXEC 并不是传统数据库那种完整的事务——它只能把命令打包顺序执行，但不能在服务器端用“读的结果”做条件分支、不能回滚错误、也不能保证像数据库那样的隔离&#x2F;一致性语义。而使用Lua脚本可以先在脚本里先 GET，再判断，然后 SET&#x2F;DEL —— 并且整段脚本在 Redis 内被当作一个命令执行，中途不会插入别的客户端命令，因此读写判断能完全原子化。实现获取读值以后并决定后续操作的这一需求。</p>
<ul>
<li>介绍一下MULTI&#x2F;EXEC 的工作机制：</li>
<li>MULTI：告诉 Redis 开始一个事务，会把后续命令 队列化（queued），不会立即执行。</li>
<li>在事务中发出的命令，客户端会收到 QUEUED（而不是命令实际的返回值）。</li>
<li>EXEC：一次性按顺序在服务器上执行之前队列的命令。</li>
<li>特点：在 EXEC 执行期间，Redis 单线程会顺序执行这些命令，外部命令不会插入到这批命令中间。</li>
<li>重要限制：在 MULTI 阶段你无法得到某个命令的回传结果来决定下一个命令（因为所有命令只是被排队），所以客户端不能做“基于读结果做复杂逻辑然后决定后续命令”的单次事务。</li>
</ul>
</li>
<li><p><strong>注意</strong>：虽然Redis在单个Lua脚本的执行期间会暂停其他脚本和Redis命令，以确保脚本的执行是原子的，但如果Lua脚本本身出错，那么无法完全保证原子性。也就是说Lua脚本中的Redis指令出错，会发生回滚以确保原子性，但Lua脚本本身出错就无法保障原子性。</p>
</li>
<li><p>Lua脚本的代码业务：</p>
<ul>
<li>获取锁中的线程标示</li>
<li>判断是否与指定的标示（当前线程标示）一致</li>
<li>如果一致则释放锁（删除）</li>
<li>如果不一致则什么都不做</li>
<li>传值：RedisTemplate使用execute这一api调用Lua脚本</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>现在我们的分布式锁满足了：</p>
<ul>
<li><strong>多线程可见</strong>，将锁放到Redis中，所有的JVM都可以同时看到</li>
<li><strong>互斥</strong>，set ex nx指令互斥</li>
<li><strong>高可用</strong>，层层优化，即使是特别极端的情况下照样可以防止超卖</li>
<li><strong>高性能</strong>，Redis的IO速度很快，Lua脚本的性能也很快</li>
<li><strong>安全性</strong>，通过给锁夹线程标识+Lua封装Redis指令充分保障了线程安全，不那么容易出现并发安全问题，同时采用超时释放避免死锁。</li>
</ul>
</li>
<li><p>经过优化1和优化2，我们实现的分布式锁已经达到生产可用级别了，但是还不够完善，比如：</p>
<ul>
<li><p>分布式锁<strong>不可重入</strong>：不可重入是指同一线程不能重复获取同一把锁。比如，方法A中调用方法B，方法A需要获取分布式锁，方法B同样需要获取分布式锁，线程1进入方法A获取了一次锁，进入方法B又获取一次锁，由于锁不可重入，所以就会导致死锁。</p>
</li>
<li><p>分布式锁<strong>不可重试</strong>：获取锁只尝试一次就返回false，没有重试机制，这会导致数据丢失，比如线程1获取锁，然后要将数据写入数据库，但是当前的锁被线程2占用了，线程1直接就结束了而不去重试，这就导致数据发生了丢失。</p>
</li>
<li><p>分布式锁<strong>超时释放</strong>：超时释放机机制虽然一定程度避免了死锁发生的概率，但是如果业务执行耗时过长，期间锁就释放了，这样存在安全隐患。锁的有效期过短，容易出现业务没执行完就被释放，锁的有效期过长，容易出现死锁，所以这是一个大难题！（（（感觉像套娃</p>
</li>
<li><p><strong>主从一致性问题</strong>：如果Redis提供了主从集群，主从同步存在延迟，线程1获取了锁写操作写入到Redis集群中的主服务器，此时从节点还没读取主服务器就宕机了，从节点通过哨兵机制选出新的主服务器又可以获取锁，锁就相当于失效。</p>
</li>
</ul>
</li>
<li><p>因此，我们这里便使用Redssion，Redssion是一个十分成熟的Redis框架，功能也很多，比如：分布式锁和同步器、分布式对象、分布式集合、分布式服务，各种Redis实现分布式的解决方案。简而言之Redisson就是一个使用Redis解决分布式问题的方案的集合，当然它不仅仅是解决分布式相关问题，还包含其它的一些问题。（ 感觉前面白雪了，这里全封装好了）</p>
</li>
<li><p><strong>Redisson分布式锁原理</strong>:</p>
<ul>
<li><p><strong>如何解决可重入问题</strong>：利用hash结构记录线程id和重入次数。</p>
</li>
<li><p><strong>如何解决可重试问题</strong>：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制。</p>
</li>
<li><p><strong>如何解决超时续约问题</strong>：利用watchDog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间。</p>
</li>
<li><p><strong>如何解决主从一致性问题</strong>：利用Redisson的multiLock，多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功。<br>  缺陷：运维成本高、实现复杂</p>
</li>
</ul>
</li>
</ul>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 UNCEIR的个人博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;David Huang
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
